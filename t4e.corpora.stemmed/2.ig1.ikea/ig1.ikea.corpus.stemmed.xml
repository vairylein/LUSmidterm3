<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE course SYSTEM "corpus.dtd"><course id="C2" title="Informatica Generale 1" lang="IT"><lecture id="L36" title="Gestione dei File, Ricorsione" date="2013-11-11"><question id="QQ3372"><question_text>qual&#39; è l&#39; util acced fil manier casual ? </question_text><answer id="A3288"><answer_text>l util acced fil manier casual sta&#39; fatt è possibil legg scriv i dat qualsias ordin . (con i fil sequenzial è sempr necessar part ?iniz fil proced ordin scansion attravers fil ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3418"><answer_text>l&#39; access casual fil permett acced conten specific posizion relat intern . </answer_text><num_votes>0</num_votes></answer><answer id="A3326"><answer_text>l&#39; util risied fatt moment dell&#39; apertur fil (open ) verr inizializz indic posizion fil . </answer_text><num_votes>0</num_votes></answer><answer id="A3335"><answer_text>l&#39; util acced fil mod casual , sta fatt poter acced conten fil più veloc mod sequenzial , quant si offset consent spost all&#39; intern fil , part necessar dall&#39; iniz , part posizion si desider . quest funzional risult particolar util si vuol acced mod rapid comod conten fil particolar grand . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ3371"><question_text>qual funzion i fluss veng apert moment dell&#39; esecu programm ? </question_text><answer id="A3291"><answer_text>stdout , stderr stdin . i prim assoc vide terminal , l&#39; tastier . stdin serv mand programm i dat input , stdout serv programm ritorn i dat output . stderr è fluss output è specif i messagg d&#39; error . </answer_text><num_votes>1</num_votes></answer><answer id="A3398"><answer_text>i fluss veng apert all&#39; iniz programm general standard input/output (&#60; stdi .h&#62; ) . standard input permett programm acquis fluss dat input tastier attravers oper lettur , standard output permett programm , attravers un&#39; oper scrittur , gener output . com esemp si può prend consider l&#39; oper cin , cout c++ </answer_text><num_votes>1</num_votes></answer><answer id="A3328"><answer_text>moment esecu programm veng apert fluss (streams ) standard : assoc vide terminal : - stdout - stderr assoc tastier : - stdin (funzion printf or scanf usan quest fluss ) </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3290"><question_text>serv aprir modal binar lettura/scrittur fil ? </question_text><answer id="A3363"><answer_text>semplic è mod poter cap numer vien scritt fil . chiar è util cas sian utilizz valor boolena , quant è scomod lettur sequenz valor com 00011101 qual non si cap nient ! </answer_text><num_votes>3</num_votes></answer><answer id="A3273"><answer_text>aprir fil mod si poss legg scriv , si pass com string modal funzion fopen string &#34; r+ &#34; . legg si usa com sol funzion fread mentr scriv si usa funzion fwritef . legg scriv richied per introdurr concett posizion corrent all&#39; intern fil . rend different vettor caratter è fatt disposit è memorizz è disc memor primar . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3387"><question_text>com si poss defin cas bas cas indutt ? com si risolv cas indutt ? </question_text><answer id="A3407"><answer_text>cas bas è quand cert problem può esser risolt dirett ricorsion , mentr cas indutt è quand si bisogn ser passagg arriv soluzion problem . risolv metod indutt si divid problem problem più piccol (suppon sap risolv ) poi tram calcol si arriv soluzion problem principal . </answer_text><num_votes>1</num_votes></answer><answer id="A3297"><answer_text>cas bas rappresent class istanz sufficient piccol (=semplic ) poter esser risolt manier diretta(=sent ricorsion ) . cas indutt ,cio class istanz rimanent , si prest esser risolt mediant seguent proced : si estragg dall&#39; istanz pres consider più istanz problem più piccol quell partenz , poi si suppon risolv dirett istanz (in realt è proced ricors ) infin compong var soluzion mod form soluzion quell partenz . </answer_text><num_votes>0</num_votes></answer><answer id="A3426"><answer_text>cas bas stud risolu problem manier dirett , ricorsion (ad es . x val 0 ) ; cas indutt ved risolu problem attravers determin proced ricors (ad es . x val n n+1 ) . sostanz si può afferm cas bas è cas particol cas indutt . risolv cas indutt si suddivid problem part (istanz ) più semplic mod pot risolv dirett success si unisc soluzion otten perven soluzion problem partenz . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3316"><question_text>si intend ricorsion dirett indirett ? </question_text><answer id="A3351"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3347"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3353"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3344"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3348"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3354"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3341"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3345"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3349"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3352"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3342"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3350"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3343"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>2</num_votes></answer><answer id="A3340"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3338"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3339"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3346"><answer_text>funzion ricors è funzion richiam sè stess (ricorsion dirett ) richiam funzion volt richiam (ricorsion indirett ) . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3304"><question_text>qual è dimostr utilizz calcol convergent dell&#39; algoritm merg sort ? </question_text><answer id="A3393"><answer_text>l&#39; algoritm merg sort , ordin sequenz &#34; n &#34; oggett , compless t(n ) = o(n\log n ) cas med cas pessim . infatt funzion merg compless o(n ) , inoltr essa richiam stess , ogni volt (circ ) met sequenz input . segu esecu dell&#39; algoritm è dat ricorrent : t(n ) = 2t (n/2 ) + (n ) soluzion è propr o(n \log n ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3366"><answer_text>chiam t(n ) numer vis necessar ordin array n element . mergesort : t(n ) =2t (n/2 ) + 5n sap l&#39; algoritm divid 2 l&#39; array,l formul divent : t(n/2 ) =2t (n/4 ) + 5 (n/2 ) , t(n ) =2*2t (n/4 ) + 5n+5n . divid ulterior : t (n/4 ) =2t (n/8 ) + 5 (n/4 ) t(n ) =2*2*2t (n/8 ) + 5n+5n+5n . scriv 2,4,8 com potenz arbitrar 2 : t(n ) =2^ ( k ) t (n/2^ ( k ) ) + 5nk . assum n=2^ ( m ), k=m : t (n ) =2^ ( m ) t (n/2^ ( m ) ) + 5nm = nt (1 ) + 5nm =n+5n log(2 ) ( n ) ( dat n=2^ ( m ) implic m=log(2 ) ( n ) ) . cresc funzion tralasc grad n,valor costant base2 log . ordinamento= o(nlog(n ) ) </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3431"><question_text>l&#39; utilizz ricorsion richied uso maggior risors comput memor ? perc ? </question_text><answer id="A3308"><answer_text>ricorsion gener massicc occup stack , quant ogni chiam funzion è necessar risolu problem produc risult vien memorizz . ricorsion impegn fortement processor , popol distrugg stack . conseguent , funzion implement ricors , potrebber dar problem termin esecu . </answer_text><num_votes>2</num_votes></answer><answer id="A3376"><answer_text>ricorsion , sebben port vantagg scrittur codic , prestazion vantagg . essa gener un&#39; enorm quantit dat occup gran part memor . infatt i dat veng richiam funzion occup stack processor vien richiam caus ogni qual volt è modif esso . </answer_text><num_votes>0</num_votes></answer><answer id="A3311"><answer_text>ricorsion permett utilizz più efficient memor dunqu richied uso spess minor . infatt ricorsion si utilizz memor memor stack più memor heap è dinam dunqu non alloc mod permanent variabil possibil programm utilizz men cell memor esser dunqu più veloc nell&#39; esecu . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3374"><question_text>può succed fil quand programm termin inaspettat (crash ) ? </question_text><answer id="A3286"><answer_text>quand apriam fil , far sì fluss dat vogl inser veng scritt ,è necessar chiud tram appos com &#34; fclos ( ) &#34; oppur automat termin programm (fin main exit ) .se programm qualc mot dovess interromp inaspettat fil non verrebb chius fluss dat non è dett verrebb scritt intern conseguent potr perd dat . </answer_text><num_votes>2</num_votes></answer><answer id="A3290"><answer_text>quand programm termin inaspettat non vien esegu l&#39; oper &#34; fclos &#34; , salv fil i dat present buffer termin l&#39; assoc fluss dat perifer , i dat rimast buffer vann persi; poss comunqu verific effett collateral addirittur perd fil . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ3396"><question_text>funzion ricors può esser sempr scritt mod non ricors lim ? </question_text><answer id="A3317"><answer_text>funzion ricors può esser scritt mod non ricors ; per non port vantagg , anzi &#34; complic &#34; l&#39; algoritm . </answer_text><num_votes>0</num_votes></answer><answer id="A3412"><answer_text>funzion ricors scritt mod non ricors , vien defin iter , cio scritt attravers cicl . sfortunat , non tutt funzion facil &#39;trasform &#39; ricors non-ricors , alcun cas funzion non può esser trasform complet riscrittur , non sempr val pen . bisogn inoltr osserv funzion iter potent , larg applic , spess efficient poss risult artific , leggibil difficil comprend . </answer_text><num_votes>2</num_votes></answer><answer id="A3416"><answer_text>si puo scriv non usand ricorsion complic codic scriv . esemp : alcun funzion &#34; semplic &#34; bast utilizz banal cicl elimin l&#39; utilizz ricorsion . funzion compless elimin metod non ricors e&#39; compless possibil . esemp pratic puo esser funzion fattorial ricors : int fattric(int n ) { int ris; if (n == 0 ) ris = 1; else ris = n * fattric(n ?1 ) ; return ris; } non ricors : int fattric(int n ) { int i , ris; ris=1 ; for (i=1;i&#60;=n ;i++ ) ris = ris *i ; } return ris; } </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3362"><question_text>qual&#39; è different printf fprintf ? </question_text><answer id="A3274"><answer_text>printf ( ) è funzion conten librer &#34; stdi .h &#34; permett stamp (visualizz ) vide (in &#34; consol application &#34; ) ciò vien pass com parametr , fprintf ( ) è funzion permett scrittur (inser ) fil ciò vien pass com parametr . different funzion printf ( ) , fprintf ( ) richied , inform stamp , puntator fil destin . </answer_text><num_votes>0</num_votes></answer><answer id="A3275"><answer_text>entramb funzion conten librer &#34; stdi .h &#34; . printf ( ) permett stamp (visualizz ) vide , &#34; consol application &#34; , ciò vien pass com parametr , fprintf ( ) permett scrittur (inser ) fil ciò vien pass com parametr . different funzion printf ( ) , fprintf ( ) richied , inform stamp , puntator fil destin . </answer_text><num_votes>1</num_votes></answer><answer id="A3276"><answer_text>entramb funzion conten librer &#34; stdi .h &#34; . printf ( ) permett stamp (visualizz ) vide , &#34; consol application &#34; , ciò vien pass com parametr , fprintf ( ) permett scrittur (inser ) fil ciò vien pass com parametr . different funzion printf ( ) , fprintf ( ) richied , inform stamp , puntator fil destin . </answer_text><num_votes>1</num_votes></answer><answer id="A3292"><answer_text>funzion printf vien utilizz visualizz standard output string costru bas form specific . fprintf è funzion deriv printf permett scrittur dell&#39; output fil . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3334"><question_text>qual i vantagg uso funzion ricors ? si intend &#34; cas bas &#34; ? ricorsion è sempr utilizz ? </question_text><answer id="A3405"><answer_text>funzion si dic ricors quand è defin seguent schem : -un più cas base,in è defin termin funzion più semplic not -un cas ricors l&#39; utilizz funzion ricors vantagg principal : permett scriv poch line codic risolv problem compless .tuttav ricorsion non è sempr utilizz poic comport elev consum stack sistem stiam lavor stack limit risc crash programm . p.s : c&#39; scritt ask question dev domand non 3 </answer_text><num_votes>4</num_votes></answer><answer id="A3379"><answer_text>i vantagg si può ridurr problem &#34; difficil &#34; , ser problem più &#34; semplic &#34; . quest problem più semplic dev esser il/i caso/ bas . cas bas problem si conosc facil soluzion . ricorsion non è sempr utilizz , maggior part è integr . </answer_text><num_votes>0</num_votes></answer><answer id="A3380"><answer_text>i vantagg si può ridurr problem &#34; difficil &#34; , ser problem più &#34; semplic &#34; . quest problem più semplic dev esser il/i caso/ bas . cas bas problem si conosc facil soluzion . ricorsion non è sempr utilizz , maggior part è integr . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3401"><question_text>qual&#39; è ruol buffer sistem process scrittur fil ? </question_text><answer id="A3392"><answer_text>buffer sistem serv memorizz mod temporane i fil scrittur cos poi quest poss esser manipol . </answer_text><num_votes>1</num_votes></answer><answer id="A3419"><answer_text>quand facc un&#39; oper scrittur fil scriv i dat conten buffer indic fil sto lavor </answer_text><num_votes>0</num_votes></answer><answer id="A3382"><answer_text>buffer contien i dat verrann poi salv com fclos fil precedent dichiar . infatt dann provoc non utilizz com fclos è perd dat . import usarl . </answer_text><num_votes>1</num_votes></answer><answer id="A3365"><answer_text>confront memor central , unit memor mass richied temp access scrittur elev . ruol buffer sistem (are memor central vien memorizz stream dat prim esser scritt fil ) è rend più veloc l&#39; esecu programm è richiest scrittur fil . volt complet scrittur buffer si svuot . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3291"><question_text>contien tip struttur fil ? </question_text><answer id="A3364"><answer_text>concett fil intend memorizz dat mod permanent , l ?utilizz moment , oppur memor central non è sufficient l ?esecu programm . programm comport creazion variabil tip fil , l ?apertur fluss vers fil , relat oper lettur scrittur import oper chiusur termin fluss . fil struttur è sequenz lunghezz non prefiss valor tip . </answer_text><num_votes>0</num_votes></answer><answer id="A3329"><answer_text>insiem fil . </answer_text><num_votes>0</num_votes></answer><answer id="A3295"><answer_text>tip struttur fil è sequenz , lunghezz non prefiss , valor tip (byte caratter ) contien : -camp modal utilizz : lettur , scrittur lettur scrittur ; -un camp posizion corrent : punt prossim byte legg scriv fil ; -un camp indic error (per lettur e/o scrittur ) ; -un camp contenent indic end-of-fil (eof ) ; -dichiar variabil punt fil c : fil *pf ; </answer_text><num_votes>4</num_votes></answer><answer id="A3404"><answer_text>e&#39; buffer contien , simil fil test , tutt i dat veng lett scritt fil perifer . c acced buffer legg scriv perifer fil real binar test . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3415"><question_text>oper gestion fil ve import &#34; r &#34; ( lettur modal test ) &#34; rb&#34; ( lettur modal binar ) . qual è different quest modal ? </question_text><answer id="A3410"><answer_text>semplic lettur modal binar legg esatt i byte com 0 1 convert test caratter ansi c . modal test convert i byte memorizz caratter potrebb incorr qualc error corrispondent . </answer_text><num_votes>0</num_votes></answer><answer id="A3409"><answer_text>semplic lettur modal binar legg esatt i byte com 0 1 convert test caratter ansi c . modal test convert i byte memorizz caratter potrebb incorr qualc error corrispondent . </answer_text><num_votes>0</num_votes></answer><answer id="A3408"><answer_text>entramb modal lettur . different sussist fatt l&#39; oper &#34; r &#34; permett legg modal test caratter scrittur , tutt conosc , mentr l&#39; oper &#34; rb&#34; permett legg form binar cio form lavor i computer calcol . </answer_text><num_votes>2</num_votes></answer><answer id="A3302"><answer_text>si usa &#34; r &#34; ( lettur modal test ) quand i fil conteng caratter stampabil inform interpret uman &#34; rb&#34; ( lettur modal binar ) , vien usat quand i fil conteng dat var gen (mix caratter stampabil non ) </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3434"><question_text>serv funzion fopen ( ) , com esser utilizz ? qual modal &#34; support &#34; ? </question_text><answer id="A3322"><answer_text>fil vien apert funzion fopen , restitu stream i/o alleg fil specific poss esser fatt lettur scrittur . funzion fopen contien fil modal (es : file* fp ; fp = fopen(nomefil ,modal ) ; ) . modal previst : &#34; r &#34; (lettur modal test ) , &#34; w &#34; (scrittur modal test ) , &#34; rb&#34; (lettur modal binar ) &#34; wb &#34; (scrittur modal binar ) , stream è posizion iniz fil , oppur &#34; &#34; (scrittur modal test ) &#34; ab &#34; (scrittur modal binar ) , stream è posizion fil . </answer_text><num_votes>4</num_votes></answer><answer id="A3307"><answer_text>funzion fopen ( ) si utilizz cas si vuol aprir fil , lettur scrittur : esemp scriv file* fin; fin=fopen(nomefil , &#34; r &#34; ) ; si vuol aprir fil ( &#34; nomefil &#34; indic appunt fil ) sol lettur ( &#34; read &#34; ) ; mentr si vuol aprir fil sol scrittur : fin=fopen(nomefil , &#34; w &#34; ) ; modal support : &#34; r &#34; : lettur test - iniz fil &#34; w &#34; : scrittur test &#34; &#34; : scrittur modal test - fil &#34; rb &#34; : lettur modal binar &#34; wb &#34; : scrittur modal binar &#34; ab &#34; : scrittur modal binar </answer_text><num_votes>0</num_votes></answer><answer id="A3374"><answer_text>funzion fopen ( ) permett creazion colleg fluss fil perifer . funzion consent aprir fil gia &#39; esistent cre assoc fluss ; permett legg i dat manier different : lettur e/o scrittur modal &#39; test all&#39; iniz fil , scrittur modal &#39; test fil , lettur e/o scrittur modal &#39; binar all&#39; iniz test scrittur modal &#39; binar test . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3421"><question_text>com defin funzion fwrit ( ) fread ( ) serv ? </question_text><answer id="A3381"><answer_text>defin com segu : int fread (void* punt , int dim_element , int n_element , file* pf ) ; int fwrit (void* punt , int dim_element , int n_element , file* pf ) ; fread ( ) legg n_element dim_element byte ciascun &#38;#64257 ;le indic pf . tal element veng cop memor part dall&#39; indirizz punt . risult è numer element lett . fwrit ( ) scriv n_element , dim_element byte ciascun , &#38;#64257 ;le indic pf , prelev memor par punt . funzion restitu numer element scritt . </answer_text><num_votes>1</num_votes></answer><answer id="A3334"><answer_text>funzion fread ( ) fwrit ( ) funzion veng utilizz lettur scrittur fil bianr . entramb funzion è necessar pass puntator fil ( &#34; fil *fp &#34; ) , tip dat scriv (es int , struttur , dimelement ) puntator all&#39; element si vuol memorizz fil (void *ptr ) . abbiam pur possibil scriv più dat , pass funzion valor ( &#34; numelement &#34; ) . quinid conclud : - fwrit (void *ptr,dimelement ,numelement , fil *fp ) ; - fread(void *ptr,dimelement ,numelement , fil *fp ) ; </answer_text><num_votes>0</num_votes></answer><answer id="A3417"><answer_text>quest funzion serv : fwrit serv scriv blocc dat binar prelev zon memor indirizz ptr. restitu numer element effett lett è defin intfwrit (void*ptr , dimelement , numelement , fil *fp ) fread serv legg blocc dat maggior byte memorizz zon memor indirizz ptr . restitu numer element effett lett . è defin int fread(void *ptr , dimelement , numelement , fil *fp ) int può camb second vogl esemp float ,int ecc . </answer_text><num_votes>0</num_votes></answer><answer id="A3277"><answer_text>sint : size_t fwrit (void *ptr , size_t siz , size_t blocks , fil *fp ) ; size_t fread (void *ptr , size_t siz , size_t blocks , fil *fp ) ; serv scriv legg , rispett , blocc dat (anc struttur ) dimension &#34; size_t siz &#34; , scriv legg &#34; size_t blocks &#34; immagazzin variabil punt ptr. restitu numer byte scritt lett . quest funzion usat scrittura/lettur dat binar fil , modal (binar ) si rend necessar gest fil contenent dat tip struttur (dimensione=cost ) </answer_text><num_votes>0</num_votes></answer><answer id="A3281"><answer_text>int fwrit (*ptr,dimensioneelement ,numelement ,fil *fp ) ; int fread(*ptr,dimensioneelement ,numelement ,fil *fp ) . funzion serv scrivere/legg blocc dat fil binar . è necessar specific , dimension singol element numer element scrivere/legg . i dat scriv fil veng pres zon memor punt ptr scritt fil punt *fp . i dat legg veng pres fil punt *fp memorizz zon memor punt *ptr. entramb restitu numer element lett </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3336"><question_text>si intend stream ? qual tip può esser ? </question_text><answer id="A3284"><answer_text>stream è fluss dat , dir un&#39; astrazion livell linguagg programm . può esser tip stream : -di tip binar (sequenz pur byte veng memorizz perifer esatt com scritt ) ; -di tip test (è sequenz caratter , stavolt non è garant sequenz i caratter scritt quell memorizz perifer ) . </answer_text><num_votes>2</num_votes></answer><answer id="A3301"><answer_text>strem è un&#39; astrazion mett disposizion dell&#39; utent c un&#39; interfacc consistent gestion oper input output ugual indipenddent perifer fisic usat . esso puo esser binar (sequenz byte ) test (sequenz caratter ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3312"><answer_text>c forn interfacc consistent perl gestion i/o indipendent perifer . ovver vien forn livell astrazion livell linguagg programm . quest astrazion vien chiam stream (perifer logic ) perifer (hard disk , stampant etc. . ) fil . e&#39; possibil colleg fil stream tram un&#39; oper &#34; open &#34; . volt esegu quest oper i dat poss esser scamb programm utent fil . tip stream : binar (sequenz byte ) tip test (sequenz caratter ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3391"><question_text>cos&#39; &#39; algoritm ricors ? qual different algoritm ricors algoritm iter ? </question_text><answer id="A3294"><answer_text>informat vien dett algoritm ricors algoritm espress termin , ovver l&#39; esecu dell&#39; algoritm insiem dat comport semplif suddivision dell&#39; insiem dat l&#39; applic algoritm insiem dat semplific . algoritm iter è tipolog algoritm costitu sequenz azion vien ripet fin . </answer_text><num_votes>3</num_votes></answer><answer id="A3336"><answer_text>algoritm ricors consist , funzion richiam stess , infatt scop scomporr problem problem più piccol non si arriv soluzion bas , different inter sta propr , non poss farl . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3324"><question_text>qual i vantaggi/svantagg gest fil modal test modal binar ? </question_text><answer id="A3325"><answer_text>i fil binar si corrispondent 1 1 garant sequenz byte , non si ottien i fil test , inoltr non occorr nessun traduzion . </answer_text><num_votes>0</num_votes></answer><answer id="A3356"><answer_text>fil tip test si codif dat tram sequenz caratter , dov general non è garant corrispondent fil scritt lett quell memorizz perifer . fil tip binar , , è form sequenz bytes , i qual corrispond perifer . all&#39; intern non c&#39; è ver propr traduzion dell&#39; inform quant i numer byte lett scritt stess memorizz perifer . è più vantagg gest fil binar tip test perc lettur più rapid . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3389"><question_text>spieg different stream fil descriv mod veng utilizz nell&#39; ambit programm , esemp utilizz . </question_text><answer id="A3370"><answer_text>c stream astrazion rappresent fil disposit fisic , veng manipol attravers l&#39; uso puntator . i fil contenitor inform assoc perifer (es.hard disk ) gest sistem oper ; ciascun perifer i/o e&#39; rappresent fil cosicc &#39; l&#39; access esse vien vist com access files . fil vien assoc stream un&#39; oper &#39;open&#39; , dop qual i dat poss esser scamb programm utent fil ; fil si dissoc stream l&#39; oper &#39;chiusur &#39; . </answer_text><num_votes>0</num_votes></answer><answer id="A3283"><answer_text>stream si intend l&#39; interfacc , fluss comun attravers l&#39; utent oper gestion fil , è contenitor inform memorizz perifer hardw si access attravers stream . esemp fil può esser assoc stream mediant com &#34; open &#34; ; mod origin scamb dat programm utent fil . </answer_text><num_votes>0</num_votes></answer><answer id="A3406"><answer_text>streams (o fluss ) quell astrazion forn livell linguagg programm gestion i/o indipendent perifer . permett acced fil manier simil si comport tutt stess manier , ovver oper oper essi stess tutt . i fil contenitor inform assoc perifer gest sistem oper . fil può esser assoc stream mediant un&#39; oper &#34; open &#34; . volt esegu quest oper i dat poss esser scamb programm utent fil . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3404"><question_text>qual principal different funzion fscanf fgets ? quand è usar l&#39; altra ? </question_text><answer id="A3402"><answer_text>funzion fscanf funzion esatt com scanf, oper fil ; restitu numer camp lett success , cas error , 0 eof . funzion fgets necess , specif string dov deposit rig lett , quantit massim caratter legg canal attravers qual effettu lettur ; funzion legg fil numer caratter specific newlin , vien incontr prim . non si può infatt conosc l ?esatt lunghezz dat conten camp cos si utilizz newlin com delimit . </answer_text><num_votes>0</num_votes></answer><answer id="A3327"><answer_text>fscanf fgets entramb funzion lettur dat . prim legg i dat input spaz bianc , mentr second legg invi cap . inoltr fgets salv i dat lett array inser null com ultim cell dell&#39; array , fscanf legg bas formatt dat all&#39; iniz . si è sicur ciò si avrà nell&#39; input è convenient usar fscanf, essend essa instabil (mand programm overflow dat input è form divers aspett ) spess convien usar fgets poic caus men error . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ3341"><question_text>e&#39; possibil esegu lettur dat modal binar fil scritt non modal binar ? succed ? </question_text><answer id="A3422"><answer_text>si è possibil i fil binar dimension limit minor test , è più difficil corregg cas error ; lettur veng form ser lung 0 1 , difficil comprend . </answer_text><num_votes>2</num_votes></answer><answer id="A3413"><answer_text>sì è possibil lettur modal binar fil non modal binar , appar com insiem &#34; zer uni&#34; , poi non tradott è tradott codif asci i caratter veng visualizz com i numer (in binar ) qual corrispond . </answer_text><num_votes>0</num_votes></answer><answer id="A3371"><answer_text>lettur fil binar avvien tram funzion fread . è possibil esegu l&#39; oper lettur dat modal binar fil non scritt modal binar , dat vien interpret erron si legg sbagl . </answer_text><num_votes>0</num_votes></answer><answer id="A3372"><answer_text>lettur fil binar avvien tram funzion fread . è possibil esegu l&#39; oper lettur dat modal binar fil non scritt modal binar , dat vien interpret erron si legg sbagl . </answer_text><num_votes>0</num_votes></answer><answer id="A3369"><answer_text>lettur fil binar avvien tram funzion fread . è possibil esegu l&#39; oper lettur dat modal binar fil non scritt modal binar , dat vien interpret erron si legg sbagl . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3315"><question_text>different c&#39; è fputs ( ) fputc ( ) ? com oper funzion ? ricev input dann output ? indic f ? </question_text><answer id="A3397"><answer_text>f indic funzion oper camp fil , l&#39; output non sar più scherm fil (solit test ) . different : - int fputc (int , file* stream ) apre stream fil , prend ingress char &#34; &#34; scriv fil caratt - int fputs (char* s , file* stream ) apre stream fil , prend ingress puntator char &#34; s &#34; , scriv fil tutt i caratter string quand non trov caratt controll /0 . </answer_text><num_votes>1</num_votes></answer><answer id="A3332"><answer_text>funzion fputs ( ) fputc ( ) differ mod oper : prim scriv line (string char termin newlin ) fil specific com parametr ingress , mentr second scriv com prossim caratt fil caratt specific i parametr ingress . prim ricev input puntator fil string inser , second ricev input caratt puntator fil ; prim restitu 0 l&#39; oper è riusc , valor divers 0 cas contrar , second restitu (com inter ) caratt inserito.l f indic fil . </answer_text><num_votes>0</num_votes></answer><answer id="A3331"><answer_text>f indic oper verrann svolt fluss (cio fil ) . fputs ( ) inser fil string immess tastier mentr fputc ( ) inser fil caratt . funzion fputs ( ) ricev input puntator string inser puntator fil , mentr fputc ( ) ricev valor inter caratt inser puntator fil . cas success fputs ( ) restitu output numer non negat fputc ( ) ritorn caratt scritt ; cas error restitu entramb eof (end of fil ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3354"><question_text>qual principal caratterist algoritm ricors qual i vantaggi/svantagg programm non ricors ? </question_text><answer id="A3425"><answer_text>funzion è dett ricors determin propr valor , essa ricorr calcol un&#39; valor ripet chiam stess . esser valid , preved condizion (dett punt ritorn ) qual restitu valor , evit loop . e&#39; not com calcol valor avveng ordin invers chiam . l&#39; uso ricorsion può rend più semplic programm , risult compatt eleg , sebben men efficient dell&#39; iter termin occup memor veloc esecu . </answer_text><num_votes>1</num_votes></answer><answer id="A3401"><answer_text>principal caratterist affinc algoritm poss esser espress form ricors : -la possibil formul l&#39; algoritm funzion ; -l&#39; esistent condizion termin , affinc non si verfichin cicl infin ; principal vantagg tal funzion è permett risolv problem compless poch righ programma.dal punt vist prestazion potrebber esser svantagg .funzion occup gross quantit spaz memor potrebber dar problem esecu . </answer_text><num_votes>1</num_votes></answer><answer id="A3396"><answer_text>ricorsion è eleg strument concettual , util situazion richied soluzion indutt , ovver quand soluzion può esser ridott risolt problem simil più piccol . c.bas : istanz semplic , risolv mod dirett ricorsion . c.indutt : istanz non risolv dirett attravers cert proced . e&#39; dirett sott.programm chiam durant l&#39; esecu , indirett vien chiam apert precedent . vantagg gestion dinam pil , elabor non sempr utilizz . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3305"><question_text>cos&#39; è variabil tip fil ? </question_text><answer id="A3287"><answer_text>fil è tip struttur contien : -camp modal utilizz : lettur , scrittur lettur scrittur ; ? -un camp posizion corrent : punt prossim byte legg scriv fil ; ? --un camp indic error (per lettur e/o scrittur ) ? -un camp contenent indic end-of-fil (eof ) . ?dichiar variabil punt fil c : fil *fp ; </answer_text><num_votes>0</num_votes></answer><answer id="A3415"><answer_text>&#34; fil &#34; è tip struttur contenent : camp modal utilizz : riguard lettur , scrittur lettur scrittur ; camp posizion corrent : punt prossim byte legg scriv fil ; camp indic error (per lettur e/o scrittur ) , camp contenent indic end-of-fil (eof ) ? . dichiar variabil punt fil c : fil *fp ; </answer_text><num_votes>1</num_votes></answer><answer id="A3389"><answer_text>è variabil apre cre fil estern programm , esemp funzion open ( ) , scop edit tal fil . buon natal tutt : ) </answer_text><num_votes>1</num_votes></answer><answer id="A3387"><answer_text>e&#39; variabil punt fil sistem oper gest tram tabell fil apert . </answer_text><num_votes>0</num_votes></answer><answer id="A3386"><answer_text>e&#39; variabil punt fil sistem oper gest tram tabell fil apert . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3332"><question_text>punt vist dell&#39; utilizz risors sistem , è utilizz algoritm iter ricors ? perc ? </question_text><answer id="A3320"><answer_text>innanzitutt ricord algoritm iter ricors punt vist computazional equivalent (cio teor convert ) . si not version ricors (per definizion matemat ) è più eleg compatt , risult men efficient quell iter poic occup stack numer istanz par chiam funzion , utilizz gross quantit spaz memor rallent notevol esecu processor . dunqu prestazion l&#39; obiett principal programm si prefer l&#39; iter . </answer_text><num_votes>3</num_votes></answer><answer id="A3411"><answer_text>algoritm ricors e&#39; possibil ridurr l&#39; utilizz risors sistem , perc determin programm puo&#39; richiam durant esecu mod dirett indirett </answer_text><num_votes>1</num_votes></answer><answer id="A3421"><answer_text>nell&#39; iter si esegu ripetut righ codic (cicl for , whil , do..whil ) mentr ricorsion è tutt routin richiam sè stess . ciò si ottien solit tram -ripet - chiam funzion , non cost trascur . general algoritm ricors codic più compatt analog iter , consum memor maggior . calcol infatt ten memor ogni chiam funzion all&#39; ultim , qual part risolv problem . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3340"><question_text>elenc descriv i pass caratterizz l&#39; algoritm ordin &#34; merg sort &#34; . </question_text><answer id="A3437"><answer_text>merg sort è algoritm ordin bas confront utilizz process risolu ricors , sfrutt tecnic divid et imper , consist suddivision problem sottoproblem stess natur dimension via via più piccol . (1 ) sequenz ordin lunghezz 0 1 , è ordin , nessun oper . altriment : (2 ) sequenz vien divis met (3 ) ognun quest sottosequent vien ordin , applic ricors l&#39; algoritm (4 ) sottosequent ordin veng fus </answer_text><num_votes>0</num_votes></answer><answer id="A3289"><answer_text>sequenz ordin lunghezz 0 oppur 1 , è già ordin . altriment : sequenz vien divis (divid ) met (se sequenz contien numer dispar element , vien divis sottosequent prim element più second ) ognun quest sottosequent vien ordin , applic ricors l&#39; algoritm (imper ) sottosequent ordin veng fus (combin ) . , si estra ripetut minim sottosequent si pon sequenz uscit , risult ordin </answer_text><num_votes>3</num_votes></answer><answer id="A3309"><answer_text>i pass caratterizz l&#39; algoritm merg sort : divid (dov sequenz element è divis sequenz n/2 element ) ; imper (che non è l&#39; ordin sequenz mod ricors usand merg sort ) combin (la fusion sequenz ordin ) </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3317"><question_text>cas è usar funzion ricors non ricors ? </question_text><answer id="A3324"><answer_text>è utilizz funzion ricors cas problem si poss suddivid sottoproblem risolv mediant funzion . esemp è programm stamp sequenz numer fibonacc poic (eccett cas n=0,1 ) programm utilizz funzion n-1 n-2 n defin dall&#39; utent poi stamp i risult . </answer_text><num_votes>0</num_votes></answer><answer id="A3420"><answer_text>ricorsion vantagg fondamental : permett scriv poch line codic risolv problem compless . tuttav , essa enorm svantagg poic ricorsion occup stack numer istanz par chiam funzion è necessar effettu risolv problem . pertant , prestazion obiett principal programm non si dispon sufficient memor , è utilizz funzion non ricors . </answer_text><num_votes>3</num_votes></answer><answer id="A3362"><answer_text>ricorsion è strument concettual present camp part matemat linguagg programm . e&#39; util eleg strument realizz formul algoritm . </answer_text><num_votes>0</num_votes></answer><answer id="A3300"><answer_text>funzion ricors si usa quand si riesc divid problem cas bas , si conosc prior soluzion , cas indutt risolv attravers proced preved richiam , dirett indirett , stess funzion inizial risolv problem più semplic . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3350"><question_text>ruol sistem oper gestion fil mediant linguagg c/c++ ? </question_text><answer id="A3385"><answer_text>qualsias linguagg programm comunic so poter acced fil , linguagg c/c++ i fil veng gest dirett sistem oper (so ) . particol c/c++ esist librer ad-hoc gest comun so . mod è possibil acced perifer ingress uscit tratt com files . </answer_text><num_votes>1</num_votes></answer><answer id="A3399"><answer_text>ruol sistem oper gestion fil mediant linguagg c/c++ è assoc mod univoc posizion filesystem fil . non si può interag dirett fil pot attravers un&#39; applic c/c++ , serv sistem oper assoc quel fil identif , non è variabil puntator tip particol far tram all&#39; access fil . </answer_text><num_votes>0</num_votes></answer><answer id="A3306"><answer_text>sistem oper (so ) gest struttur dat memorizz i fil attual utilizz programm esecu .quand programm vuol aprir fil (fopen ) , apre stream indic so intenzion aprir fil . so : -cre element vettor fil apert content tutt i dat necessar gestion fil ; -restitu variabil puntator tip fil l&#39; indirizz struttur descriv fil question . i camp conten struttur : modal utilizz , posizion corrent fil , indic error eof </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3294"><question_text>streams i files c++ ? caratteristiche/propriet ? consent ? </question_text><answer id="A3333"><answer_text>stream si intend fluss avvien trasmission dat , mentr fil si intend memorizz dat memor mass , infatt stream consent legg ,scriv acced fil , sin tip fil , &#34; normal &#34; binar , i prim salv semplic un&#39; immagin ,mentr quell binar codific . </answer_text><num_votes>0</num_votes></answer><answer id="A3298"><answer_text>c/c++ permett gest input/output var perifer indipendent tip perifer ; tutt ciò vien res possibil graz livell astrazion res possibil linguagg programm ; tal astrazion vien chiam stream (fluss ) rappresent canal attravers pass inform , mentr perifer vien chiam fil ; i fluss (di tip binar test ) si comport stess manier veng gest tram stess funzion , mentr non tutt i files simil caus divers perifer . </answer_text><num_votes>2</num_votes></answer><answer id="A3313"><answer_text>stream serv mett contatt (cre pont ) files . i files insiem dat organizz struttur (definizion general ) , caratterizz attravers posizion memor (per acced fil bisogn quest inform ) . attravers stream è possibil aprir , leggere/scriv chiud fil (è ben ricord fil sempr chius mod vad svuot buffer dat avev memor scriv fil ) . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3408"><question_text>qual&#39; è l&#39; utilizz flag eof gestion error all&#39; intern tip struttur fil ? </question_text><answer id="A3373"><answer_text>funzion int feof ( fil *f ) ; restitu valor divers 0 posizion corrent fil raggiunt fil . restitu 0 non fil . </answer_text><num_votes>0</num_votes></answer><answer id="A3394"><answer_text>all&#39; intern tip struttur fil flag eof (end-of-fil ) funzion restitu variabil tru quand si è arriv fond fil . esemp lettura/scrittur caratter string funzion putc ( ) , fputc ( ) , *fputs quand si è raggiunt fil funzion ce segnal restitu variabil eof tru . e&#39; possibil utilizz flag com condizion uscit cicl whil qual scorr fil dall&#39; iniz . </answer_text><num_votes>2</num_votes></answer><answer id="A3403"><answer_text>all&#39; intern tip fil vien struttur camp &#34; end of fil &#34; , assum valor &#34; tru &#34; quand vien raggiunt . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3381"><question_text>qual oper gestion variabil tip fil ? elencal descrivil . </question_text><answer id="A3293"><answer_text>fluss ifstream deriv class istream è utilizz gest lettur fil (sol lettur ) fluss ofstream deriv class ostream è utilizz gest scrittur fil (sol scrittur ) fluss fstream deriv iostream è utilizz gest lettur scrittur fil (lettura+scrittur contemporan ) </answer_text><num_votes>0</num_votes></answer><answer id="A3318"><answer_text>instaur un&#39; assoc fluss fil perifer è defin cos : fil *fopen (nomefil , modal ) indirizz struttur tip file.modal : ? r ? lettur modal test iniz fil , ? w ? scrittur modal test iniz fil , ?a ? scrittur modal test fil , ?rb ? lettur modal binar iniz fil , ?wb ? scrittur modal binarioiniz fil , ?ab ? scrittur modal binar fil .termin dell&#39; assoc fluss fil perifer veng scritt dat memorizz buffer fil indirizz fp : int fclos (fil *fp ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3375"><answer_text>acced fil è necessar predisporr variabil rappresent , puntator fil (fil * fp ) . apertur : fil *fopen(nomefil , modal ) ; dov modal puo esser lettur &#34; r &#34; , scrittur &#34; w &#34; cos via . chiusur : int fclos (fil *fp ) ; resitu 0 tutt è andat ben , altriment eof . lettura/scrittur : int getc (fil *fp ) ; int putc (int c , fil *fp ) ; int fgetc (fil *fp ) ; int fputc (int c , fil *fp ) ; cancell : int remov (nomefil ) rinomin : int renam (vecchionom , nuovonom ) </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3357"><question_text>qual i fluss c qual caratterist ? </question_text><answer id="A3400"><answer_text>mod utilizz i fluss (streams ) : -i fluss commun cre aprir fil , può esser tip binar cio sequenz byte tip test cio sequenz caratteri; -programm c permett assoc fil fluss vien dichiar (# includ stdi .h ) permett cos scamb dat programm fil ; -il programm utilizz i fluss standard , veng esegu mod autonom : (stdout , stderr ) vide terminal (stdin ) tastier terminal . </answer_text><num_votes>3</num_votes></answer><answer id="A3390"><answer_text>esist fluss standard si apron automat l&#39; esecu programm : stdin ,stdout stderr . quest fluss assoc fil rappresent vide tastier . funzion ingress uscit utilizz printf scanf. </answer_text><num_votes>0</num_votes></answer><answer id="A3315"><answer_text>linguagg c preved ogni programm dispong , mod predefin , fluss fil già costitu : standard input , standard output standard error . è predispost lettur norm è colleg tastier ; consent scrittur colleg normal scherm . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3400"><question_text>istanz sistem oper quand vien istanz fil ? fa&#39; sistem oper quand chiud fil ? </question_text><answer id="A3360"><answer_text>quand vien istanz fil (fil *f ; ) sistem oper cre &#34; stream &#34; , fluss , assoc fil . fluss permett appunt legg scriv fil . i fluss utilizz comunic perifer com l&#39; output vide tastier . quand chiud fil sistem oper &#34; dissoc &#34; stream fil . fil vien chius manier automat quand programm termin l&#39; esecu . durant chiusur i dat veng scritt fil . programm si arrest inaspettat è possibil alcun dat vad pers . </answer_text><num_votes>0</num_votes></answer><answer id="A3359"><answer_text>quand vien istanz fil (fil *f ; ) sistem oper cre &#34; stream &#34; , fluss , assoc fil . fluss permett appunt legg scriv fil . i fluss utilizz comunic perifer com l&#39; output vide tastier . quand chiud fil sistem oper &#34; dissoc &#34; stream fil . fil vien chius manier automat quand programm termin l&#39; esecu . durant chiusur i dat veng scritt fil . programm si arrest inaspettat è possibil alcun dat vad pers . </answer_text><num_votes>0</num_votes></answer><answer id="A3304"><answer_text>sistem oper gest tram tabell fil apert variabil punt fil ; fluss standard , quand vien istanz fil , sistem oper instaur un&#39; assoc fluss fil perifer ; mod quand fil vien chius , si termin l&#39; assoc fluss fil perifer . </answer_text><num_votes>1</num_votes></answer><answer id="A3358"><answer_text>quand vien istanz fil (fil *f ; ) sistem oper cre &#34; stream &#34; , fluss , assoc fil . fluss permett appunt legg scriv fil . i fluss utilizz comunic perifer com l&#39; output vide tastier . quand chiud fil sistem oper &#34; dissoc &#34; stream fil . fil vien chius manier automat quand programm termin l&#39; esecu . durant chiusur i dat veng scritt fil . programm si arrest inaspettat è possibil alcun dat vad pers . </answer_text><num_votes>2</num_votes></answer><answer id="A3321"><answer_text>riteng domand non chiar mal post . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3308"><question_text>qual è different ricorsion tip dirett tip indirett ? </question_text><answer id="A3299"><answer_text>si ricorsion dirett quand sottoprogramm p chiam , durant esecu , . si ricorsion indirett quand sottoprogramm p chiam , durant esecu , sottoprogramm q volt chiam sottoprogramm r. success r chiam nuov p. </answer_text><num_votes>2</num_votes></answer><answer id="A3378"><answer_text>si parl ricorsion indirett quand nell&#39; algoritm funzion richiam un&#39; altra volt richiam prim , altriment si parl ricorsion dirett . </answer_text><num_votes>0</num_votes></answer><answer id="A3285"><answer_text>ricorsion tip dirett funzion richiam stess (ad esemp funzion p richiam p ) mentr ricorsion tip indirett funzion richiam altra funzion volt richiam prim (ad esemp funzion p richiam q richiam p ) </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3297"><question_text>qual principal oper usabil tip fil ? </question_text><answer id="A3395"><answer_text>funzion bas i tip fil si trov librer stdi .h fopen ( ) aprir fil , fclos ( ) chiud , fscanf ( ) fprintf ( ) scriv legg fil , fread ( ) fwrit ( ) lettur scrittur dat fil blocc alcun fseek ( ) ftell ( ) . general i fil ,propr com i fluss , poss esser form test (leggibil poi tram blocc not mett .txt com estension ) oppur numer binar (che imped lettur fuor programm ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3296"><answer_text>innanzitutt fil esist già è possibil aprirl (fopen ) success chiud (fclos ) ; principal modal quell lettur (fopen &#34; exampl .txt &#34; , rt ) scrittur (fopen &#34; example2.txt &#34; , w ) . quest possibil version binar , camb legger codic . tuttav i comand feof , fprintf , fscanf, fputs , fgets , fputc , fgetc è possibil utilizz fil .txt qualsias mod previst c/c++ . </answer_text><num_votes>0</num_votes></answer><answer id="A3384"><answer_text>oper principal usabil tip fil : oper gestion fil : apertur &#34; fopen ( ) &#34; , chiusur &#34; fclos ( ) &#34; , cancell &#34; remov ( ) &#34; ridenomin &#34; renam ( ) &#34; fil ; oper lettura/scrittur : formatt &#34; fprintf ( ) fscanf( ) &#34; , caratter &#34; fgetc ( ) fputc ( ) &#34; fil binar &#34; fread ( ) fwrit ( ) &#34; ; oper gestion error : &#34; ferror ( ) &#34; controll è commess error precedent oper lettur scrittur , &#34; feof ( ) &#34; controll è stat raggiunt fil precedent oper lettur . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ3360"><question_text>aprend fil dimentic chiud , succed quand programm termin (du cas ) ? </question_text><answer id="A3391"><answer_text>session scrittur lettur fil è necessar chiud fil mod tal conten veng salv permanent memor mass . quest oper vien esegu tram funzion fclos ( ) , può restitu risult distint : l&#39; oper chiusur è stat esegu corrett restitu valor 0 , chiusur non è andat buon ritorn costant eof . </answer_text><num_votes>1</num_votes></answer><answer id="A3377"><answer_text>quand si diment usar chiusur fil (fclos ) , poss succed 2 cas : - perd dat (rimast buffer ) ; - perd files . </answer_text><num_votes>1</num_votes></answer><answer id="A3323"><answer_text>moment programm termin propr esecu improvvis , ovver andand crash , i fil rimast apert poss non aver incis memor conten si poss perd dat . d&#39; altra part modif eran stat salv precedent non vien pers alcun dat . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3378"><question_text>si intend access random ? si distingu sequenzial ? </question_text><answer id="A3423"><answer_text>perifer fisic lavor utilizz fil access random oppur sequenzial . i fil access random è possibil moment apertur fil (open ) acced determin posizion identif posizion (puntator ) . fil access sequenzial non è possibil raggiung determin posizion occorr scorr fil . </answer_text><num_votes>0</num_votes></answer><answer id="A3282"><answer_text>access random si intend lettur l&#39; utilizz variabil posizion casual . different l&#39; access sequenzial è quest&#39; l&#39; access variabil avverr ordin , non mod casual . </answer_text><num_votes>0</num_votes></answer><answer id="A3280"><answer_text>access casual (access random ) si indic caratterist poter acced element arbitrar sequenz costant , indipendent dimension sequenz stess posizion dell&#39; element essa . l&#39; element è arbitrar sens posizion non è preved , mot qual si usa termin &#34; casual &#34; . concett oppost è access sequenzial , l&#39; access element richied più men second posizion . </answer_text><num_votes>1</num_votes></answer><answer id="A3355"><answer_text>premess domand non è pertinent all&#39; argoment , access casual si indic caratterist poter acced element arbitrar sequenz costant indipendent dimension sequenz stess . esemp struttur consent l&#39; access random è l&#39; array . concett oppost è access sequenzial , l&#39; access element richied più men second posizion . esemp struttur consent l&#39; access sequenzial list concaten . </answer_text><num_votes>0</num_votes></answer><answer id="A3279"><answer_text>access casual (access random ) si indic caratterist poter acced element arbitrar sequenz costant , indipendent dimension sequenz stess posizion dell&#39; element essa . l&#39; element è arbitrar sens posizion non è preved , mot qual si usa termin &#34; casual &#34; . concett oppost è access sequenzial , l&#39; access element richied più men second posizion . </answer_text><num_votes>0</num_votes></answer><answer id="A3330"><answer_text>------------2 modalita&#39; access fil ----------- -- 1 ) random : permett acced costant qualsias part fil indipendent dimension quest&#39; ; 2 ) sequenzial : richiest acced inform fil vien condizion posizion all&#39; intern . n.b. -in fil access casual è possibil legg scriv i dat qualsias ordin . -ne fil sequenzial è sempr necessar part ?iniz fil proced ordin scansion dat conseguent perd . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3373"><question_text>nell&#39; ambit gestion fil fann com si usan funzion remov renam ? </question_text><answer id="A3367"><answer_text>funzion remov permett elimin fil vien indic parentes : remov ( &#34; fil .txt &#34; ) ; renam permett camb fil : renam ( &#34; vecchionom .txt &#34; , &#34; nuovonom .txt &#34; ) ; bisogn ten ment fil è apert non è possibil elimin , l&#39; effett dell&#39; esecu dip com si implement programm . e&#39; necessar utilizz funzion controll verific l&#39; oper è andat buon (la funzion restitu 0 cas success 1 cas error ) . </answer_text><num_votes>2</num_votes></answer><answer id="A3319"><answer_text>funzion remov vien utilizz quand si vuol cancell determin fil . nell&#39; implement codic , funzion pass fil (es . int renam ( nome_fil ) ) si vuol cancell . funzion renam serv poter rinomin determin fil . funzion vann pass original fil si vuol modific (es . int renam ( nome_original , nuovo_nom ) ) . entramb funzion restitu 0 oper avveng success , altriment restitu valor divers 0 . </answer_text><num_votes>0</num_votes></answer><answer id="A3388"><answer_text>funzion remov ( &#34; nomedelfil .form &#34; ) ; serv elimin fil , mentr renam ( &#34; nomeprecedent .form &#34; , &#34; nuovonome.form &#34; ) ; serv rinomin . fil vien assegn com fil già esistent quest&#39; vien solit sovrascritt . entramb funzion restitu feedback : 0 non error , oppur -1 aggiorn finestr elenc error codic dell&#39; error verificat . usar funzion è necessar includ programm librer standard input output : #include&#60;std .h&#62; </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3321"><question_text>different c&#39; è fil normal fil binar ? </question_text><answer id="A3305"><answer_text>fil normal test è fil contien caratter scrittur semplic , compong test leggibil dirett utent bisogn install programm appos . termin si usa contrapposizion fil binar , è fil contenent dat numer binar non dirett leggibil dall&#39; utent . realt , punt vist macchin , non c&#39; è distinzion i tip , poic tutt i fil non sequenz byte . different sta ciò i byte rappresent com veng interpret fil . </answer_text><num_votes>1</num_votes></answer><answer id="A3357"><answer_text>fil normal inform rappresent com fluss caratter . particol non è per garant corrispondent input output . infatt alcun caratter poss esser tradott . fil binar non è fluss bytes ugual all&#39; input . non è traduzion dell&#39; inform corrispondent è garant . fil binar è per difficil consult , quant i bytes spess risult protett . </answer_text><num_votes>0</num_votes></answer><answer id="A3361"><answer_text>fil binar è rappresent sequenz bytes mentr fil tip test (normal ) è caratterizz dall&#39; esser sequenz caratter . cas occorr process codifica/decodif : comport corrispondent caratter scritti/lett quell realment memorizz perifer non garant . cas fil binar , , corrispondent è garant , quant non avvien alcun traduzion dell&#39; inform . </answer_text><num_votes>1</num_votes></answer><answer id="A3424"><answer_text>l&#39; unic different fil normal binar e&#39; mod codif </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3295"><question_text>mod utilizz memor , funzion lavor modal ricors ? </question_text><answer id="A3314"><answer_text>funzion ricors gest memor manier dinam , più propr &#34; costru &#34; pil dat : ovver funzion , part cas compless , calcol risult parzial parchegg memor risolv problem sar pò più semplic ... cos via cas bas funzion riesc trov soluzion utilizz risolv &#34; soluzion parzial &#34; otten . </answer_text><num_votes>3</num_votes></answer><answer id="A3383"><answer_text>funzion ricors cre zon memor esemp ogni volt funzion richiam stess </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3286"><question_text>l&#39; access modal binar port vantagg svantagg confront modal test ? com mai ? </question_text><answer id="A3414"><answer_text>l &#39; access modal binar port vantagg confront modal test quant fil binar : pros minor overhead (minor dimension ) , facil dell&#39; access random modif , cons portabil calcol , non text editor </answer_text><num_votes>1</num_votes></answer><answer id="A3316"><answer_text>l&#39; access modal binar port vantagg modal tip test quant riguard numer byte letti/scritt stess memorizz nella/dall perifer . corrispondent test , , caratter scritti/lett quell memorizz perifer non è garant . </answer_text><num_votes>1</num_votes></answer></question></lecture><lecture id="L25" title="Algoritmi, il sistema operativo (E1.1), l’ambiente di sviluppo DEVC++ (E1.1), dichiarazione, inizializzazione e utilizzo delle variabili (E1.2)" date="2013-09-16"><question id="QQ2047"><question_text>computer può più microprocessor ? si com potrebb esser gest l&#39; esecu programm ? </question_text><answer id="A3440"><answer_text>approcc increment performanc computer consist nell&#39; utilizz più processor , com architettur smp utilizz server workstation part anni &#39;90 . i processor multi-cor consent potenzial moltipl performanc bas numer cor patt i programm sian &#34; scritt &#34; sfrutt quest potenzial : architettur multicor richied ottimizz part programm . cert compil c preved già support utilizz processor multicor . </answer_text><num_votes>0</num_votes></answer><answer id="A1975"><answer_text>si è attual possibil , l&#39; esecu programm avvien parallel cos aument performanc computer . e&#39; import inoltr microprocessor inform spaz memor sta andand utilizzare,per evit sovrascr dat stess cella.quest quand memor microprocessor è condivis ,ci architettur memor distribu dov ogni microprocessor è dot banc priv memor . </answer_text><num_votes>0</num_votes></answer><answer id="A1872"><answer_text>si , computer può 2 più processor oper parallel . l’esecu programm sistem elabor più microprocessor utilizz calcol parallel rend l’esecu programm più rapid , perc vien svolt più element contemporane . pratic , è spess difficil suddivid programm mod divers unit elabor poss svolg ciascun propr part interfer l’altr . </answer_text><num_votes>0</num_votes></answer><answer id="A1920"><answer_text>computer poss esser present più microprocessor . esemp 2 cpu separ , sald pezz silic , funzion separat . sicur condivid bus dat dovrann gir stess frequenz . l’esecu programm vien divis essi . esegu cert oper mentr l&#39; oper . infin i dat converg tutt bus dat . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2038"><question_text>qual valor poss attribu variabil tip char ? </question_text><answer id="A1825"><answer_text>variabil tip caratt poss atteibu valor non numer , valor rappresent caratter tip asci , identific tip &#60;char&#62; . </answer_text><num_votes>0</num_votes></answer><answer id="A1989"><answer_text>variabil char poss attribu qualsias caratt defin stand asci . poss dunqu attribu letter maiuscol minuscol . tip char identif caratt necessar 8 bit rappresent . </answer_text><num_votes>1</num_votes></answer><answer id="A1956"><answer_text>variabil char è possibil attribu caratt alfanumer maiuscol minuscol , simbol qualsias inser tastier non visibil (ad esemp spaz ) . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ2101"><question_text>accad variabil , essa vien assegn numer tropp grand (numer bits maggior numer bits poss memorizz ) , vien segnal error overflow oppur programm continu assegn valor massim variabil può conten ? </question_text><answer id="A2023"><answer_text>programm continu assegn variabil numer massim bits quel tip variabil può conten , elimin i bits più ; esemp variabil potess conten 4 bits , assegn valor binar 10010 , ciò verr memorizz variabil sar 0010 , riport alcun error </answer_text><num_votes>0</num_votes></answer><answer id="A2005"><answer_text>variabil vien assegn valor tropp grand , programm segnal part riserv messagg (in bass ) l&#39; error riguard variabil digit , programm vien comunqu esegu valor non è desider . infatt si fuor rang definizion , risult comp segu l&#39; aritmet complement 2 , volt super valor più alto è possibil memorizz , fa ripart contegg più bass . </answer_text><num_votes>3</num_votes></answer><answer id="A1883"><answer_text>dichiar variabil float od int , compil c/c++ alloc automat spaz 4 bytes memorizz valor . signif , variabil tip int , si può assegn rang valor 0 4294967295 , fenomen analog variabil float . accad assegn valor tropp grand , è error fas compil , fas esecu (nel cas vogl assegn valor tastier esecu ) . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2094"><question_text>variabil : succed non si dichiar variabil ? </question_text><answer id="A1948"><answer_text>programm scritt dec c++ scriv programm rich variabil averl dichiar , compil fas compil dar error riport : &#34; undeclared (first use this function ) &#34; . particol dichiar variabil serv compil conosc tipolog dat sap quant spaz andar riserv variabil (char 8bit , int 16 bit , float 32 bit ) . </answer_text><num_votes>3</num_votes></answer><answer id="A1837"><answer_text>l&#39; esecu non sar possibil . dichiar variabil si riserv cert quantit memor dov poi verrann inser i dat , non si dichiar non sar nessun spaz dispon inser i dat compil indic c&#39; è error . </answer_text><num_votes>2</num_votes></answer><answer id="A1986"><answer_text>non si dichiar variabil non si poss salv i risult oper si effettu </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2097"><question_text>different c&#39; è &#34; macchin fisic &#34; &#34; macchin virtual &#34; ? </question_text><answer id="A1939"><answer_text>macchin fisic non è l&#39; insiem component elettron necessar funzion calcol , mentr macchin virtual è softw grad simul funzion macchin fisic tram un&#39; interfacc grafic . </answer_text><num_votes>1</num_votes></answer><answer id="A1797"><answer_text>ogni utent interag macchin virtual non macchin fisic . termin “virtual ” indic quest macchin non esist realment , softw realizz part funzion . l&#39; insiem funzion macchin virtual descriv può esegu . </answer_text><num_votes>1</num_votes></answer><answer id="A1921"><answer_text>different macchin fisic , macchin virtual i component hardw simul . signif sistem oper sar install macchin virtual utilizz hardw non fisic simul programm (ad es virtual machin ) install sistem oper principal , ovver install macchin fisic . conseguent avrem macchin fisic può esser esecu più macchin virtual . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2032"><question_text>serv registr , registr dat registr indirizz cpu ? </question_text><answer id="A1966"><answer_text>registr (stat register ) controll condizion anomal durant cicl esecu ; utilizz flag (c ,z,s,v ) ; registr dat (dat register ) contien dat prelev cell memor oppur dat dovr esserv trasfer ; registr indirizz (accumulator register ) vien utilizz esegu somm memorizz i risult parzial oper . </answer_text><num_votes>0</num_votes></answer><answer id="A1855"><answer_text>registr serv controll non insorg problem cpu durant oper . registr dat contien cop parol lette/d scriv mm ; esso serv pertant forn dat elabor perifer (oper scrittur ) prelev dat mess disposizion perifer (oper lettur ) . registr indirizz contien l&#39; indirizz memor ram dalla/nell qual dat esser prelevato/inser . </answer_text><num_votes>1</num_votes></answer><answer id="A1945"><answer_text>registr serv riport indic relat risult var oper ; registr dat , , caric conten cell memor (lettur ) oppur cop propr conten cell memor (scrittur ) . infin registr indirizz contien inform relat var posizion cell memor . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2058"><question_text>com si present conten variabil dichiar non inizializz ? </question_text><answer id="A2006"><answer_text>conten può esser var , sens non si è cert conteng registr assoc dett variabil . infatt è possibil esso conteng inform tip alfanumer (es : 0 , -20 , 14875269 , ecc . ) . inoltr , è assolut sconsigl l&#39; uso variabil non inizializz all&#39; intern programm , quant non si conosc conten . </answer_text><num_votes>2</num_votes></answer><answer id="A1944"><answer_text>conten variabil non inizializz è indetermin , cio contien intern è present moment dell&#39; alloc è assegn compil . </answer_text><num_votes>1</num_votes></answer><answer id="A1874"><answer_text>rispond esemp pratic , scriv c programm : #includ &#60;stdi .h&#62; #includ &#60;stdlib.h&#62; int main(int argc , char *argv[ ] ) { int a; printf ( &#34; valor = %a\n &#34; , ) ; system ( &#34; paus &#34; ) ; return 0 ; } compil esegu . com puo ved valor non è dichiar programm mostr vide conten cell è occup sistem . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2057"><question_text>qual è &#34; ruol &#34; clock sistem ? </question_text><answer id="A1970"><answer_text>clock l&#39; orolog intern sistem , è util scand qualsias oper computer . general sincronizz funzion tutt i disposit dell&#39; oper . e&#39; comunqu sempr clock impon determin frequenz veloc cpu (si misur hertz ) . </answer_text><num_votes>0</num_votes></answer><answer id="A1890"><answer_text>macchin von neuman fas d&#39; elabor si sussegu mod sincr &#34; orolog sistem &#34; dett clock , scand cpu . funzional clock è gener tension produc segnal period . l&#39; elettron macchin traduc oscill tension commut livell logic 0 1 (il funzion calcol è binar ) . numer commut è frequenz clock (espress hz ) . </answer_text><num_votes>0</num_votes></answer><answer id="A1980"><answer_text>clock sistem , circu temporizz , consent sincronizz l’esecu tutt oper esegu cpu . tal orolog intern è respons segnal onda quadr caratterizz rapid succession livell tension , alto bass . poic maggior è frequenz tal segnal maggior è numer oper veng esegu unit , si può afferm tal frequenz incid manier considerevol veloc pc . </answer_text><num_votes>2</num_votes></answer><answer id="A1896"><answer_text>clock sistem scand esecu un&#39; istruzion programm . più alto è frequenz clock più istruzion potrann esser esegu determin lass . </answer_text><num_votes>1</num_votes></answer><answer id="A1982"><answer_text>ruol clock sistem è scand i temp esecu var istruzion . component funzion mand impuls ogni clock frequenz , misur hertz . clock frequenz più elev gener numer maggior impuls unit conseguent sarann esegu più veloc istruzion . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ1984"><question_text>riguard all&#39; architettur intern cpu ,specific funzion dell&#39; alu (unit aritmet logic ) dell&#39; uc (unit controll ) relazion intercorr esse . </question_text><answer id="A1958"><answer_text>l&#39; alu funzion esegu oper aritmet logic , è component fondamental cpu assiem cu comp coordin azion necessar svolg istruzion . l&#39; unit controll ricev segnal relat alu . </answer_text><num_votes>0</num_votes></answer><answer id="A1886"><answer_text>l&#39; uc è l&#39; unit controll coordin tutt azion necessar l&#39; esecu più istruzion cpu ; conseguent è coinvolt gestion dell&#39; alu attravers azion dett micro-istru . l&#39; alu è tipolog processor digital grad svolg oper logic aritmet . sintes poss dir l&#39; uc gest l&#39; alu svolg oper . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ1961"><question_text>com si può defin algoritm qual propriet ? </question_text><answer id="A2012"><answer_text>algoritm è sequenz precis oper , comprens esecutor defin sequenz fin pass port realizz comp , (in informat esser scritt linguagg programm comprens calcol codif è dett programm ) . propriet : correttezz : l&#39; algoritm esser corrett port soluzion problem ; efficient : l&#39; algoritm ottien risolu problem usand risors minim . </answer_text><num_votes>3</num_votes></answer><answer id="A1897"><answer_text>algoritm è proced risolv determin problem attravers numer precis fin oper , comprens dall&#39; esecutor . propriet : correttezz perc l&#39; algoritm perven soluzion problem salt nessun pass ; efficient perc l&#39; algoritm arriv super ques minor numer oper possibil . ambedu quest propriet dev coesist corrett riusc programm . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2162"><question_text>tip valor può conten variabil tip doubl variabil tip float ? </question_text><answer id="A2007"><answer_text>variabil tip doubl variabil tip float poss conten valor appartenent all&#39; insiem numer real . semplic l&#39; utilizz variabil tip doubl permett numer cifr maggior dop virgol (fin 15-16 cifr ) . variabil tip float riserv infatt memor 4 byte mentr tip doubl riserv 8 . </answer_text><num_votes>1</num_votes></answer><answer id="A1913"><answer_text>i tip primit float doubl rappresent i numer virgol mobil , rappresent l&#39; insiem numer real . different i tip è numer bit riserv memorizz variabil , si riflett rang numer numer cifr dop virgol si poss memorizz ; i float usan 32 bit , rappresent numer 10^ ( -45 ) 10^ ( -38 ) circ ; i doubl (dopp precision ) usan 64 bit , descriv i numer 10^ ( -324 ) 10^ (308 ) circ . </answer_text><num_votes>0</num_votes></answer><answer id="A1901"><answer_text>variabil tip float contien numer real mentr variabil doubl contien anch&#39; essa numer real &#34; &#34; different variabil doubl numer bit riservatiall rappresent numer maggior quell variabil float . specif fariabil float 32 bit mentr variabil doubl 64 bit . </answer_text><num_votes>1</num_votes></answer><answer id="A1908"><answer_text>entramb utilizz dichiar variabil numer reali(es . numer virgol ) . l&#39; unic different sta fatt variabil tip doubl può mantiss (cifr destr virgol ) più lung più precis quell variabil dichiar tip float . parol doubl più bit dedic memorizz (64 bit ) contrar float , men (32 bit ) . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2039"><question_text>visualizz vide string , inser %s %c printf ? </question_text><answer id="A1881"><answer_text>visualizz vide string inser %s printf . </answer_text><num_votes>0</num_votes></answer><answer id="A1861"><answer_text>visualizz vide string bisogn inser %s all&#39; intern com stamp otten rig codic sar simil quest : printf ( &#34; % s &#34; , string ) ; avess inser %c all&#39; intern com stamp avre visualizz scherm variabil tip char . printf ( &#34; % c &#34; , variabilec ) ; entramb i cas string , variabil tip char , dev comunqu esser stat dichiar inizializz , altriment fas compil veng rilev error . </answer_text><num_votes>4</num_votes></answer><answer id="A1801"><answer_text>letter segu % dip tip variabil si assegn : %d variabil inter %f variabil float / doubl %e decimal notazion esponenzial %c variabil tip caratt ( char ) </answer_text><num_votes>0</num_votes></answer><answer id="A1880"><answer_text>visualizz vide string inser %s printf . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2068"><question_text>perc è necessar svuot fil stdin quand si legg variabil tip char tastier ? </question_text><answer id="A2029"><answer_text>variabil programm memorizz memor primar calcol . memor primar è piccol non si poss memorizz grand quantit dat ; perc variabil tip char vien rappresent memor mediant byte ,convien svuot fil stdin quand si legg . </answer_text><num_votes>0</num_votes></answer><answer id="A1946"><answer_text>è necessar svuot fil stdin quand si legg variabil tip caratt tastier , perc dop aver esegu programm inser i valor tastier rimang memorizz non quest valor caratter (com invi ) dop chiusur dell&#39; esecu , caus mal funzion programm . esemp utent dig numer 8 conferm invi , verrebb prelev fil input valor 8 valor invi . </answer_text><num_votes>1</num_votes></answer><answer id="A1902"><answer_text>siccom funzion scanf %c , attend input caratt prim inser variabil predestin mett fil std , quand prem invi dop aver mess caratt esemp &#34; p &#34; compil mett fil std codic asci tast invi consider anchess input , cos fil std è &#34; sporc &#34; , far mod prossim scanf vad tutt ben , pul fil std funzion fflush , cos l&#39; inser prossim input potr avven . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ1997"><question_text>signific i parametr funzion main : &#34; ( int argc , char *argv[ ] ) &#34; ? </question_text><answer id="A1935"><answer_text>parametr argc signif &#34; argument count &#34; contien numer string inser dall&#39; utent line com , mentr argv signif &#34; argument vector &#34; è parametr contien array string . ogni argoment dell&#39; array è puntator caratt . </answer_text><num_votes>0</num_votes></answer><answer id="A1938"><answer_text>parametr argc , dichiar com int (int argc ) , argv , dichiar com array puntator char (char*argv[ ] ) serv pass programm i parametr inser line com (command tail ) moment si richied sistem oper mand esecu programm . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2146"><question_text>spieg brevement funzion svolg i component dell&#39; architettur hardw calcol . </question_text><answer id="A1923"><answer_text>l&#39; architettur hardw calcol è compost : processor cpu svolg l&#39; elabor programm , memor central ram utilizz memorizz dat istruzion esegu , memor mass utilizz memorizz grand quantit dat programm manier permanent (quind non volatil com ram ) , perifer var tip infin bus sistem interconnett tutt component permett scamb dat essi . </answer_text><num_votes>1</num_votes></answer><answer id="A1847"><answer_text>cpu contien disposit elettron grad acquis , interpret esegu istruzion ; memor central (ram ) è memor volatil accogl dat programm qual oper calcol ; memor mass (rom ) memorizz grand quantit dat programm manier persistent , cio non volatil ; perifer permett scamb inform calcol l&#39; estern ; bus sistem interconnett component , consent scamb dat . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2027"><question_text>serv i simbol %d %f %c %e %g %s %u %x ? </question_text><answer id="A2020"><answer_text>quest simbol caratter conversion funzion è seguent : - %d l&#39; argoment è convert notazion decimal ; - %f l&#39; argoment contien numer decimal ; - %c l&#39; argoment contien unic caratt ; - %e l&#39; argoment contien numer decimal espress notazion scientif ; - %g l&#39; argoment contien numer decimal , più cort %e %f ; - %s string ; - %u l&#39; argoment è convert decimal segn ; - %x l&#39; argoment è convert esadecimal </answer_text><num_votes>0</num_votes></answer><answer id="A1912"><answer_text>quest caratter controll variabil ambient c . %d si utilizz variabil tip inter segn , mentr i decimal segn denot %u . %f è usat variabil tip float (real ) %c i caratter . insiem caratter (string ) si denot %s . %e si usa notazion esponenzial argoment tip float . %x è caratter esadecimal . %g è particol estension %e . trov comand printf scanf. </answer_text><num_votes>2</num_votes></answer><answer id="A1972"><answer_text>simbol % (segu letter ) , permett sovrascriv (e inizializz ) rend leggibil conten cell memor relat variabil abbiam gia dichiar . cas %d,il calcol stamp vide sarem inser numer intero,per %f numer è reale,per %c caratt ,il %s è relat string ,% relat notazion scientif ,% g relat esponenzial real , %x numer esadecimal ,% u integral . </answer_text><num_votes>0</num_votes></answer><answer id="A2021"><answer_text>quest simbol caratter conversion funzion è seguent : - %d l&#39; argoment è convert notazion decimal ; - %f l&#39; argoment contien numer decimal ; - %c l&#39; argoment contien unic caratt ; - %e l&#39; argoment contien numer decimal espress notazion scientif ; - %g l&#39; argoment contien numer decimal , più cort %e %f ; - %s string ; - %u l&#39; argoment è convert decimal segn ; - %x l&#39; argoment è convert esadecimal </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2020"><question_text>e&#39; possibil svolg oper variabil tip divers , esemp moltipl variabil &#34; int &#34; variabil &#34; float &#34; ? perc ? </question_text><answer id="A2011"><answer_text>sì , è possibil effettu oper variabil tip divers , patt risult inser contenitor tip float (in cas ) . risult foss assegn variabil tip inter perd tutt cifr decimal . espression scritt corrett è tip c = (float ) a*b , dov è variabil tip int b tip float . </answer_text><num_votes>3</num_votes></answer><answer id="A1790"><answer_text>cert , esemp med vien defin com somm numer int med numer float; occorr per ricord defin poi l&#39; oper camp float mett parentes prim dell&#39; oper . esemp med = (float ) somma/x ; x indic element otten med . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2135"><question_text>perc progett calcol è scelt utilizz sistem binar ? sarebb possibil progett calcol funzion decimal bas numer ? </question_text><answer id="A2031"><answer_text>i modern elabor elettron verific presenz (o men ) corrent all&#39; intern circu . l&#39; unit fondamental inform veng rappresent , bit , assum pertant soltant : &#34; 1 &#34; &#34; 0 &#34; . sarebb cert possibil realizz computer sensibil , esemp , all&#39; intens corrent , permett oper bas different , attual tecnolog sarebb particolar compless assicur calcol affid più . </answer_text><num_votes>1</num_votes></answer><answer id="A1961"><answer_text>perc unic tip sengnal on/off si poss scamb tutt inform si desider . scrittur aument lunghezz l&#39; elabor è cos grad distingu facil segnal div . cre elabor bas numer different è possibil già esist (trit-calcol ternar ) . bas decimal sarebb complic realizz 10 segnal different . </answer_text><num_votes>1</num_votes></answer><answer id="A1947"><answer_text>stat test part calcol progett bas ternar (ma bas 4 , 8 16 , com multipl sistem binar ) progett component memor trasmission inform . tuttav sistem binar è più comun poic semplif i process rend conseguent più veloc ; inoltr alcun cas non esist terz altern (es : on/off ) : determin component sarann sempr bas sistem binar . </answer_text><num_votes>2</num_votes></answer><answer id="A1931"><answer_text>poic è più semplic interpret circu elettr sol fas dat 0 dall&#39; 1 ( &#34; non pass corrent 0 &#34; , &#34; pass corrent 1 &#34; ) . si è possibil progett calcol div sistem numer , ciò rend più difficil progett controll error sistem . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2041"><question_text>funzion fflush (stdin ) serv svuot buffer prim legg input caratt . quand effett utilizz ? </question_text><answer id="A1977"><answer_text>fflush (stdin ) serv imped error lettur input tastier variabil tip char . scrittur tip : scanf( &#34; % c &#34; , &#38;dato1 ) ; scanf( &#34; % c &#34; , &#38;dato2 ) ; non è funzional poic dop l&#39; inser caratt pression tast &#34; invi &#34; sar interpret com input . scriv : scanf( &#34; % c &#34; , &#38;dato1 ) ; fflush (stdin ) ; scanf( &#34; % c &#34; , &#38;dato2 ) ; imped error pooic fflush (stdin ) elimin buffer caratt &#34; invi &#34; prim input </answer_text><num_votes>2</num_votes></answer><answer id="A1943"><answer_text>dop l&#39; inser cert tip dat , different variabil tip int float , l&#39; inser dat success tip caratt è necessar svuot prim buffer input . infatt , l&#39; oper scanf potrebb esser ripet , essendoc buffer cert tip caratt , si ricorr error . far sì non accad , bisogn inser fflush (stdin ) prim scanf( &#34; % c &#34; , &#38;car ) printf ( &#34; car=% c \n &#34; , car ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2027"><answer_text>funzion fflush utilizz quand , prim acquis variabil caratt , lett variabil tip . perc buffer scanf rimang memorizz caratter (ad esemp i caratter invi ) non valid variabil numer rimang finc non vien inser variabil char . </answer_text><num_votes>2</num_votes></answer><answer id="A1851"><answer_text>funzion fflush (stdin ) utilizz dop scanf pul buffer tastier ogni caratt rimast “non vol ” . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2040"><question_text>serv i codic asci ? </question_text><answer id="A2004"><answer_text>codic asci è sistem codif 7 bit vien comun usat calcol . codic permett determin tabell codic fann rifer caratter . i prim 32 (0-31 ) 127 caratter non stampabil perc controll . i restant rappresent tutt i caratter stampabil . stat propost soluzion 8 bit permett raddopp i caratter per quell più comun utilizz è 7 bit . sistem approv iso 646 . </answer_text><num_votes>4</num_votes></answer><answer id="A1997"><answer_text>asci si intend codic standard usat codif caratter . codic &#34; extended asci &#34; ogni caratt vien riserv byte corrispond , , sequenz 8 bit . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2001"><question_text>ram rom tip memor caratterist general simil , consist different ? </question_text><answer id="A1992"><answer_text>different principal : memor ram è volatil può esser cancell sovrascritt , rom non può esser modific sovrascritt nessun mod perc è possibil legg conten apport nessun modif . inoltr rom è permanent è caratterizz d&#39; access maggior ram , vien continu modific essend rapid dirett access . </answer_text><num_votes>2</num_votes></answer><answer id="A2025"><answer_text>different principal memor ram memor tip rom è prim è volatil , second permanent . pertant conten ram verr pers qundo cess l&#39; aliment sistem . un&#39; altra different è access : mentr ram (random access memory ) i l access è brev indipendent dall&#39; indirizz parol vogl acced , rom esso è maggior . quest ultim inoltr memor access sequenzial . </answer_text><num_votes>1</num_votes></answer><answer id="A2014"><answer_text>ram è memor volatil , qual veng &#34; conserv &#34; i dat cors elabor istruzion programm computer esecu , tutt ciò vien pers quand si spegn calcol . rom , , è memor permanent sol lettur , vien scritt sol volt è tipic utilizz memorizz dat programm serv moment dell’accension calcol . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2003"><question_text>cos&#39; è macchin &#34; von neumann &#34; ? qual different macchin astratt linguagg c ? </question_text><answer id="A1999"><answer_text>macchin von neumann rappresent mod maggior part calcol è organizz livell hardw . i element principal : cpu , memor central , memor mass , perifer bus sistem . macchin astratt linguagg c si bas quell von neumann , divers essa possied standard input standard output . quest suddivis cell (variabil ) , ognun qual contien dat immess dall&#39; utent . </answer_text><num_votes>0</num_votes></answer><answer id="A1822"><answer_text>macchin &#34; von neumann &#34; è modell hardw oper manier sequenzial .e&#39; form var component : processore,l memor central ,la memor mass var perifer ;son interconness bus sistem trasfer i dat sincronizz &#34; clock &#34; dall&#39; unit controllo.l macchin astratt c rispett quest caratterist struttur softw .e&#39; compost dall&#39; unit central ,dall memor central ,da perifer standandard i/o bus sistem . </answer_text><num_votes>2</num_votes></answer><answer id="A1983"><answer_text>macchin von neumann si intend modell hardw modern calcol cpu,l memor perifer comunic attravers bus sistem . fas elabor istruzion part cpu scand clock cu stabil funzion svolg . macchin lavor manier sequenzial . macchin c è un&#39; astrazion prim permett memorizz esegu programm c attravers l&#39; uso struttur dat algoritm . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ1969"><question_text>qual mot bisogn utilizz com fflush (stdin ) ? particol , succed vien valorizz tastier variabil tip &#34; char &#34; dop avern valorizz tip &#34; int &#34; , utilizz com fflush (stdin ) ? </question_text><answer id="A1793"><answer_text>quand si inser valor tastier si prem invi , vien salv fil chim &#34; stdin &#34; . esemp si inser prim variabil tip inter (int ) success caratt (char ) , quest&#39; non è possibil inser dat valor caratt vien pres fil &#34; stdin &#34; . prim scriv com &#34; scanf( &#34; % c &#34; , &#38;i ) ; &#34; è necessar svuot buffer stdin com &#34; fflush (stdin ) &#34; . </answer_text><num_votes>0</num_votes></answer><answer id="A1811"><answer_text>com fflush (stdin ) serv cancell ciò c&#39; è all&#39; intern dell&#39; input buffer .vol acquis tastier valor assoc variabil tip inter si dig prim dat numer dop si prem tast invi . valor digit vien inser nell&#39; indirizz variabil mentr nell&#39; input buffer riman valor par tast invio.s vien poi valorizz varibil tip char quest vien assoc invi quant valor valid quel tip variabil . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ2143"><question_text>signif string : &#34; system ( &#34; paus &#34; ) ; &#34; ? e&#39; essenzial funzion programm può esser omess ? </question_text><answer id="A1974"><answer_text>&#34; system( &#34; paus &#34; ) ; &#34; è dirett vien dat compil , qual sosp l&#39; esecu programm non vien prem tast . quest dirett programm si chiud appen esegu l&#39; ultim istruzion . &#34; system( &#34; paus &#34; ) ; &#34; è essenzial si vuol programm non si chiud automat process . </answer_text><num_votes>0</num_votes></answer><answer id="A1957"><answer_text>string &#34; system( &#34; paus &#34; ) ; &#34; è essenzial programm . e&#39; consigl , non indispens , utilazz quest string poic essa finestr esecu programm si chiud all&#39; istant , imped cos controll risult . inser &#34; system( &#34; paus &#34; ) ; &#34; è possibil manten apert finestr esecu tutt necessar consult . finestr vien poi chius prem qualsias tast tastier . </answer_text><num_votes>1</num_votes></answer><answer id="A1815"><answer_text>system ( &#34; paus &#34; ) serv sospend l&#39; esecu programm utent non prem tast (a vide verr visualizz : &#34; prem tast continu &#34; ) .in pratic serv visualizz finestr l&#39; output previst durant l&#39; esecu programm (util verific correttezz ) .se non è present finestr vien chius termin dell&#39; esecu poter visualizz &#34; risult &#34; dunqu potrebb esser omess (dip tip programm cre ) </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2013"><question_text>si intend fas fetc ? </question_text><answer id="A1984"><answer_text>ll fetc è prim fas fondamental dell&#39; elabor sequenzial programm calcol elettron , qual volt si articol 4 pass , ogni pass corrispond trasfer dat i registr cpu e/o alloc specif memor central . fas fetc è fas prel istruzion , caric nell&#39; ir (instruction register ) . fas fetc segu fas decod , fas exec . </answer_text><num_votes>0</num_votes></answer><answer id="A1792"><answer_text>fas fetc è prim fas l&#39; esecu programma.l fas fetc cpu legg istruzion memor ram . particol fas fetc vien esegu 4 pass : 1.la cu cop conten pc ar 2.vien lett ram conten all&#39; indirizz dat ar 3.il dat lett mess disposizion dr 4.il conten dr spost cir cu-controlunit,pc-programcounter ,ar-addressregister,dr-dataregister,cir-currentinstructionregister </answer_text><num_votes>2</num_votes></answer><answer id="A1942"><answer_text>fetc è prim fas cicl esecu programm compr : 1 l&#39; invi part dell&#39; unit controll segnal affinc conten program counter trasfer nell&#39; address register . 2 l&#39; invi segnal memor affinc veng lett dat appen trasfer . 3 l&#39; inser dat lett dat register . 4 l&#39; invi segnal controll part dell&#39; uc affinc conten dat register spost registr istruzion corrent . </answer_text><num_votes>2</num_votes></answer><answer id="A1985"><answer_text>ll fetc è prim fas fondamental dell&#39; elabor sequenzial programm calcol elettron , qual volt si articol 4 pass , ogni pass corrispond trasfer dat i registr cpu e/o alloc specif memor central . fas fetc è fas prel istruzion , caric nell&#39; ir (instruction register ) . fas fetc segu fas decod , fas exec . </answer_text><num_votes>0</num_votes></answer><answer id="A1954"><answer_text>fas fetc è fas acquisizion ogni istruzion . essa è compost pass : 1 . l&#39; unit controll mand segnal affinc conten registr contator programm veng trasfer registr indirizz 2 . memor ricev dat controll legg dat registr indirizz 3 . dat vien trasfer registr dat 4 . l&#39; unit controll mand segnal affinc conten registr dat spost registr istruzion corrent . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2117"><question_text>pes i div component hardw veloc computer , proporzion ? avend disposizion budget limit , qual component sarebb prefer invest ? </question_text><answer id="A1839"><answer_text>sicur cpu memor ram copp poter caric dat elabor veloc . poi memor fiss : hard disk access lent , più capient , memor solid (ssd ) più veloc capac ridott . perifer (sched aud , vide , ret , ecc. . ) non influent veloc calcol (ultim per alcun softw sfrutt gpu parallel cpu calcol compless ) . si necess veloc , invest prim 3 </answer_text><num_votes>0</num_votes></answer><answer id="A1827"><answer_text>component hardw maggior pes veloc computer cpu , infatt più è elev frequenz impuls clock , più è elev numer istruzion esegu unit . secondar prestazion pc influenz memor ram dispon (e tip memor -sram dram - ) , veloc trasfer dat disc memor . mot è prefer invest potenz processor . </answer_text><num_votes>0</num_votes></answer><answer id="A1950"><answer_text>cpu pes maggior veloc computer , segu i registr , sram , dram , memor mass infin tutt i rimanent component . è dover precis non esist scal precis stabil qual component influ maggior veloc final computer . avend budget limit bisogn invest component nell&#39; ordin scritt , consider invest dovrebber bas sull&#39; utilizz dell&#39; utent specif . </answer_text><num_votes>1</num_votes></answer><answer id="A1971"><answer_text>alcun component computer men fondamental comunqu veloc computer dip veloc calcol processor memor cach mont giust sched madr memor ram contien tutt i dat i programm coinvolt nell&#39; elabor corrent .infin veloc computer nell&#39; esegu un&#39; elabor dip numer applic esecu .quind sarebb opportun invest microprocessor ram . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ1983"><question_text>cos&#39; è l&#39; overflow ? fai esemp . </question_text><answer id="A2028"><answer_text>l&#39; overflow si verif quand ,esegu un&#39; oper numerica,il numer risult super massim numer calcol può rappresent </answer_text><num_votes>1</num_votes></answer><answer id="A2026"><answer_text>overflow si intend quand programm richied spaz maggior disposizion , quand durant l’esecu programm gener valor aritmet maggior capac cell memor dedic risult . esemp cre cicl infin andrem increment variabil ogni cicl sicur prim poi si verific overflow (con cell memor 8 bit massim numer si può salv prim entrar overflow è 255 ) . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ2165"><question_text>com mai scanf, apic dov sol scriv %d , è non scriv ? esemp scanf( “ valore=% d ” , &#38;valor ) ; dovre inser tastier cas assegn valor valid variabil valor ? </question_text><answer id="A1809"><answer_text>e&#39; non scriv perc cas contrar dovre inser tastier ciò non è l&#39; identif sta apic affinc variabil veng valorizz mod corrett . cas assegn valor valid variabil valor dovre scriv all&#39; intern programm &#34; valore= &#34; segu valor inter desider . </answer_text><num_votes>0</num_votes></answer><answer id="A1854"><answer_text>perc inser = calcol ragion mod , fa ragion , paragon %d altra variabil risult non conform ciò vol raggiung . </answer_text><num_votes>0</num_votes></answer><answer id="A1877"><answer_text>scanf è non scriv caratt controll (es . %d ) poic si inser qualsias valor , poss esser problem durant l&#39; esecu programm . si dovrebb inser : printf ( &#34; valore= &#34; ) ; scanf( &#34; % d &#34; , &#38;valor ) ; </answer_text><num_votes>1</num_votes></answer><answer id="A1976"><answer_text>inser caratter div caratter controll all&#39; intern virgolett funzion scanf( &#34; &#34; ) provoc error lettur dell&#39; input . utilizz notazion scanf( “ valore=% d ” , &#38;valor ) non otten risult si otterrebb printf ( &#34; valore= &#34; ) scanf ( &#34; % d &#34; , &#38;valor ) , variabil &#34; valor &#34; potrebb esser inser valor errat (qualsias l&#39; input tastier ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2012"><question_text>si intend linguagg alto livell ? </question_text><answer id="A1949"><answer_text>linguagg alto livell si intend linguagg comprens utilizz person desider utilizz tal linguagg programm compil si programm . i linguagg alto livell più comun c , c++ , pascal , jav . tram compil linguagg alto livell vien tradott linguagg binar , unic linguagg macchin conosc compr . </answer_text><num_votes>0</num_votes></answer><answer id="A2019"><answer_text>linguagg alto livell è linguagg programm più vicin logic linguagg natural , mod si rend programm più leggibil indipendent caratterist dell&#39; hardw linguagg bass livell . </answer_text><num_votes>1</num_votes></answer><answer id="A2016"><answer_text>linguagg alto livell si intend linguagg permett livell astrazion tal poter esser compres programm , riconosc intern struttur bas , compil , programm potr convert linguagg comprens calcol . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ1962"><question_text>perc nell&#39; utilizz com &#34; scanf&#34; è import , dop aver dichiar opportun caratt controll , inser &#34; &#38; &#34; prim variabil qual vogl memorizz dat ? </question_text><answer id="A1926"><answer_text>quant contrar com &#34; printf &#34; , &#34; scanf&#34; salv valor è necessar attribu indirizz quel valor andrà salv ciò avvien utilizz l&#39; oper &#34; &#38; &#34; . </answer_text><num_votes>0</num_votes></answer><answer id="A1934"><answer_text>&#38; commercial è necessar quant restitu com scanf l&#39; indirizz dell&#39; oper allocare/assegn valor input . moment non foss &#38; commercial , com esemp : scanf( &#34; % d &#34; , ) ; &#34; &#34; verr vist com oper , ossi com &#34; valor &#34; , scanf non sar grad assegn valor input quand non ved l&#39; indirizz , &#34; &#38; &#34; vien pass com indirizz &#34; &#34; . </answer_text><num_votes>2</num_votes></answer><answer id="A1973"><answer_text>funzion dell&#39; &#34; &#38; &#34; sint funzion &#34; scanf&#34; verr tratt nell&#39; argoment riquard i puntator . signific è comunqu assegn valor inser variabil dichiar altriment compil non cap dov salv dat inser . l&#39; &#34; &#38; &#34; è defin puntator propr mot segnal compil variabil predispost accogl valor dichiar . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2163"><question_text>perc comand com &#34; scanf&#34; &#34; printf &#34; non fann part parol chiav linguagg c ? qual librer è necessar includ ? </question_text><answer id="A2008"><answer_text>linguagg c (com qualunqu ) consent realizz programm serv dell&#39; utilizz &#34; keywords &#34; (parol chi ) . i comand &#34; scanf&#34; &#34; printf &#34; non fann rigor part linguagg c , bens librer standard ; usufru quest bisogn includ librer &#60;stdi .h&#62; . </answer_text><num_votes>0</num_votes></answer><answer id="A1796"><answer_text>&#34; printf ( ) &#34; &#34; scanf ( ) &#34; non keywords c comand consent programm interag mond estern . &#34; printf ( ) &#34; permett scriv vide messagg (output ) , mentr &#34; scanf ( ) &#34; consent legg i dat inser tastier memorizz variabil (input ) . poter utilizz quest comand è necessar inser librer gestion perifer input/output macchin virtual , ovver scriv fuor &#34; main{ } &#34; : &#34; # includ &#60;stdi .h&#62; &#34; . </answer_text><num_votes>1</num_votes></answer><answer id="A1964"><answer_text>utilizz istruzion scanf printf è necessar includ librer &#34; # &#60; stdi .h&#62; &#34; keyword parol fondamentali,infatt non è necessar inizializz alcun librer utilizz ,quest rimang tal applic c (es : microcontrollor ) , mentr istruzion elenc non fiss , utilizz linguagg c altra piattaform avrò librer istruzion divers , keyword rimarrann tal perc propr c. </answer_text><num_votes>1</num_votes></answer><answer id="A1803"><answer_text>parol chiav linguagg c parol riserv linguagg , esemp int , char , float..., non poss esser usat com identif funzion variabil . scanf printf funzion predefin linguagg c permett effettu l&#39; input l&#39; output consoll fann part librer standard input\output present nell&#39; intest programm (# includ &#60;stdi .h&#62; ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ1973"><question_text>qual caratterist differ memor archiv mass memor central (r.a.m. ) ? </question_text><answer id="A1988"><answer_text>memor ram si tratt memor volatil , ovver tutt conten all&#39; intern essa vien pers quand cess l&#39; aliment sistem . contrar memor archiv mass può conten dat manier permanent spegn calcol . memor ram è inoltr più piccol quell mass present access (temp intercorr richiest element leggere/scriv ) gran lung maggior quell mass . </answer_text><num_votes>0</num_votes></answer><answer id="A1990"><answer_text>memor ram è memor &#34; volatil &#34; , poic quand essa non vien più aliment perd i dat intern . ram più veloc (e più costos ) memor archiv mass , qual memor persistent different prim . </answer_text><num_votes>1</num_votes></answer><answer id="A1802"><answer_text>memor ram è memor volatil , different disposit memor mass memor persistent (es . hard disk ) ; memor differ tuttav un&#39; aspett : ram (per l&#39; appunt random access memory ) è più veloc memor mass quant d&#39; access locazion memor caratterizz è indipendent dall&#39; indirizz words . </answer_text><num_votes>3</num_votes></answer><answer id="A2017"><answer_text>memor central è volatil : si perd inform quand cess l&#39; aliment sistem ; memor mass è non volatil : è grad manten inform essa conten quand cess l&#39; aliment sistem (hard disk rom ) . memor central d&#39; access fiss non dip dimensione/posizion parol codic cerc ;in quell mass d&#39; access dip veloc lettur dat posizion . </answer_text><num_votes>0</num_votes></answer><answer id="A2002"><answer_text>memor ram funzion primar ricev un’enorm quantit dat finc pc sta elabor , comp cre access dirett tutt indirizz brev veloc elev . quant riguard memor mass ,invec , comp raccogl grand quantit dat veng immagazzin , vien defin different ram com memor non volatil , comp registr , conserv permett rilettur dat . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ1976"><question_text>mod fattor estern , com quantit memor dispon influenz veloc sistem nonost impuls clock ? </question_text><answer id="A1821"><answer_text>clock permett alte veloc elabor i dat arriv lent calcol sar lent quant elabor i dat mod veloc quand ricev . sarann veloc fas elabor segu lent fas attes .esemp : paragon fluss dat d&#39; acqua corrent tub strozzatur (ram... ) ; lev strozzatur non otten null poic rimang . velocizz fluss si dev ridurr tutt strozzatur . </answer_text><num_votes>0</num_votes></answer><answer id="A1979"><answer_text>frequenz impuls gener clock – dipendent cpu – veloc sistem può esser influenz quantit memor dispon . diminu quantit memor disposizion , infatt , diminu numer dat istruzion potrann esser conten essa conseguent esegu un’un , indipendent impuls gener dall’orolog intern . contribu ridurr veloc sistem . </answer_text><num_votes>2</num_votes></answer><answer id="A1824"><answer_text>computer rallent è dat fatt ogni process cors è sempr concorrent quantit risors (es : cpu memor ) alloc . front cert frequenz clock dat programm lavor memor ram , access costant , mot rallent è dat richiest spaz memor non dispon (cio quand ram è pien ) scars disponibil . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2082"><question_text>qual&#39; è stat necess port differenz memor volatil non volatil , perc calcol c&#39; è bisogn unit memor (central mass ) struttur complet divers ? </question_text><answer id="A2030"><answer_text>necess port differenz stat : -il bisogn otten memor qual acced veloc riusc cos implement maggior numer oper cpu nell&#39; unit (volatil ) ; -un memor grad manten inform quand non vien aliment , cio capac salv permanent i dat (non volatil ) . port formazion unit separ , comp div , calcol . </answer_text><num_votes>1</num_votes></answer><answer id="A1894"><answer_text>computer bisogn memor non volatil (rom ) perc aver possibil manten sempr salv i programm sistem funzion . mentr ram è stat cret salv process continu camb . stat cre sched memor divers . </answer_text><num_votes>0</num_votes></answer><answer id="A1987"><answer_text>memor central quant volatil , present access cell ridott è inoltr indipendent dall&#39; indirizz &#34; word &#34; qual si vuol acced , caratterist permett dirett collabor cpu . essa per necess un&#39; aliment costant tratten i dat inser sistem inoltr ridott capac essa obblig compresent memor mass grad memorizz maggior quantit programm mod persistent . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2067"><question_text>si intend sistem legacy ? </question_text><answer id="A1968"><answer_text>letteral &#34; sistem ereditar &#34; ovver sistema/appl (es . l&#39; applic commercial cobol ) non recent invenzione/costru , per valor . cio sistem &#34; dat &#34; conserv valor all&#39; intern mond continu evolu . sistem non facil modif sostitu od upgrad . julius k . baah donkor matricol : 167124 </answer_text><num_votes>1</num_votes></answer><answer id="A1808"><answer_text>sistem &#39;legacy&#39; si rifer softw hardw , pur essend dat , continu esser utilizz funzional mancanz altern valid . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2128"><question_text>perc all&#39; iniz programm serv quest righ : #includ &#60;stdi .h&#62; #includ &#60;stdlib.h&#62; serv com funzion ? </question_text><answer id="A1967"><answer_text>simbol # rappresent dirett , ovver simbol comun processor includ qualcos . cas stiam includ librer : &#60;stdi .h&#62; è l&#39; header fil (.h ) librer standard linguagg c contien definizion variabil , funzion etc utilizz oper input output ; &#60;stdlib.h&#62; è sempr l&#39; header fil librer standard dichiar variabil costant util general , com esemp i tip dat . </answer_text><num_votes>2</num_votes></answer><answer id="A1899"><answer_text>librer fann part librer standard c . &#60;stdi .h&#62; forn funzional basilar input/output c , esemp permett usar funzion printf scanf. &#60;stdlib.h&#62; è neccessar esegu oper com esemp conversion alloc numer pseud casual . non veng inclus quest librer progett , tant funzion import util general com appunt printf scanf non poss esser usat . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2116"><question_text>qual è different algoritm programm ? </question_text><answer id="A1918"><answer_text>l&#39; algoritm indic pseudo-cod linguagg natural tal metod usar risolv problem mentr stesur programm si è fatt passagg più quant si è &#34; tradott &#34; l&#39; algoritm linguagg programm poss esser esegu calcolor . (n.b. concett algoritm non preved necessar problem debb esser risolt calcol ) </answer_text><num_votes>1</num_votes></answer><answer id="A1833"><answer_text>più different sarebb opportun parl rapport algoritm programm ; infatt i intercorr ordin rapport esistent gen (algoritm ) spec (programm ) ; infatt mentr gener algoritm può esser scritt qualunqu linguagg (linguagg natural ,matemat , ecc ... ) , programm è algoritm vien scritt linguagg (c .d. programm ) vien compres calcol sar l&#39; esecutor quell&#39; algoritm . </answer_text><num_votes>1</num_votes></answer><answer id="A2010"><answer_text>l&#39; algoritm è sequenz pass port risolu problem programm è traduzion dell&#39; algoritm linguagg comprens macchin . </answer_text><num_votes>0</num_votes></answer><answer id="A1819"><answer_text>algoritm è proced risolv determin problem attravers numer fin pass discret non ambigu . programm è algoritm post form comprens computer (scritt tram linguagg programm ) , cio insiem istruzion , tram esecutor (computer ) , produc soluzion i problem post . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2029"><question_text>consist proced top-down , perc tal proced risult fondamental ? </question_text><answer id="A1969"><answer_text>scrittur algoritm proced top-down consist nell&#39; aggiung sotto-algoritm (funzion ) specific un&#39; istruzion dell&#39; algoritm principal cas risult ambigu non abbast precis . mod si realizz algoritm livell superior chiar sintet si appogg algoritm livell inferior esegu mod estes istruzion più dettagl . </answer_text><num_votes>1</num_votes></answer><answer id="A2015"><answer_text>proced top-down consist scomporr problem tant sottoproblem più piccol dettagl .quest metod risult util corrett comprension problem , è spess fas fondamental rioluzion problem informat . </answer_text><num_votes>0</num_votes></answer><answer id="A1857"><answer_text>proced top-down consist suddivision programm partenz tant sottoproblem più semplic risolv . sottoproblem vien suddivis volt , necessar sottoproblem più semplic otten sottoproblem elementar , cio non ulterior scompon . tal proced risult fondamental miglior dell&#39; ingegner softw ovver : affid , leggibil , riutilizz revision . </answer_text><num_votes>1</num_votes></answer><answer id="A1919"><answer_text>top-down è proced preved affront problem part dall&#39; ultim fas : l&#39; obiett (top ) , affront man man i sottoproblem qual può esser scompost (down ) . proced risult fondamental affront soltant problem dirett colleg final , quant l&#39; obiett riman sempr focalizz . com ricett cucin , si part piatt final poi scomporl ingredient necessar non vicevers . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2129"><question_text>assegn valor float variabil integer , valor trov poi variabil ? </question_text><answer id="A1993"><answer_text>trov valor tronc , decimal dop virgol . esemp : 67.7 divent 67 </answer_text><num_votes>0</num_votes></answer><answer id="A1917"><answer_text>trov sol part inter numer assegn variabil . esemp : assegn valor 5.77 variabil tip integer , trov valor 5 assegn suddett variabil , (in parol pov , numer vien semplic tronc (non arrotond ! ! ) ) . </answer_text><num_votes>3</num_votes></answer><answer id="A2003"><answer_text>variabil trov valor integer (ovver i numer sinistr virgol ) </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2069"><question_text>com funzion conversion decimal binar ? </question_text><answer id="A1804"><answer_text>convert numer decimal binar è necessar divid numer decimal divisor 2 , cas calcol dia rest si segn 1 vicevers si segn 0 . 25|1 12|0 06|0 03|1 01|1 destr line vertical è numer binar 25 esser lett bass vers l&#39; alto . 25 (10 ) = 11001 (2 ) (10 ) = valor decimal (2 ) = valor binar </answer_text><num_votes>0</num_votes></answer><answer id="A1991"><answer_text>convert numer decimal binar è necessar effettu ser division 2 numer decimal . numer binar si ottien consider , cifr men signif più signif , i rest division effettu . esemp vogl convert numer 49 binar oper mod : 49 : 2=24 rest 1 24 : 2=12 rest 0 12 : 2=6 rest 0 6 : 2=3 rest 0 3 : 2=1 rest 1 1 : 2=0 rest 1 numer 49 notazion binar è 110001 </answer_text><num_votes>3</num_votes></answer><answer id="A1959"><answer_text>trasform numer binar decimal : ogni cifr numer decimal corrispond potenz 2 , quest cifr è &#34; 1 &#34; prend mett part , quest cifr è &#34; 0 &#34; pass successiva(proced destr vers sinistr ) , si calcol tram l’algoritm division , divid success 2 (bas sistem binar ) numer decimal convert consider i rest contrar . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2008"><question_text>succed assegn valor non inter variabil tip int? assegn esemp valor 3.9 somm numer 4 vien dat com risult ? </question_text><answer id="A1807"><answer_text>succed assegn valor non inter variabil tip inter è compil sar capac legg part real valor conseguent non legger cifr dop virgol . risult somm 3.9 4 sar 7 . </answer_text><num_votes>0</num_votes></answer><answer id="A1998"><answer_text>assegn valor non inter variabil inter , com esemp 3.9 , programm inizializz variabil soltant part inter numer . esemp assegn valor 3.9 variabil &#34; i &#34; stamp vide , legg &#34; i=3 &#34; . infatt , variabil inter i=3.9 somm j=4 , com risult otterrem valor 7 , qual è esatt somm part inter valor . </answer_text><num_votes>2</num_votes></answer><answer id="A1937"><answer_text>i numer inter , rappresent tip int , quell “senz virgol ” . svolg qualsias oper non verr consider part decimal . assegn valor non inter , esemp 3.9 valor visualizz consol sar soltant part inter (3 ) , mentr stamp mantiss bisogn dichiar variabil tip float . somm 4 numer 3.9 , risult mostr scherm 7,quind part inter , omett i numer dop virgol . </answer_text><num_votes>1</num_votes></answer><answer id="A2001"><answer_text>si assegn valor non inter variabil tip int (variabil tip inter ) , variabil assum valor corrispondent sol part inter numer assegn . cas veng assegn valor 3.9 variabil tip int , essa assum valor 3 , pertant somm numer 4 risult otten sar 7 . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2158"><question_text>spieg regol definizion variabil </question_text><answer id="A1868"><answer_text>variabil distint bas identif simbol . ogni identif è compost succession lett , cifr simbol underscor , post non mai cifr . linguagg c è cas sensit , bisogn attenzion all&#39; utilizz maiuscol minuscol . e&#39; viet utilizz identif più variabil variabil più identif . esist infin nom non si poss utilizz corrett lessical . </answer_text><num_votes>3</num_votes></answer><answer id="A1978"><answer_text>defin variabil signif assegn scelt dell&#39; utent locazion memor . esegu quest oper bisogn segu regol : -è obbligator defin tip dat conterr variabil (int,float,c , ... ) ; -po si defin scelt dell&#39; utent (è consigl scegl richiam signific dat vien inser ) . esemp : int altezz ; float lat ; </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2050"><question_text>quand è necessar usar com conversion variabil (casting ) ? </question_text><answer id="A1795"><answer_text>e&#39; necessar usarl quand compil esegu oper (somm , different etc ) più variabil disomogene (ad es . , int a=5 ; float b=2.5 ; ) salv risult variabil int c=a+b ; cos fac si perd part decimal (c=7 anzic 7.5 ) . , maggior comprension puliz codic , è specific form &#34; output &#34; (int , float , unsigned ... ) evit risult indesider . l&#39; esemp prim , si scriv int c = (int ) (a+b ) ; //c val 7 . </answer_text><num_votes>1</num_votes></answer><answer id="A1965"><answer_text>com casting convert tip variabil tip , è necessar usarl quand si vuol comp oper ,us tip variabil dichiar , risult errat approssim . com casting è denot parentes tond ( ) inter è scritt tip variabil convert variabil . esemp casting utilizz division numer inter risult è numer real , convert variabil inter real . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2137"><question_text>different c&#39; è linguagg compil linguagg interpret ? </question_text><answer id="A1995"><answer_text>linguagg compil part assembler alto livell tram tools (compil ) si pass compil linguagg macchin specif quel calcol quel tip sistem oper qual verr &#39; poi esegu . different linguagg interpret sta fatt compil non traduc linguagg macchin simul programm ambient virtual . rend possibil esegu programm calcol s.o. different . </answer_text><num_votes>1</num_votes></answer><answer id="A1963"><answer_text>linguagg è compil quand codic vien tradott dirett compil linguagg macchin . cas è compil inser programm compil tutt compless caratterizz struttur intern programm , andand caric dirett memor rend immediat esegu . linguagg è interpret quand è interpr estern compil tradurr codic linguagg macchin moment dell&#39; esecu . </answer_text><num_votes>0</num_votes></answer><answer id="A1863"><answer_text>i linguagg compil linguagg com c c++ dov esegu programm esser prim compil . caric programm calcol ricompilarlo. linguagg interpret , com jav , non pass attravers compilatore,m funzion macchin virtual esegu dirett codic . essi funzion ogni macchin dirett . svantagg , i linguagg interpret per veloc esecu inferior compil . </answer_text><num_votes>1</num_votes></answer><answer id="A1994"><answer_text>linguagg compil part assembler alto livell tram tools (compil ) si pass compil linguagg macchin specif quel calcol quel tip sistem oper qual verr &#39; poi esegu . different linguagg interpret sta fatt compil non traduc linguagg macchin simul programm ambient virtual . rend possibil esegu programm calcol s.o. different . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2042"><question_text>relat all&#39; architettur hardw calcol cpu mod riesc gest perifer tutt i component contemporan ? </question_text><answer id="A1996"><answer_text>modell von neumann macchin gest oper manier sequenzial (non poss esser esegu istruzion modal parallel non contemporan ) . oper , infatt , veng effettu mod sincr clock sistem gener intervall . ciascun quest intervall l&#39; unit controll stabil funzion svolg . cpu , component perifer inoltr comunic attravers bus sistem . </answer_text><num_votes>3</num_votes></answer><answer id="A1831"><answer_text>cpu , central processing unit , è processor calcol . gest tutt perifer contemporan graz : -il bus sistem , colleg tutt i component , rend dunqu raggiung messagg component -la frequenz clock stabil veloc processor , avend cos possìbil aument prestazion , riusc svolg più attiv contemporan </answer_text><num_votes>1</num_votes></answer></question><question id="QQ1967"><question_text>dat variabil integer ( int ) occup spaz memor equivalent 4 byte ( 32 bit ) , chiar numer memorizz non può esser lunghezz infin ; qual è numer memorizz più grand utilizz variabil integer (lim superior inferior ) ? </question_text><answer id="A1962"><answer_text>tipolog variabil integer : signed unsigned . l&#39; utent può decid usar l&#39; altra second valor verrann success assegn variabil . variabil signed int può conten valor -2147483648 +2147483647 . , variabil unsigned int può conten valor posit , cio 0 +4294967295 . </answer_text><num_votes>1</num_votes></answer><answer id="A1928"><answer_text>utilizz variabil tip &#34; int &#34; i numer memorizz dev esser compres -32768 32767 , si utilizz modif &#34; unsigned &#34; i numer si poss memorizz dev esser compres 0 65535 . </answer_text><num_votes>0</num_votes></answer><answer id="A1914"><answer_text>variabil tip int 32 bit può rappresent numer inter posit negat , infatt , bit indic segn . cas si avrà lim massim posit +2147483647 negat ?2147483648 . calcol numer massim numer rappresentabis si fa 2^n , per rappresent segn serv bit si potrann rappresent -2^ (n-1 ) numer negat +2^ (n-1 ) numer posit non è compres 0 . numer massim sar +2^ (n-1 ) -1 </answer_text><num_votes>1</num_votes></answer><answer id="A1904"><answer_text>variabil int immagazzin i valor negat tecnic complement . numer total valor immaganizz variabil int 32 bit : 2^32=4294967296 . tecnic complement i valor poss esser negat compres - (2^32 ) / 2 + (2^32 ) /2-1 . signif lim inferior è : -2.147.483.648 ; mentr superior è : 2.147.483.647 . </answer_text><num_votes>1</num_votes></answer><answer id="A2000"><answer_text>numer più grand è 2147483647 , più piccol -2147483648 . tip int occup si 32 bit , dedic segn (+ - ) . numer avrà disposizion 31 bit , è calcol fac 2^31 -1 è appunt ugual 2147483647 . numer minor bast , unic different è modul sar 1 più grand ( - 2^31 ) . perc 0 vien consider posit , numer negat posit è ugual . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2132"><question_text>quant riguard sistem oper gestion memor central , mod funzion &#34; riloc &#34; ? </question_text><answer id="A1929"><answer_text>riloc consist traduzion indirizz logic , ovver indirizz gener processor è esecu process , fisic , cio locazion esatt , fisic memor principal . esist tip div riloc present funzion different : quell static quell dinamica.l scop tal meccan , entramb i cas , è mett corrispondent indirizz logic indirizz fisic . </answer_text><num_votes>2</num_votes></answer><answer id="A2032"><answer_text>riloc dip mem central sist oper .generalizzando,il pc legg valor variabil attravers bus sistem assegn spaz virtual mem central .quest spaz nn è numer binar corrispond valor variabil memor può var bas tip incogn (ex : int ,char,float.. ) .riloc ,consist spost blocc dat memor contenent esemp variabil bus sistem . </answer_text><num_votes>0</num_votes></answer><answer id="A1834"><answer_text>riloc , all&#39; atto caric process , mett corrispondent &#34; indirizz virtual &#34; , &#34; indirizz fisic &#34; dov present risors necessar process . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2166"><question_text>quant variabil è possibil dichiar ? esist lim ? </question_text><answer id="A1960"><answer_text>non c&#39; è lim , per variabil dichiar veng mess stack programm dimension limit è possibil si riemp programm vad error . </answer_text><num_votes>0</num_votes></answer><answer id="A2022"><answer_text>si , esist massim variabil si poss dichiar , si tratt numer grand . var second tip variabil veng utilizz (int,float,char... ) second disponibil memor ram dov quest verrann memorizz . second tip variabil perc sapp ben ogni tip si distingu spaz occup memor . inoltr second quantit dispon memor ram perc è quest memor veng memorizz . </answer_text><num_votes>2</num_votes></answer><answer id="A1936"><answer_text>numer variabil è possibil dichiar non è limit var bas caratterist tecnic computer si sta impieg fas programm . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2052"><question_text>qual i bus present calcol qual è utilizz ? </question_text><answer id="A1953"><answer_text>bus sistem bus estension . svolg principal funzion : - funzion bus dat , permett scamb informzaion bidirezional i component - funzion bus indirizz , dov indirizz invi mod unidirezional dic cpu dov svolg funzion richiest - funzion bus controll ,coordin oper sistem mod tal evi conflitt permett comun nuov perifer tram slot . </answer_text><num_votes>0</num_votes></answer><answer id="A2013"><answer_text>bus calcol serv far comunic i var component calcol (memor mass , perifer , memor central , cpu ) . funzion bus è quell colleg element , trasmett ricev . bus è costitu tip line : line controll , bus dat bus indirizz . </answer_text><num_votes>0</num_votes></answer><answer id="A1952"><answer_text>bus sistem bus estension . svolg principal funzion : - funzion bus dat , permett scamb informzaion bidirezional i component - funzion bus indirizz , dov indirizz invi mod unidirezional dic cpu dov svolg funzion richiest - funzion bus controll ,coordin oper sistem mod tal evi conflitt permett comun nuov perifer tram slot . </answer_text><num_votes>0</num_votes></answer><answer id="A1981"><answer_text>i bus present calcol : bus dat , bus indirizz bus controll . bus dat serv trasfer i dat dall&#39; unit master all&#39; unit slav vicevers ; bus indirizz serv trasmett conten registr indirizz memor central ; infin , bus controll serv trasfer codic inform esegu dall&#39; unit central all&#39; unit slav , inform avven comp dell&#39; oper richiest dall&#39; unit slav all&#39; unit master . </answer_text><num_votes>3</num_votes></answer><answer id="A1951"><answer_text>bus sistem bus estension . svolg principal funzion : - funzion bus dat , permett scamb informzaion bidirezional i component - funzion bus indirizz , dov indirizz invi mod unidirezional dic cpu dov svolg funzion richiest - funzion bus controll ,coordin oper sistem mod tal evi conflitt permett comun nuov perifer tram slot . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ1999"><question_text>e&#39; possibil variabil si chiam &#34; 1counter &#34; ? motiv rispost . </question_text><answer id="A1924"><answer_text>, perc caratt variabil non può esser numer , esser letter . </answer_text><num_votes>0</num_votes></answer><answer id="A1932"><answer_text>, non è possibil , poic caratt &#34; 1 &#34; post iniz variabil non è compres compil . variabil &#34; counter1 &#34; è tranquill possibil . </answer_text><num_votes>0</num_votes></answer><answer id="A1955"><answer_text>, variabil identif porzion memor destin conten dat , può compost lett cifr , necessar non iniz numer . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2056"><question_text>qual è relazion linguagg programm linguagg macchin ? si intend livell astrazion ? </question_text><answer id="A2018"><answer_text>linguagg programm defin “livell astrazion ” è costitu alfabet , veng costru insiem parol chiav insiem regol sintatt l’us corrett parol linguagg . linguagg è tropp vicin macchin , risult difficil programm , mentr cas tropp vicin programm , i programm risult esser inefficient . l&#39; hardw esegu comand mediant circu binar (linguagg macchin ) . </answer_text><num_votes>0</num_votes></answer><answer id="A1830"><answer_text>linguagg programm vien tradott linguagg macchin poter esser esegu . i livell astrazion indic quant linguagg programm dist linguagg macchin (bass ) linguagg natural (alt ) . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2022"><question_text>riguard l&#39; alloc dat all&#39; intern memor central , spieg funzion registr dat registr indirizz . </question_text><answer id="A1859"><answer_text>registr dat : contien dat attual oggett elabor risult termin dell’esecu . registr indirizz : conteng indirizz usat acced cell si vuol far rifer . </answer_text><num_votes>0</num_votes></answer><answer id="A1870"><answer_text>i registr punt più alto gerarc memor , costitu mod più rapid sistem gest i dat poss esser dirett indirizz istruzion input output microprocessor . molt class registr , com esemp registr dat (dr ) registr indirizz (ar ) . vien usat memorizz numer inter , parol lett scriv mm . contien indirizz è usat acced memor . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ1964"><question_text>serv ricerc dicotom ? perc abbrev ricerc ? </question_text><answer id="A1852"><answer_text>ricerc dicotom , ricerc binar , è usat quand si cerc determin dat grupp , magar numer , dat array memorizz (obbligator ordin ) si vuol ridurr i temp lung risult ricerc sequenzial . ricerc dicotom ,infatt , risult esser più veloc perc esegu men confront ,utilizz access casual dat , ricerc sequenzial dunqu , cas compil , permett esegu men oper . </answer_text><num_votes>0</num_votes></answer><answer id="A1841"><answer_text>ricerc dicotom (o binar ) è algoritm ricerc permett trov , tram access casual , determin valor insiem ordin dat . algoritm oper men confront esemp algoritm ricerc sequenzial . prim trov l&#39; element med dat ordin ; corrispond cerc , termin ricerc . altriment val valor è maggior minor dell&#39; element med rip process finc non trov l&#39; element cerc </answer_text><num_votes>1</num_votes></answer><answer id="A1866"><answer_text>ricerc dicotom è algoritm velocizz ritrov dat list . essa elabor list ordin . vien ricerc dat punt central list , non si trov quest posizion si prosegu met list dov dat si dovrebb trov . si ricontroll dat central met pres esam . process si rip ritrov dat . ricerc è più veloc perc non controll tutt i dat scart met list ogni cicl . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ1971"><question_text>qual problem si può riscontr quand si effettu oper variabil tip float ? com si può risolv ? </question_text><answer id="A1940"><answer_text>tipic problem può insorg quand si effettu oper variabil tip divers (float int ) . e&#39; necessar anteporr &#34; ( float ) &#34; (senz virgolett ) all&#39; identif variabil tip int desider invoc , specific cos intend tratt com float . inoltr i valor numer inter dev termin .0 (es . 3.0 , 7.0 ) . es : int = 6 ; float f; f= (float ) / 3.0 ; // f val 2 quest oper è dett typecasting . </answer_text><num_votes>0</num_votes></answer><answer id="A1888"><answer_text>problem principal è l&#39; approssim variabil float,es : 20.30 può ven scritt compil com 20.2999 . infatt i numer virgol mobil non esatt poss condurr risult &#34; stran &#34; . super problem non bisogn verific i valor sian esatt quell si aspett usand l&#39; aritmet standard , bisogn verific i valor calcol si trovin all&#39; intern intorn risult attes defin cert margin eps . </answer_text><num_votes>1</num_votes></answer><answer id="A1941"><answer_text>tipic problem può insorg quand si effettu oper variabil tip divers (float int ) . e&#39; necessar anteporr &#34; ( float ) &#34; (senz virgolett ) all&#39; identif variabil tip int desider invoc , specific cos intend tratt com float . inoltr i valor numer inter dev termin .0 (es . 3.0 , 7.0 ) . es : int = 6 ; float f; f= (float ) / 3.0 ; quest oper è dett typecasting . </answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L32" title="Conversioni Basi, Rappresentazioni Informazioni, Tipi di Dati" date="2013-10-18"><question id="QQ2884"><question_text>dop aver spieg different rappresent numer inter &#34; modul segn &#34; quell &#34; complement &#34; , descriv procedur utilizz rappresent i numer inter ca2 illustr i vantagg e/o svantagg un&#39; altra rappresent . </question_text><answer id="A2861"><answer_text>rappresent complement si vantagg : 1 zer non vien ripet 2 non è richiest circuiter specif tratt segn . codif ca2 i numer posit è normal codif cio msb è 0 (numer posit ) indic valor numer inter , i numer negat codif numer com foss posit , poi invert zer infin somm 1 . es 6=0110 invert zer 1001 infin somm 1 otteng 1010=-6 </answer_text><num_votes>0</num_votes></answer><answer id="A2821"><answer_text>rappresent &#34; modul segn &#34; usa bit com bit segn , n bit veng usat n-1 bit modul . quell &#34; complement &#34; non richied esamin segn . avend n bit , ca2 si codific i valor -2^ (n-1 ) 2^ (n-1 ) -1 . bit più signif rappresent segn , è 0,si proced normal decodif , è 1 si decodif poi si sottra 2^ (n-1 ) . invert numer binar , si invert singol cifr poi si aggiung 1 . ca2 è men intuit , non dopp codif 0 , addizion usat sottrazion . </answer_text><num_votes>1</num_votes></answer><answer id="A2845"><answer_text>different maggior rappresent l&#39; elimin ridond zer (cio zer rappresent ) present rappresent modul segn , quell complement . ca2 si assoc bit signif (msb ) segn numer . msb=0 si decodif normal , msb=1 si proced decodif poi si sottra 2^n-1 . </answer_text><num_votes>0</num_votes></answer><answer id="A2785"><answer_text>rappresent &#34; modul segn &#34; usa bit decodif segn , schem : 1=- 0=+ quell &#34; complement &#34; preved esegu procedur (divers ca2 ca1 ) determin numer rappresent . ca2 si oper seguent mod : -se msb=0-&#62;normal decodif -se msb=1-&#62;dop decodif si sottra 2^ (n-1 ) ca2 svantagg esser men intuit &#34; modul segn &#34; . i vantagg : -elimin dell&#39; ambigu zer -possibil utilizz component elettron full-adder addizion sottrazion numer </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2810"><question_text>si sta parl , quand si parl &#34; conversion implic &#34; c ? </question_text><answer id="A2829"><answer_text>conversion implic c ( ingles coercion ) è tip conversion tip dat vien svolt manier automat compil , cio quand oper operand tip divers , quest veng convert tip comun segu regol specif . compil tent conversion sequenz defin finc non riesc , alcun cas quest conversion si può verific perd d&#39; inform si può perd precision . </answer_text><num_votes>0</num_votes></answer><answer id="A2808"><answer_text>quand si fann oper variabil tip divers , linguagg c convert tip comun . conversion è implic perc non c&#39; è bisogn specific richiest conversion , può port incomprension risult inaspett all&#39; intern programm , esemp può verific overflow int convert float tronc cas float convert int. ovvi quest problem si può ricorr all&#39; oper casting (conversion esplic ) , ossi inser parentes tond tip si vuol risult dell&#39; oper . </answer_text><num_votes>4</num_votes></answer><answer id="A2814"><answer_text>c esist tip conversion : implic esplic . conversion tip implic c vien attu mod automat compil . conversion implic riconduc i var tip dat present un&#39; espression , unic tip , mod essi sian confront . esemp andrò assegn variabil tip &#39;&#39; int&#39; &#39; conten variabil tip &#39;&#39; float&#39; &#39; : int i =0 ; float f=2.8; i=f ; compil convert valor conten variabil float (2 .8 ) , valor inter (2 ) , conseguent perd inform . </answer_text><num_votes>0</num_votes></answer><answer id="A2837"><answer_text>conversion implic si intend conversion tip più variabil realizz mod automat c consent valut un&#39; espression . si tratt un&#39; oper rischios , quant potrebb comport perd inform variabil (ad esemp passagg variabil tip float int , conseguent perd part decimal ) . essa si contrappon conversion esplic , realizz &#34; hoc &#34; programm , permett gest variabil i tip mod desider più util programm si sta realizz . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2790"><question_text>com funzion conversion binar decimal vicevers ? </question_text><answer id="A2916"><answer_text>pass decimal binar bisogn divid numer decimal 2 non si arriv 0 , riport sempr rest division . numer binar , dunqu , si trov prend i numer rest bass vers l&#39; alto , ovver dall&#39; rest division . vicevers bisogn prend numer binar moltiplic ogni membr potenz 2 corrispondent . esemp numer moltiplic 2^0 , 2^1 , 2^2 , cos via . si somm tutt i risult si ottien numer decimal . </answer_text><num_votes>1</num_votes></answer><answer id="A2820"><answer_text>convert numer binar decimal si moltipl ciascun cifr numer binar potenz 2 esponent aument 1 proced destr sinistr , quant esso e&#39; relazion posizion cifr numer ; infin si somm i risult otten . es . 0011=(0x8 + 0x4 + 1x2 + 1x1 ) = (2+1 ) =3 . convert numer decimal binar si oper success division 2 numer decimal ; risult e&#39; sequenz 0 1 otten consider nell&#39; ordin , cifr men signif quell piu&#39; signif i rest division . es.14=1101 . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2799"><question_text>qual è different rappresent numer binar virgol fiss virgol mobil ? qual è più vantagg ? </question_text><answer id="A2847"><answer_text>rappresent virgol fiss non fa codific part inter ten cont segn part decimal separ virgol ; rappresent virgol mobil port tutt virgol codif part decimal , moltiplic poi esponent anch&#39; esso codific . vien utilizz maggior codif virgol mobil perc &#39; utilizz spaz fiss riserv segn , esponent mantiss ( 1 segn , 8 l&#39; esponent 23 mantiss ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2881"><answer_text>rappresent virgol fiss , non si fa convert binar part inter decimal , poi si unisc i , virgol mobil si usa notazion scientif , ovver si fa conversion numer mantiss esponent . più vantagg è virgol mobil perc utilizz memor . </answer_text><num_votes>0</num_votes></answer><answer id="A2838"><answer_text>numer virgol mobil permett rappresent ampi insiem numer all&#39; intern determin numer cifr (appunt è vantagg ) , graz rappresent scientif normalizz l&#39; utilizz sistem binar (dunqu fattor scal è potenz 2 ) , virgol fiss non conced . </answer_text><num_votes>1</num_votes></answer><answer id="A2792"><answer_text>virgol fiss veng diversific i bit indic part inter quell indic part decimale.s stabil dunqu virgol posizion fiss . virgol mobil part bit veng riserv rappresent cifr signif numer indipendent posizion virgol alcun veng riserv stabil dov posizion virgol . virgol mobil utilizz standard ieee-754 graz qual è possibil rappresent valor null infin nan , rend rappresent più esaust più complic </answer_text><num_votes>0</num_votes></answer><answer id="A2880"><answer_text>rappresent virgol fiss veng divis prior i bit design rappresent part inter quell part frazionar . rappresent virgol mobil , , bit riserv cifr signif numer (mantiss ) veng deput l&#39; indic dov porr virgol . modal più vantagg è second , moment tal mod può esser ponder spaz part inter part frazionar second esigent , non avend determin prior . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2883"><question_text>com poss pass array rifer funzion ? qual è l&#39; intest corrett ? </question_text><answer id="A2887"><answer_text>quand array vien pass funzion com parametr formal , l&#39; indirizz bas dell&#39; array vien pass &#34; valor &#34; funzion . fatt si realizz passagg parametr &#34; indirizz &#34; effett final apparent è l&#39; array pass &#34; rifer &#34; . parametr formal dichiar test funzion vien tratt com puntator . suppon tipoarray defin com : typedef doubl tipoarray[maxnumelem ] un&#39; intest corrett è esemp : doubl sum (doubl *a , int n ) dov n è dimension dell&#39; array pass . </answer_text><num_votes>5</num_votes></answer><answer id="A2817"><answer_text>pass array rifer funzion , ovver mod ogni modif funzion parametr veng visualizz fuor funzion , bast preced parametr simbol &#38; . quand si pass array realt si pass l&#39; indirizz element dell&#39; array . parametr formal vien tratt com puntator element . element dell&#39; array non veng cop parametr formal . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2814"><question_text>integral floating i grand insiem qual veng suddivis i tip dat linguagg c . qual caratterist quest insiem ? qual tip dat fann part insiem qual tip conten ? </question_text><answer id="A2826"><answer_text>i tip predefin c veng raggrupp insiem , identific caratterist comun : -integral , raggrupp i tip rappresent memor com inter , rappresent numer discret valor compres nell&#39; insiem numer natural (fann dunqu part grupp i tip predefin int char , i qualif tip : unsigned-signed , short-long ) ; -floating , raggrupp i tip rappresent memor numer real , preved numer grand valor numer , fann part : float (long ) doubl . </answer_text><num_votes>4</num_votes></answer><answer id="A2902"><answer_text>caratterist integral : rappresent numer discret valori,v è corrispondent biunivoc qualsias tip integral sottoinsiem numer natural caratterist floating : concettualmente,il domin r è insiem dens : dat element x1 x2 domin distanz epsilon piccol piac ,esist sempr ?infin valor r conten ?intervall [x1 ,x2 ] . tip integral : char signed char unsigned char signed short int signed int signed long int unsigned short int unsigned int unsigned long int floating : float doubl long doubl </answer_text><num_votes>0</num_votes></answer><answer id="A2822"><answer_text>integral utilizz rappresent i numer inter solit occup spaz 2 4 byte memor . i floating numer virgol mobil utilizz rappresent i numer razional solit occup 4 8 byte . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2794"><question_text>codif asci non compr lett accent . è necessar utilizz codif different asci , possibil ? qual&#39; è codif necessar visualizz utilizz lett accent ? </question_text><answer id="A2886"><answer_text>codif necessar scriv lett accent è l&#39; asci 8 bit , extended ascii.quest codif è orma standard pc . </answer_text><num_votes>1</num_votes></answer><answer id="A2889"><answer_text>lett accent com &#39;è &#39; , codif asci codic superior 127 , fann part tabell asci estes , contrar quell standard (caratter 0 127 compres ) , spess var .un semplic risolu problem è sostitu lett accent vocal &#34; apostrof &#34; com &#34; e&#39; &#34; post &#34; è &#34; . </answer_text><num_votes>2</num_votes></answer><answer id="A2872"><answer_text>avend disposizion 128 caratter veng esclus moltissim simbol lett accent . infatt fà , pagin web , inser caratter non compres codif asci era necessar usar cos dett entit html , cio caratter preced da&#39;&#38; &#39; . era scomod moment si dov scriv qualcos lingu divers dall&#39; ingles . infatt part quest entit divenner inutil l&#39; estension codif asci . venn defin l&#39; asci estes usa 256 numer (8bit caratt , usand l&#39; ottav bit dell&#39; asci lasc inutilizz ; c </answer_text><num_votes>1</num_votes></answer><answer id="A2922"><answer_text>è possibil modific codif caratter , farl non istruzion univoc dipend browser vien utilizz codif asci è più diffus è consigl risolv problem lett accent utilizz apic , tuttav si voless camb total codif miglior sostit potrebb esser utf-8 . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2914"><question_text>si intend tip dat astratt perc si differenz ? </question_text><answer id="A2777"><answer_text>i tip dat astratt var tip general determin , com interpret insiem bit memor , quant memor riserv variabil funzion tip permett trov &#34; error tip &#34; fas compil . esist 4 tip tip : -semplic (int , float , char ) ; -struttur (array , matric ) ; -predefin linguagg programm usat ; -defin programm attravers azion typedef strcut (per linguagg c ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2782"><answer_text>tip dat astratt (adt ) è particol inform , rappresent calcol , è not mod interpret manipol . ciò si evinc valor rappresent calcol può esser interpret manier different second tip dat vien assoc . es . caratt asci , integer floating , livell memor rapprent mediant sequenz bit ugual , rappresent inform complet different . non è sufficient chiar rispond , si intend tip ! </answer_text><num_votes>2</num_votes></answer><answer id="A2770"><answer_text>linguagg programm alto livell tratt tip dat astratt cio insiem valor oper mediant codif non corrispond dat tratt concret macchin . programm è fondamental l&#39; utilizz tip dat astratt perc è possibil tratt l&#39; inform prescind mod concret qual essa è rappresent all&#39; intern macchin . </answer_text><num_votes>0</num_votes></answer><answer id="A2831"><answer_text>tip dat astratt (adt ) è tip dat segu modell matemat includ oper defin esso . si differenz tip dat perc un&#39; alloc dinam memor , un&#39; efficient maggior memorizz (veng riserv spaz memor dat effett utilizz ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2766"><answer_text>principal different sta fatt tip dat astratt è riconosc dall&#39; utent non compil ; infatt quand si &#34; costru &#34; bisogn assoc (con typedef ) tip dat riconosc compil . es : typedef int inter ; dic compil inter (riconosc dall&#39; utent ) è &#34; sinonim &#34; int(riconosc compil ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2819"><question_text>signif complement n (n numer natural ) cert numer com si fa ? </question_text><answer id="A2772"><answer_text>complement 1 2 (non esist ) veng utilizz rappresent codic binar i numer negat . complement 1 si ottien somm numer posit binar mascher sol &#34; 1 &#34; , otten cos corrispondent numer negat . metod cre per problem zer : infatt verrebb identific mod div . complement 2 si somm ulterior &#34; 1 &#34; numer binar otten complement 1 , elimin cos problem . (si parl somm binar ) esemp : 0(dec ) =0000 0(dec ) =1111 (compl.1 ) 0(dec ) =0000 (compl.2 ) </answer_text><num_votes>1</num_votes></answer><answer id="A2824"><answer_text>informat si utilizz fondamental complement 1 2 com metod rappresent dat inter relat complement si esegu invert tutt i bit parol : 00001001=9 ; 11110110=-9 metod è imperfett quant preved rappresent numer 0 complement 2 si esegu pratic complement aggiung 1 oper complet 00001001=9 ; 11110111=-9 metod è più usat quant semplif notevol oper somm different usand bit com indic segn </answer_text><num_votes>1</num_votes></answer><answer id="A2910"><answer_text>complement è utilizz rappresent i numer segn solit vien utilizz numer binari.il complement n numer si fa invert tutt i bit numer (in parol sostitu 0 uni vicevers ) somm n-1.in particol complement 1 invert i bit somm nient , complement 2 invert i bit somm complement 3 invert i bit somm 2 ecc.solit i più utilizz complement 1 2 . (5 compl 2 ) 5-&#62;0000 0101-&#62;compl 1-&#62;1111 1010-&#62;compl 2-&#62;1111 1011 (-5 compl 2 ) </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2899"><question_text>qual different codif virgol mobil codif virgol fiss ? </question_text><answer id="A2899"><answer_text>codif virgol fiss rappresent numer (ad esemp ) 8 bit 4 bit riserv part inter 4 bit part frazionar . codif virgol mobil rappresent numer (ad esemp ) 32 bit notazion +-m*2^e . bit più signif indic segn (+ - ) , i success 8 codific l&#39; esponent &#34; &#34; complement i restant 23 rappresent mantiss (m ) . sostanz mantiss rappresent tutt cifr numer mentr l&#39; esponent indic posizion virgol . </answer_text><num_votes>3</num_votes></answer><answer id="A2804"><answer_text>numer virgol mobil è possibil rappresent ampi insiem valor , maggior virgol fiss parit memor . tuttav i numer virgol fiss utilizz dov serv maggior precision ; perc virgol mobil si riscontr problem arrotond , assorb valor (esemp 10^15 + 1 = 10^15 ) impossibil rappresent . esemp valor 0.1 è imposs i numer virgol mobil manier esatt non arrotond . alcun settor qual finanziar si dev evit più possibil quest error . </answer_text><num_votes>1</num_votes></answer><answer id="A2800"><answer_text>codif virgol fiss i bit dispon veng divis rappresent part inter quell frazionar , ovver virgol posizion fiss . vicevers codif virgol mobil larg part bit vien usat rappresent cifr signif , mentr i rimanent veng usat stabil posizion virgol . pag.6 cap 4.5 </answer_text><num_votes>0</num_votes></answer><answer id="A2923"><answer_text>codif virgol fiss , i bit veng divis manier costant part inter part frazionar mentr codif part mobil i bit veng frazion quell rappresent cifr signif quell volt stabil posizion avrà virgol . </answer_text><num_votes>0</num_votes></answer><answer id="A2780"><answer_text>codif virgol fiss numer vien divis part , part inter part decimal , abbiam 8 bit disposizion , i prim 4 rappresent part inter mentr part decimal . es . (0101.0011 ) bin-&#62; ( 5 .1875 ) dec conversion virgol mobil (floating point ) numer occup 32 bit , suddivis manier specif . bit sinistr (msb ) rappresent segn , atri 8 l&#39; esponent 23 mantiss . codific numer decimal otten numer è dat formul : x=±m*2^e m&#60;1 . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2816"><question_text>perc inter posit calcol non poss numer grand (tendent infin ) ? qual è valor massim ? com vien espress ? </question_text><answer id="A2863"><answer_text>inter gestibil calcol non poss assum numer grand (tendent infin ) perc memor risors disposizion calcol fin . quest cos limit i valor i calcol poss manegg . c/c++ inter posit (dett unsigned int ) può assum com valor massim 4.294.967.295 . valor è otten fac ( ( 2^32 ) -1 ) : 2^32 perc codif è 32 bit mentr si fa men perc tolt 0 (quest perc vogl otten valor massim non numer combin possibil ) . </answer_text><num_votes>4</num_votes></answer><answer id="A2834"><answer_text>i calcol non poss numer grand tendent infi , perc grandezz predefin (massim ) . valor massim inter calcol è : segn &#38;#8722 ;2.147.483.648 +2.147.483.647 segn : 0 +4.294.967.295 quest inform si poss trov librer stdlib.h </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2800"><question_text>com si convert numer bas ottal numer bas esadecimal ? fai esemp . </question_text><answer id="A2852"><answer_text>convert num base8 b16 si può proced utilizz b2 cm pern passagg cifr sistem ottal (0 ..7 ) espress sistem binar max sar compost 3 cifr (0 ..111 ) ogni cifr b8 andrò riserv 3 post b2 3 b6 -&#62;011 b2 es 3 4 1 b8 011 100 001 b2 341 b8 -&#62;011100001 b2 num b16 sar dat raggrupp 4 a4 part dx cifr num binar esprim valor (tra 0-15 ) corrispondent simbol bas esadec : 1110 b2 -&#62;14 b10 -&#62; b16 1110 0001 b2 1 b16 341 b8 = e1 b16 </answer_text><num_votes>1</num_votes></answer><answer id="A2759"><answer_text>numer ott vien convert numer esa attravers passagg : conversion numer bas ott numer bas dec conversion numer dec otten numer bas esa . esemp numer 2370 bas ott divent 1272 bas dec , divent 4f8 bas esa . passagg ott dec si ottien moltiplic , dall&#39; ultim prim cifr , cifr question 8^n , n posizion cifr part cifr più destr ;il passagg dec esa si ottien divid numer dec 16 legg i rest dall&#39; otten numer esa . </answer_text><num_votes>0</num_votes></answer><answer id="A2912"><answer_text>mod può esser trasform numer bas 8 bas 2 poi riconvert bas 16 . esemp : 64752 -&#62; 110 100 111 101 010 raggrupp i bit otten 4 4 , part destr (aggiung zer sinistr ) otteng : 0110 1001 1110 1010 -&#62; 6 9 </answer_text><num_votes>0</num_votes></answer><answer id="A2898"><answer_text>convert numer bas ottal bas esadecimal possibil soluzion (si potrebb utilizz trasform dirett utilizz per bas non decimal difficil applic ) : 1 . trasform bas ottal bas decimal success bas esadecimal es : 203( 8 ) -&#62; (2*8^2+0*8^1+3*8^0 ) =131 (10 ) -&#62; 83(16 ) 2 . trasform bas ottal bas binar success bas esadecimal . quest è inoltr procedur più usat calcol . es : 208( 8 ) -&#62;10000011 (2 ) -&#62; 83(16 ) </answer_text><num_votes>4</num_votes></answer></question><question id="QQ2806"><question_text>qual&#39; è l&#39; algoritm conversion numer binar decimal ? </question_text><answer id="A2853"><answer_text>l&#39; algoritm conversion numer binar decimal è descritt sequenz d&#39; istruzion logic costitu quest 6 passagg : 1 ) porr zer variabil cont n=0 n=0 . 2 ) posizion destr numer . 3 ) legg caratt seguent sinistr . 4 ) caratt è vuot , ferm ( cifr fin ) . 5 ) somm n valor 2n moltiplic cifr posizion n increment n 1 . 6 ) torn pass 3 ripet istruzion success . </answer_text><num_votes>0</num_votes></answer><answer id="A2758"><answer_text>convert numer binar numer decimal bast segu algoritm : numer binar puo&#39; esser vist com array , dov ogni cifr (1 0 ) corrispond cell array . e&#39; necessar moltiplic ogni cifr numer binar (quind ogni cell dell&#39; array ) , 2^n , dov n e&#39; posizion cifr nell&#39; array (ricord prim cell dell&#39; array corrispond n=0 ) . volt fatt ciò non rest somm i risult tal moltipl , somm dar numer binar convert bas decimal . </answer_text><num_votes>2</num_votes></answer><answer id="A2839"><answer_text>dat numer binar restitu rappresent bas decimal tal numer . trov l&#39; algoritm risolut problem è necessar proced ser moltipl (2 ) elev valor dip posizion bit ?array , somm i div contrib leg bit ?array binar , poi stamp risult tal somm . riport segu esemp risolu : int n=8 ; int bin [8 ] ={1 ,0,0,0,0,0,1,1 } ; int i , dec=0 ; for (i=0;i&#60;n ;i++ ) { dec = dec + numbin [n-1-i ] * exp(log(2 ) * i ) ) ; } </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2826"><question_text>cos&#39; è l&#39; overflow ? quand si manifest ? </question_text><answer id="A2866"><answer_text>e&#39; error dov memorizz dat spaz insufficient conten . ciò caus memorizz sbagl dat . esemp si usa codif 6 bit , dov bit più signif indic segn , si fa somm 011010 011111 , risult 111001 dov 1 vien lett com segn anzic com 1*2^5 , risult è numer divers modul segn . </answer_text><num_votes>1</num_votes></answer><answer id="A2823"><answer_text>traduzion esatt è &#34; trabocc &#34; si manifest quand , effettu oper aritmet , risult è tropp grand esser memorizz super spaz programm mess disposizion risult . </answer_text><num_votes>2</num_votes></answer><answer id="A2810"><answer_text>l&#39; overflow si verif quand risult un&#39; oper super numer massim rappresent calcol . esemp dat 8 bit val 255 (11111111 ) , fac a+1 risult non potr esser 256 (100000000 ) perc serv 9 bit rappresent . quel cas solit calcol tien ultim 8 bit 255+1 = 0 </answer_text><num_votes>1</num_votes></answer><answer id="A2776"><answer_text>l&#39; overflow si manifest quand cerc occup più spaz dispon nell&#39; alloc memor stiam scriv i dat . si manifest gestion array poic , quant vist fin&#39; , grandezz array è static volt dichiar ; ciò presuppon programm conosc esatt qual sar funzion quell&#39; array . cas contrar , potr trov front array tropp piccol andand cos incontr all&#39; error overflow </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2873"><question_text>spieg cos&#39; è codif virgol mobil com funzion . </question_text><answer id="A2869"><answer_text>codif &#34; virgol mobil &#34; tecnic rappresent i numer part frazionar . codif virgol mobil si divid i bit utilizz part : maggior bit riserv rappresent cifr signif numer alcun bit serv stabil dov posizion virgol . standard present numer frazionar virgol mobil 32 bit è seguent : -il bit codif segn -i sucess 8 codific l&#39; esponent ca2 -gli ultim 23 codific mantiss m (senz segn ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2924"><answer_text>rappresent virgol mobil utilizz notazion esponenzial codif numer real . esemp standard ieee 754-1985 rappresent 32 bit , ciascun numer real vien rappresent bit segn , 8 bit caratterist 23 bit mantiss . caratterist è numer usat com esponent mentr mantiss è numer compres 0 1 . quest codif è possibil rappresent caratter special com risult oper non ammess com division zer , i valor più infin men infin . </answer_text><num_votes>3</num_votes></answer><answer id="A2791"><answer_text>codif virgol mobil è mod rappresent i numer frazionar caratterist è quell riserv part bit rappresent cifr signif (m ) altra part stabil posizion virgol . standard codific numer virgol mobil 32 bit è seguent : bit segn , i success 8 l&#39; esponent &#34; &#34; ca2 , serv spost virgol , i success 23 bit mantiss &#34; m &#34; segn valor inferior 1 . numer verr codific com +-m*2^e . </answer_text><num_votes>1</num_votes></answer><answer id="A2896"><answer_text>codif virgol mobil è mod rappresent mod opportun i numer frazionar (con virgol appunt ) . pratic , bit necessar rappresent tal numer , grand part vien dedic cifr signif (mantiss ) , bit post all&#39; iniz determin numer è posit negat (segn ) , piccol ser bit stabil posizion virgol numer (esponent ) . 2 metod risolu : - l&#39; esponent determin spost virgol - l&#39; esponent esser elev numer 2 tutt moltiplic mantiss . </answer_text><num_votes>0</num_votes></answer><answer id="A2874"><answer_text>codif virgol mobil è util rappresent cifr grand piccol evit sprec inutil cell memor . punt vist sintatt rappresent virgol mobil consist part : mantiss l&#39; esponent bas 10 , separ caratt &#34; &#34; . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2812"><question_text>qual ragion codif virgol mobil è prefer codif virgol fiss ? </question_text><answer id="A2797"><answer_text>e&#39; sicur più vantagg rappresent virgol mobil qual permett esprim numer grand poch cifr precision numer piccol . rappresent virgol mobil si utilizz notazion esponenzial 32 bit dov 1 bit indic segn , 8 bit l&#39; esponent , dett caratterist , indic posizion virgol infin 23 bit mantiss rappresent cifr più rappresent numer . </answer_text><num_votes>1</num_votes></answer><answer id="A2883"><answer_text>codif virgol mobil vien solit prefer quell virgol fiss quant quest&#39; ultim lim numer cifr inter decimal . consegu precision decimal davver ridott (anc quand numer inter è piccol ) . codif virgol mobil , , numer part inter piccol molt cifr decimal , quest ultim poss occup i bit codif virgol fiss sarebber occup part inter (che sarebb preced zer , esser utilizz &#34; convenient &#34; ) . </answer_text><num_votes>3</num_votes></answer><answer id="A2815"><answer_text>mod rappresent valor tip real è normal rappresent decimal , dett virgol fiss . quest rappresent divent dispend , termin capac memor rappresent grafic valor grand piccol . è prefer codif virgol mobil poic permett rappresent poch cifr numer grand oppur rappresent precision numer piccol , attravers mantiss esponent . </answer_text><num_votes>0</num_votes></answer><answer id="A2774"><answer_text>perc codif virgol mobil è possibil codific rang più elev valor (molt piccol e/o grand ) andand lavor non numer limit bit part inter part decimal (virgol fiss ) , lavor segn , mantiss (oss cifr signif numer ) esponent , dic qual posizion spost virgol . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2831"><question_text>descriv l&#39; util funzion codif complement 2 (ca2 ) . </question_text><answer id="A2907"><answer_text>complement è sistem conversion utilizz abit elettron , infatt vantagg elimin rison zer ( elimin zer multipl divers rappresent numer binar ) . , codif complement è infin larg utilizz elettron poic circu sommator utilizz quest conversion oper mod più rapid ( esemp l&#39; alu ) </answer_text><num_votes>0</num_votes></answer><answer id="A2846"><answer_text>è metod più diffus rappresent numer segn informat . enorm diffusion è dat fatt i circu addizion sottrazion non dev esamin segn numer rappresent sistem determin qual oper necessar , permett tecnolog più semplic maggior precision . bit inizial numer pes negat (1 ) posit (0 ) . prend complement aggiung 1 numer binar risult si può cos otten valor assol numer binar negat . </answer_text><num_votes>1</num_votes></answer><answer id="A2914"><answer_text>complement 2 è complement più utilizz più semplic rappresent numer binar posit negat . è possibil poic l&#39; inform segn è inclus bit numer mot bast l&#39; oper &#34; addizion &#34; effettu oper addizion quell sottrazion . otten numer rappresent ca2 , bast legg numer destr vers sinistr invert tutt cifr part bit ugual 1 (esclus ) . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2955"><question_text>qual oper si poss applic variabil costru mediant struct (non singol camp ) ? </question_text><answer id="A2904"><answer_text>oper applic variabil tip struct : 1 . access singol camp variabil mediant dot notation ; 2 . definizion puntator all&#39; inter variabil struct ; 3 . definizion puntator camp variabil struct . </answer_text><num_votes>1</num_votes></answer><answer id="A2917"><answer_text>variabil costru mediant struct poss conten inform eterogene (di tip divers : numer , string ... ) conseguent è possibil oper esser var mod ten cont l&#39; appunt different tip inform . mod veng defin quest variabil non può esser modific all&#39; intern main , quest variabil rimang stess all&#39; intern tutt programm . i camp all&#39; intern struct poss esser richiam mediant &#34; . &#34; ( es : agend .event ) quest poss esser svolt oper inizializz , stamp cos via ... </answer_text><num_votes>1</num_votes></answer><answer id="A2825"><answer_text>domand non sens . </answer_text><num_votes>0</num_votes></answer><answer id="A2813"><answer_text>oper si poss applic struttur cop , l&#39; assegn com unic oggett , manipol tram l&#39; access camp , l&#39; inizializz tram list valor costant , l&#39; indirizz tram l&#39; oper &#38; , passagg struttur funzion ritorn esse . non poss , funzion , esser confront . </answer_text><num_votes>1</num_votes></answer><answer id="A2818"><answer_text>struct e&#39; tip dat defin programm , e&#39; dett user-defined type assolv funzion raggrupp inform eterogene . oper poss esser comp variabil tip &#34; struct &#34; : l&#39; assegn variabil un&#39; altra mediant cop conten (se tip ) ; l&#39; access var camp attravers dot notation ; l&#39; indic dell&#39; indirizz variabil attravers &#34; &#38; &#34; ; l&#39; impossibil &#39; effettu confront variabil tip struttur definizion variabil com puntator . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2813"><question_text>immagin bisogn convert numer bas 22 . scriv conversion numer 1589 (scritt bas 10 ) , com convert . </question_text><answer id="A2819"><answer_text>convert qualsias numer bas decimal altra bas bisogn divid numer dat bas dobb convert scriv i rest . volt otten i rest si scriv numer bas desider part dall&#39; rest otten . prend esam conversion 1589 bas 22 si divid numer 22 si otteng i rest (5 ,6,3 ) . invert posizion rest , prim cifr corrispond all&#39; rest , si ottien numer bas 22 : (365 ) i n bas 22 . </answer_text><num_votes>1</num_votes></answer><answer id="A2799"><answer_text>1589/22=72 rest 5 72/22=3 rest 6 3/22= 0 rest 3 1589 bas 10 quival 365 bas 22 </answer_text><num_votes>0</num_votes></answer><answer id="A2841"><answer_text>si divid 22 1589 : 1589 : 22= 72 rest 5 72 : 22= 3 rest 6 3 : 22= 0 rest 0 si consider i rest bass vers l&#39; alto 1589 , convert bas 22 è 065 </answer_text><num_votes>0</num_votes></answer><answer id="A2768"><answer_text>risult conversion è 365 bas 22 . convert numer inter decimal un&#39; altra bas bisogn divid tal numer bas conserv rest divid bas risult null . i rest otten part dall&#39; propr cifr rappresent nuov bas numer decimal partenz . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2928"><question_text>com mai rappresent numer inter si adott rappresent complement non si utilizz scrittur semplic si utilizz bit segn i success numer ? </question_text><answer id="A2903"><answer_text>rappresent complement sostitu quell rappresent segn esplic perc , pur essend men intuit vantagg : non è dopp codif valor zer (infatt avrebb signific divers second si trov prim posizion ) non è richiest circuiter specif tratt segn infatt codif complement l ?oper sottrazion vien fatt esegu ?addizion . </answer_text><num_votes>1</num_votes></answer><answer id="A2925"><answer_text>non dopp codif valor &#34; zer &#34; non richied circuiter specif tratt segn </answer_text><num_votes>1</num_votes></answer><answer id="A2867"><answer_text>rappresent complement è metod più diffus rappresent numer segn informat . aspett più import è dat fatt i circu addizion sottrazion non dev esamin segn numer rappresent determin qual oper necessar si utilizz circu , sommator , l&#39; addizion sottrazion . inoltr consent un&#39; unic rappresent zer (quand tutt i bit zer ) oper addizion sottrazion sempr avend bit indic segn . </answer_text><num_votes>2</num_votes></answer><answer id="A2789"><answer_text>si utilizz complement perc elimin problem dopp rappresent 0 necess circuiter specif gestion segn semplif calcoli.il più utilizz è complement 2 , dov rappresent numer si invert i valor ogni bit &#34; risult &#34; si aggiung 1 , elimin poi eventual rest .esist complement 1 , simil precedent , semplic si invert tutt i bit l&#39; aggiunt .in metod per trov problem dopp rappresent 0 . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2830"><question_text>quand si progett programm funzion divers macchin , perc occorr verific quant byte veng dedic variabil tip inter ? </question_text><answer id="A2842"><answer_text>occorr sap mod vien codific variabil tip int perc , second dell&#39; architettur sistem oper destin , valor massim assegn variabil potrebb camb potrebb esser necessar effettu modif adatt . </answer_text><num_votes>0</num_votes></answer><answer id="A2794"><answer_text>è necessar verific quant byte veng dedic variabil tip inter cognizion &#39;range&#39; valor dispon poic oper sitem 64 32 bit avveng manier divers . </answer_text><num_votes>0</num_votes></answer><answer id="A2888"><answer_text>siccom second dell&#39; architettur macchin (hardw ) è possibil divers numer bits , giorn d&#39; oggi si utilizz pc architettur 64 bits signif i numer poss &#34; fisic &#34; rappresent compres 0 2*10^64-1 (senz segn ! ! ) , mentr macchin 32 bits i valor var 0 2*10^32-1 (senz segn ) . entramb architettur (64 32 bits ) è possibil stess cos (a discap veloc ) , esemp tram soluzion softw poss rappresent numer più grand 2*10^32-1 architettur 32 bits . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2855"><question_text>serv costrutt &#34; typedef &#34; dov si colloc programm ? </question_text><answer id="A2757"><answer_text>funzion typedef serv defin tip dat esemp : typedef char caratt ; assoc tip char caratt poi potr scriv sempr : caratt letter ; caratt lettera2 ; sar equivalent scriv : char letter ; char lettera2 ; typedef &#34; char &#34; vien sostitu complet parol &#34; caratt &#34; , serv si usa programm compless men confusion . si scriv prim rig main quand si defin variabil usar programm . </answer_text><num_votes>1</num_votes></answer><answer id="A2756"><answer_text>costrutt typedef e&#39; utilizz dar &#34; &#34; tip dat c . cas particolar costrutt risult util : - programm tip dipendent macchin - programm occorr utilizz molt struct parametr puntator programm vien colloc dichiar costant dichiar variabil . </answer_text><num_votes>1</num_votes></answer><answer id="A2828"><answer_text>costrutt &#34; typedef &#34; vien utilizz ogni qual volt si vuol defin tip utilizz per tip già esistent programm . esso risult util sopratutt quand programm utilizz divers &#34; struct &#34; puntator . &#34; typedef &#34; vien colloc all&#39; iniz programm , prim main ( ) . struttur : typedef tipoesistent nuovotip ; </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2921"><question_text>accad esegu un&#39; oper oper tip int tip float ? </question_text><answer id="A2900"><answer_text>si oper tip dat int , i 2 byte memor rappresent inter , dat float 4 byte , rappresent numer razional , men propr numer real , linguagg c non avvert alcun error , esegu assegn , cio conversion automat tip . l&#39; assegn convert tip dx dell&#39; ugual tip sx ( [int ] = c[float ] c-&#62;a ) . ciò può caus tronc , perd inform , trasform indesider . conversion implic trasform tip inferior superior , regol int&#60;float . </answer_text><num_votes>1</num_votes></answer><answer id="A2761"><answer_text>veng esegu oper element tip eterogene (com int float ) , variabil tip inferior esser convert temporan tip superior seguent gerarc : int&#60;long&#60;unsigned&#60;unsigned long&#60;float&#60;double&#60;long doubl cas oper int float variabil int vien convert temporan float . risult dell&#39; oper sar tip superior , cas float . </answer_text><num_votes>1</num_votes></answer><answer id="A2840"><answer_text>dip tip è variabil tien risult dell&#39; oper . cas sommator variabil float variabil int: variabil risult tip int , avrò risult inter ; altriment variabil tip float avrò com risult numer virgol . </answer_text><num_votes>0</num_votes></answer><answer id="A2873"><answer_text>oper è float : tip int verrebb trasform float l&#39; oper risult float . general valut operand rifer oper veng convert tip comun segu quest regol ordin : 1 operand e&#39; long doubl l&#39; vien convert long doubl 1 e&#39; doubl l&#39; vien convert doubl 1 e&#39; float l&#39; vien convert float altriment entramb vien esegu trasform inter sequenz cas non interess non riusc scriv limitaz caratter </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2803"><question_text>com è possibil defin tip dat ? descrivin procedur </question_text><answer id="A2868"><answer_text>defin tip dat può esser util cas avessim molt variabil defin tip : cos com int inizializz variabil inter , si poss inizializz variabil conteng intern struct . esemp , vogl defin tip dat struct contenent variabil tip inter dovr scriv prim main : typedef struct { int pes ; int altezz ; int eta } identikit; poi main dovrem inizializz : indentikit a; mod , variabil sar tip dat identikit sar gest com struct 3 variabil . </answer_text><num_votes>0</num_votes></answer><answer id="A2901"><answer_text>c poss ridefin tip già esistent defin tip (user-defined types ) attravers com typedef . si vuol ridefin tip già esistent si digit l&#39; istruzion typedef segu tip dat si vuol assegn . si vuol defin tip dop typedef segu tip dat compless (struct , bit-field , union , enumeration ) , tip (facolt ) parentes graff . cas struct all&#39; intern parentes si poss trov variabil tip divers , cas enumeration sequenz numer . </answer_text><num_votes>1</num_votes></answer><answer id="A2862"><answer_text>funzion permett gener tip dat avval quell standard com (int , char , float ) è chiam &#34; typedef &#34; . quest funzion consent programm defin piac i nom propr dat com esemp i tip dat built-in quell struttural . semplic esemp tip dat potrebb esser : typedef int numer ; numer var; </answer_text><num_votes>0</num_votes></answer><answer id="A2908"><answer_text>defin tip dat è necessar cre struttur scriv typedef struct{ //qui mett variabil struttur esemp int a; char c; } nomestruttur ; infin usar struttur è necessar assoc &#34; nomestruttur &#34; variabil . l&#39; passagg : nomestruttur b; </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2833"><question_text>indic descriv brevement i principal tip predefin dat c/c++ . infin spieg mod programm può cre tip dat . </question_text><answer id="A2765"><answer_text>i tip predefin c/c++ int,char,float,void,enum . alcun essi poss esser modific attravers parol chiav esemp long,short ,doubl , camb i valor conten . programm può cre tip dat attravers parol chiav typedef permett all&#39; utent defin identif tip dat potrann esser usat dall&#39; utent all&#39; intern programm . </answer_text><num_votes>1</num_votes></answer><answer id="A2856"><answer_text>i tip predefin linguagg c : &#34; int &#34; (numer inter ) , &#34; float&#34; &#34; doubl &#34; (numer razional ) , &#34; char &#34; (caratter asci ) . i tip defin dall&#39; utent : &#34; struct &#34; (struttur raggrupp div tip variabil ) , &#34; typedef &#34; (definizion nom tip esistent ) , &#34; enum &#34; ( list simbol variabil può assum ) , &#34; union &#34; (permett defin stess porzion memor tip div ) , &#34; bit-field &#34; (variazion struttur permett acced singol bit parol memor ) . i tip elenc dev esser defin prim &#34; main &#34; </answer_text><num_votes>3</num_votes></answer><answer id="A2811"><answer_text>i principal tip dat : int (per i numer inter ) , float (per i numer real ) , doubl (per i numer real dopp precision ) char (per i caratter ) . tip bas i tip &#34; user-defined &#34; , defin programm . i tip user-defined più utilizz struct typedef . tip struct defin variabil riun inform eterogene , ovver , all&#39; inern struttur , poss esser variabil tip divers . typedef si defin sinonim i tip già esistent . </answer_text><num_votes>0</num_votes></answer><answer id="A2809"><answer_text>i tip bas dat : -&#38;#8239 ;int (inter ) , -&#38;#8239 ;float (real ) , -&#38;#8239 ;doubl (real dopp precision ) &#38; #8207 ; , -&#38;#8239 ;char (caratter ) . e&#39; possibil defin sinonim tip dat esistent attravers costrutt typedef . </answer_text><num_votes>0</num_votes></answer><answer id="A2783"><answer_text>i tip dat c : -tip semplic : element ?insiem consider entit non scompon part più elementar -tip struttur : ciascun element ?insiem è aggreg element volt semplic struttur -tip defin dall&#39; utent : tip può esser defin dand tip già esistent -tip predefin built in(inter , real float ) già defin linguagg linguagg programm permett all&#39; utent cre tip dat mediant l&#39; utilizz seguent struttur : struct ,enum ,typedef,ecc </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2920"><question_text>tipolog dat poss esser inser struttur ? quant dat poss esser conten all&#39; intern struttur ? e&#39; possibil struttur struttur ? </question_text><answer id="A2913"><answer_text>struttur poss esser conten tip dat numer , com int float , caratter array . struttur può conten intern un&#39; altra struttur . </answer_text><num_votes>0</num_votes></answer><answer id="A2784"><answer_text>poss esser inser struttur i tip bas qual int , float , doubl chat . è possibil struttur struttur utilizz tip struttur qual struct , typedef , enumeration </answer_text><num_votes>1</num_votes></answer><answer id="A2778"><answer_text>quand si parl struttur c si rifer costruzion defin programm poss conten n tip dat div tutt tipolog , mod eterogene (tip predefin , array , dat enum , ecc ) . not è tal costrutt poss esser utilizz tramm typedef defin mod comod veloc tip dat div quell predefin ; permett costru &#34; struttur struttur &#34; quant volt defin tip dat eterogene esso può esser utiliz com camp all&#39; intern struttur grand . </answer_text><num_votes>1</num_votes></answer><answer id="A2864"><answer_text>struttur è particol tip user-defined permett raggrupp variabil eterogene (integer , char , ecc ) . struttur poss conten quant dat si vogl , ovvi evit cad overflow . inoltr è possibil defin struttur struttur . ciò permett organizz defin struttur ordin alcun inform (com poss esser voc agend ) bisogn più voc esser rappresent . var camp struttur si acced tram dot-notation . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2825"><question_text>different c&#39; è costrutt typedef struct ? </question_text><answer id="A2893"><answer_text>typedef è &#34; parol chiav &#34; serv dichiar tip . mentr costrutt &#34; struct &#34; permett defin struttur aggreg inform var tip . poch parol &#34; struct &#34; è tip , dunqu esser defin dovr esser preced &#34; typedef &#34; . </answer_text><num_votes>0</num_votes></answer><answer id="A2850"><answer_text>different const fatt struct è costruttor tip defin struttur , mentr typedef è oper sintatt ridefin cre identif tip esistent variabil user-defined (com struttur stess ) . typedef struct mod defin tip defin dall&#39; utent spess typedef struct usat insiem dar nuov struttur . </answer_text><num_votes>1</num_votes></answer><answer id="A2788"><answer_text>i costrutt svolg funzion simil , different : -se dichiar struct potr assegn variabil , dovr dop dichiar struttur . -se dichiar typedef (costruttor tip ) potr dichiar quant variabil vorr segu dichiar tip , non possibil semplic struttur . typedef struct { int nmatricol ; char [20 ] ; } student ; mod si potrann cre array tip : student student [100 ] ; </answer_text><num_votes>1</num_votes></answer><answer id="A2882"><answer_text>struttur c sostanzial permett l&#39; aggreg , non necessar ordin omogene , più variabil (anc , , tip divers ) . funzion &#34; typedef &#34; , , vien utilizz defin tip dat . infin l&#39; uso &#34; typedef &#34; può esser combin &#34; struct &#34; ciò permett cre tip dat compless . </answer_text><num_votes>0</num_votes></answer><answer id="A2806"><answer_text>cos effett , different sta scrittur programm infatt struct quand vuo cre variabil tip &#39;dat &#39; dev scriv struct dat vard ; mentr typedef dev scriv dat vard ; </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2822"><question_text>perc è import defin numer epsilon piccol piac quand bisogn confront valor tip float ? </question_text><answer id="A2827"><answer_text>ricord i tip float usat c (che sian quantific long ò doubl ) rappresent concettual l&#39; insiem numer real realta&#39; non sottoinsiem r caus precision limit calcol . dunqu defin qualsias tip virgol mobil è consigl cit vincol precision tram costant float sufficient vicin zer , appunt epsilon assicur margin accett error oper confront valor : &#34; ( x==y ) --&#62; (x&#60;=y+eps ) &#38;&#38; (x&#62;=y-eps ) &#34; dov , es : #defin eps 0.00001 </answer_text><num_votes>4</num_votes></answer><answer id="A2801"><answer_text>perc calcol non è infinit precis . talvolt numer 0 vien consider 0,0000034 . sicurezz si mett epsilon mett ripar quest evenient </answer_text><num_votes>0</num_votes></answer><answer id="A2926"><answer_text>perc valor float , caus error minim calcol legg cert valor , non poss mai esser ugual . vien cos defin numer epsilon piccol rapresent margin error , graz qual si poss confront valor tip float dov approssim , garant appunt valor epsilon . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2887"><question_text>qual different costruttor tip &#34; array &#34; &#34; struct &#34; ? </question_text><answer id="A2921"><answer_text>costruttor array defin insiem element tip , ordin access tram indic tip int. struct defin insiem element tip diversi,c poss esser built-in user-defined , access più facil programm tram cosiddett &#34; dot notation &#34; </answer_text><num_votes>3</num_votes></answer><answer id="A2890"><answer_text>l&#39; array è contenitor omogene , contien dat tutt tip , l&#39; access ogni element avvien attravers indic (ed cicl for ) . struct è eterogene , può conten dat tip divers , camp si acced attravers dot notation . un&#39; altra different è array non può esser restitu funzion , struct si </answer_text><num_votes>0</num_votes></answer><answer id="A2760"><answer_text>l&#39; array non si prest rappresent oggett astratt conteng variabil tip divers , struct permett defin variabil struttur aggreg inform eterogene , contrast all&#39; array . </answer_text><num_votes>0</num_votes></answer><answer id="A2753"><answer_text>prend esemp tip dat &#34; impieg &#34; qual dovrebb esser caratterizz : , cognom , codic fiscal , indirizz , numer telef , stipend via segu . l&#39; array non può esser costruttor tip adegu dat &#34; impieg &#34; poic non si prest aggreg tutt quest inform . infatt , esso è costitu element valor tip omogene . costruttor struct , , permett defin struttur dat aggreg element tip div i var element si dic camp struttur . </answer_text><num_votes>0</num_votes></answer><answer id="A2854"><answer_text>i costr.d tip consent defin tip dat struttur ovver dat costitu dall&#39; aggreg div component .utilizz l&#39; array si defin sequenz cell memor consecut omogene conteng dat uniform (stess tip ) e&#39; possibil acced attravers indic . es.int list [10 ] typedef implic .struct permett aggreg inform eterogene struttur contien tip dat div .si acced ogni singol element dot notation.d sol si dichiar form esplic typedef struct . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2886"><question_text>scop è util assoc tip defin un&#39; enumer ? forn esemp </question_text><answer id="A2877"><answer_text>è util non dover ripet l ?elenc valor ogni volt si defin variabil . esemp : typedef enum {lun , mar , mer , gio , ven , sab , dom } giornosettiman ; ? ? giornosettiman giorn ; </answer_text><num_votes>0</num_votes></answer><answer id="A2871"><answer_text>può esser util assoc tip defin enumer non dover ripet l&#39; elenc ogni volt variabil quel tip vien defin . esemp : typedef enum{giall , verd , ross , blu , viol , ros } coloriarcobalen ; coloriarcobalen color ; color = giall ; // stamp valor color ( cas giall ) printf ( &#34; % d &#34;, color ) ; </answer_text><num_votes>1</num_votes></answer><answer id="A2860"><answer_text>è util assoc tip defin un&#39; enumer non dover ripet ogni volt l&#39; elenc valor . esemp : typedef enum {lun , mar , mer , gio , ven , sab , dom } giornoimpegn ; giornoimpegn giornoiniz ; giornoimpegn giornofin ; </answer_text><num_votes>0</num_votes></answer><answer id="A2779"><answer_text>è util assoc tip defin un&#39; enumer non dover ripet l&#39; elenc valor ogni volt si defin variabil , sens non divent necessar richiam tutt string dell&#39; insiem tip defin . esemp : enum{nome1,nome2,nome3,nome4 } student non dover richiam tutt part enum , si proced mod : typedef enum{nome1,nome2,nome3,nome4 } studentedainterrog ; studentedainterrog student ; </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2885"><question_text>specific quant rappresent complement qual . inoltr spieg funzion rappresent complement elenc i mot utilizz . </question_text><answer id="A2915"><answer_text>rappresent : complement l&#39; altra complement . complement consist nell&#39; invert zer vicevers ; complement funzion simil complement l&#39; unic different calcol aggiung . </answer_text><num_votes>0</num_votes></answer><answer id="A2805"><answer_text>rappresent complement : rappresent complement . più utilizz è quell complement rappresent tutt i numer -2^ (n-1 ) +2^ (n-1 ) -1 dov n sta numer bit utilizz . msb (most significant bit ) rappresent segn numer , esso è 0 si proced normal decodifica,s val 1 si sottrarr 2^ (n-1 ) numer decodific ; inoltr camb segn numer bast invert cifr somm 1 . si usa perc è access sistem semplic quant usa circu . </answer_text><num_votes>2</num_votes></answer><answer id="A2878"><answer_text>rappresent complement più utilizz vantagg non dopp codif tratt segn non richied circuiter specif tratt segn . rappresent complement bit rappresent segn n bit si codific i valor -2^ (n-1 ) 2^ (n-1 ) -1 . codif avvien normal bit è 0 , mentr si decodif poi si sottra 2^ (n-1 ) . inoltr invert numer binar si invert singol cifr poi si aggiung . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2792"><question_text>descr l&#39; algoritm necessar implement conversion conversion binar ottal . </question_text><answer id="A2816"><answer_text>poic 8=2^3 , ogni cifr total corrispond 3 cifr binar : 000=0 001=1 010=2 011=3 100=4 101=5 110=6 111=7 convert numer sistem binar ottal si proced mod : si consider numer binar part destr si divid grupp 3 cifr binar . dop l&#39; oper avanz cifr si aggiung tant zer quant bast complet grupp . ogni grupp poi convert corrispett numer ottal , com indic . esemp : conversion numer binar (1101 ) bas ottal (1101 ) = (1|101 ) = (001|101 ) =15 bas ottal . </answer_text><num_votes>2</num_votes></answer><answer id="A2879"><answer_text>conversion binar ottal si può semplic passagg convert binar decimal poi decimal binar . metod non vist lezion più pratic è seguent . bas tabell conversion 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 conversion si fa semplic isol 3 3 i numer binar , convert tram tabell poi rimett tutt insiem . esemp 10101011.1111-&#62; (10 ) ( 101 ) ( 011 ) . (111 ) ( 11 ) -&#62; (010 ) ( 101 ) ( 011 ) . (111 ) ( 110 ) -&#62; ( 2 ) ( 5 ) ( 3 ) . (7 ) ( 6 ) -&#62;253.76 </answer_text><num_votes>1</num_votes></answer><answer id="A2769"><answer_text>convert numer form binar ottal occorr : 1 . prend numer binar suddivid , part dall&#39; lsb , grupp 3 cifr 2 . far corrispond ogni grupp 3 cifr binar l&#39; equivalent valor form decimal 3 . comporr numer ottal affianc cifr otten convert ogni grupp bit , rispett l&#39; ordin numer binar esemp : (110101001 ) bin =&#62; (110 ) bin (101 ) bin (001 ) bin (6 ) dec (5 ) dec (1 ) dec =&#62; (651 ) tt </answer_text><num_votes>1</num_votes></answer><answer id="A2885"><answer_text>essend 8 multipl 2 (2^3 ) conversion risult semplic : ogni 3 cifr binar si otterr un&#39; unic cifr ottal . numer convert separ grupp cifr part destr (senz preoccup cifr non multipl ) ognun qual vien divis 8 . numer ottal si ottien lettur sequenz rest otten division . facc esemp chiar : numer binar 1001010111 suddivis mod : &#34; 00 &#34; 1 -001-010-111 ; division ogni triad 8 si otteng i rest 1-1-2-7 . numer convert è 1127 . </answer_text><num_votes>3</num_votes></answer><answer id="A2884"><answer_text>essend 8 multipl 2 (2^3 ) conversion risult semplic : ogni 3 cifr binar si otterr un&#39; unic cifr ottal . numer convert separ grupp cifr part destr (senz preoccup cifr non multipl ) ognun qual vien divis 8 . numer ottal si ottien lettur sequenz rest otten division . facc esemp chiar : numer binar 1001010111 suddivis mod : &#34; 00 &#34; 1 -001-010-111 ; division ogni triad 8 si otteng i rest 1-1-2-7 . numer convert è 1127 . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2817"><question_text>qual mot dichiar tip variabil è requis fondamental compil ? </question_text><answer id="A2803"><answer_text>dichiar tip variabil è fondamental fas programm far cap compil com esso debb tratt variabil stess . tip specif infatt aspett enorm import caratterizz variabil esso fa rifer , inform compil : 1 ) qual valor variabil può assum ; 2 ) l&#39; insiem oper poss esser effettu quest ultim ; 3 ) quantit memor esserl riserv tal variabil : char=1 byte int short=2 byte long float=4 byte double= 8 byte . </answer_text><num_votes>4</num_votes></answer><answer id="A2795"><answer_text>dichiar tip variabil è requis fondamental quant defin l&#39; insiem valor variabil può assum , oper essa poss esser applic </answer_text><num_votes>0</num_votes></answer><answer id="A2891"><answer_text>dichiar variabil si alloc spaz memor programm potr utilizz determin scop , inser cert tip dat (specific dichiar ) . quantit memor alloc dip tip variabil dichiar . non dichiar variabil vien riconosc com error , quant programm non saprebb spaz utilizz segu . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2922"><question_text>si ottien output esegu oper aritmet (+ , - ,* ,/ ) dat tip char ? </question_text><answer id="A2920"><answer_text>risult sar valor tip int risult dall&#39; oper desider , esemp a-a=|40| tabell asci è valor separ i caratter , cas sar risult oper . </answer_text><num_votes>0</num_votes></answer><answer id="A2786"><answer_text>i caratter segu stess regol operazional inter . dat i tip char codific asci 7 bit , facc char c,t ; poi somm , succed si somm i bit codific i tip char risult è numer inter conversion binar decimal verr stamp vide tram printf . </answer_text><num_votes>0</num_votes></answer><answer id="A2919"><answer_text>risult sar valor tip int risult dall&#39; oper desider , esemp a-a=|40| tabell asci è valor separ i caratter , cas sar risult oper . </answer_text><num_votes>0</num_votes></answer><answer id="A2773"><answer_text>oper aritmet variabil tip char ident quell tip int. somm , esemp , caratt (riconduc numer tabell codic asci ) caratt (altr numer tabell ) si otterr caratt (corrispondent numer tabell asci ) otten somm caratter precendent . </answer_text><num_votes>1</num_votes></answer><answer id="A2775"><answer_text>compil svolg l&#39; oper codic asci corrispett caratter , percu dar &#39; comunqu un&#39; caratt corrispondent codic asci risult dell&#39; oper svolt non error com si potrebb immagin . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2793"><question_text>qual mot è fortement sconsigl l&#39; utilizz dell&#39; oper == variabil tip float doubl ? </question_text><answer id="A2802"><answer_text>l&#39; utilizz tal oper è sconsigl presenz floating point . ovver essend i numer rappresent attravers codic binar funzion esponenzial , essend numer bit fin , numer real poss infin numer dop virgol , fa si numer real &#34; ugual &#34; present different nell&#39; digit fa si l&#39; oper == restitu corrispondent non ver . </answer_text><num_votes>1</num_votes></answer><answer id="A2755"><answer_text>e&#39; fortement sconsigl poic , verif tip (x==y ) , risult è &#34; ver &#34; tutt cifr decimal ugual è improb . e&#39; consigl scriv : ( ( x &#62;= (y-d ) ) &#38;&#38; (x&#60;= (y+d ) ) dov d è piccol margin incertezz . </answer_text><num_votes>3</num_votes></answer><answer id="A2894"><answer_text>quant l&#39; oper uguagl (== ) relazion variabil poss differ quant variabil float contien numer real virgol mentr variabil doubl identif numer real virgol different float può conten numer più compless lung </answer_text><num_votes>0</num_votes></answer><answer id="A2812"><answer_text>simbol &#34; == &#34; è un&#39; oper relazional uguagl ; ritorn 1 (ver ) 2 espression ritorn valor ugual ritorn 0 (fals ) cas contrar . usiam variabil float (32 bit ) variabil doubl (64 bit ) difficil restitu valor credibil poic variabil tip doubl contien più numer . </answer_text><num_votes>0</num_votes></answer><answer id="A2892"><answer_text>quant l&#39; oper uguagl (== ) relazion variabil poss differ quant variabil float contien numer real virgol mentr variabil doubl identif numer real virgol different float può conten numer più compless lung </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2870"><question_text>mod c riesc confront ordin i caratter ? </question_text><answer id="A3434"><answer_text>calcol è grad rappresent i caratter alfabet , numer i simbol special punteggiatur ogni divers caratt vien assegn , convenzional , codic numer corrispondent programm c lavor sempr i codic numer . inoltr lett maiuscol tutt consecut , ordin alfabet com pur lett minuscol tutt consecut , ordin alfabet (le lett maiuscol veng ?prim ? minuscol ) , cifr numer tutt consecut , ordin 0 9 . confront avvien numer . </answer_text><num_votes>0</num_votes></answer><answer id="A2905"><answer_text>i tip char sol veng rappresent mediant byte , sufficient rappresent i 256 caratter codif ascii.l&#39; asci è sistem codif caratter 7 bit , comun utilizz calcol . codic asci caratter realt memor vien espress numer inter -128 +127 defin oper assegn quell aritmet quell relazional .pertant , i caratter è automat defin ordinamento,per esemp sar lec scriv &#39;a&#39;&#60; &#39; r &#39; . </answer_text><num_votes>2</num_votes></answer><answer id="A2844"><answer_text>i caratter string linguagg c poss esser semplic confront ordin . si prend esemp consider l&#39; eserciz (svolt laborator ) confront string decid qual preced l&#39; altra ordin alfabet . bast utilizz variabil contator cont numer caratter utilizz un&#39; altra valut i caratter . </answer_text><num_votes>0</num_votes></answer><answer id="A2911"><answer_text>ogni caratt è rappresent rispett numer inter (codic asci ) . confront caratter è necessar confront i relat codic asci . esemp caratt &#39;0 &#39; è identific codic 48 , mentr caratt &#39;1 &#39; è identific codic 49 . confront poss dir 0&#60;1 . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2820"><question_text>permett costruttor struct ? ? </question_text><answer id="A2787"><answer_text>permett defin variabil cre dall&#39; utent aggreg inform var tip . </answer_text><num_votes>0</num_votes></answer><answer id="A2909"><answer_text>tip struct permett cre array struttur dat non omogene , cio array può conten variabil tip char , variabil tip int float , string caratter , esemp . </answer_text><num_votes>1</num_votes></answer><answer id="A2843"><answer_text>costruttor struct permett defin variabil struttur aggreg inform eterogene , non concess array . cio costruttor struct poss inser più variabil divers tip . non ved più variabil singolar , si parl entit più compless , caratterizz div camp . (es l&#39; entit (nome,cognome,et ) ) . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2903"><question_text>qual&#39; è proced segu convert numer decimal esadecimal ? </question_text><answer id="A2876"><answer_text>si divid numer 16 si consider risult rest , success si divid risult precedent trov 16 (sempr consider rest ) , si proced cos finc risult divison è zer (con rest ) . infin si consider i rest trov ordin invers : è numer partenz bas esadecimal . es : (35 ) base10-&#62; 35/16= 2 (rest 3 ) , 2/16 = 0 (rest 2 ) , (35 ) base10 -&#62; (23 ) base16 ovver numer cerc sequenz rest contrar . </answer_text><num_votes>0</num_votes></answer><answer id="A2763"><answer_text>sistem esadecimal cifr vann 0 9 qual si aggiung prim lett dell&#39; alfabet (a ,b,c ,d ,e ,f ) . i valor lett : a=10,b=11,c=12,d=13 ,e=14 ,f=15.per convert numer decimal numer esadecimal è necessar divid numer dat i success quozient 16 segu prend i rest ordin contrar ricord 10 15 valor sostitu lett . esemp : n° 26 26/16=1 resto=10 ( ) 1/16=0 resto=1 26 decimale= 1a esadecimal </answer_text><num_votes>3</num_votes></answer><answer id="A2918"><answer_text>conversion b10 b16 si verif numer b10 è maggior 16 , cos è si divid 16 prend rest si moltipl 16 otten numer 0 9 lett g,dov a=10,b=11 , c=12,d=13 ,e=14 ,f=15 , g=16.di segu numer inter rimast division si effettu proced non si numer inferiore/ugual 16 si assegn rispett termin : es : (4321 ) b10 = -&#62; 4321/16 = 270 + resto1 . 270/16 = 16 resto . 16/16 = g. (4321 ) b10 = (ge1 ) b16 . verif si not : (g * 16^2 ) + (e*16^1 ) + (1*16^0 ) =4321 </answer_text><num_votes>0</num_votes></answer><answer id="A2858"><answer_text>conversion si prend numer binar si divid 16 quand possibil . scriv numer esadecimal si prend i risult division i numer 0 9 vann scritt cos com , i risult 10 15 vann scritt lett f, i risult 16 25 vann scritt i numer 10 19, poi si ripet lett numer davant . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2958"><question_text>qual è different codic asci 7 bit 8 bit ? </question_text><answer id="A2855"><answer_text>codic asci forn tabell elenc corrispondent caratter numer . different codic asci standard 7 bit , mett disposizion possibil rappresent 128 caratter (2^7 caratter ) codific attravers 7 bit inform , conterrann cifr binar assoc caratt corrispondent , codic asci estes 8 bit mett disposizion possibil rappresent 256 caratter div (2^8 caratter ) , quant i bit veng consider grupp 8 non più grupp 7 . </answer_text><num_votes>1</num_votes></answer><answer id="A2751"><answer_text>codif asci 7 bit è standard codif caratter pot rappresent 128 caratter (2^7 ) . quest 128 alcun rappresent caratter alfanumer , dett caratter non stampabil rappresent codic controll (ad esemp &#39;null&#39; ) . codif 8 bit (extended asci ) è stat svilupp segu poter codific caratter fuor 128 original (ad esemp lett accent simbol val ) . </answer_text><num_votes>2</num_votes></answer><answer id="A2875"><answer_text>different codic asci 7 bit 8 bit consist puo&#39; conten massim 128 unit &#39; lett maiuscol minuscol , numer (0 127 ) , alcun simbol , codic asci 8 bit contien massim 256 unit &#39; aggiunt all&#39; elenc precedent lett accent simbol eran 7 bit . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2918"><question_text>com avvien conversion ottal decimal ? </question_text><answer id="A2754"><answer_text>convert numer inter sistem ottal sistem decimal riscriv com somm cifr numer moltiplic potenz decrescent 8 . esemp 576 ( base8 ) = (5*8^ ( 2 ) ) + (7*8^ ( 1 ) ) + (6*8^ ( 0 ) ) =320+56+6=382 (base10 ) . numer non intero,per convert part frazionar , somm cifr part frazionar numer moltiplic potenz crescent negat 8(per part inter proced com descritt precedent ) . esemp 576 ,16 ( base8 ) = (5*8^ ( 2 ) ) + (7*8^ ( 1 ) ) + (6*8^ ( 0 ) ) + (1*8^ ( -1 ) ) + (6*8^ ( -2 ) ) =320+56+6+1/8+3/32=382 ,21875 (base10 ) . </answer_text><num_votes>2</num_votes></answer><answer id="A2752"><answer_text>convert numer ottal decimal , dobb scriv numer dat com somm prodott cifr numer potenz decrescent dell&#39; 8 . </answer_text><num_votes>1</num_votes></answer><answer id="A2750"><answer_text>conversion ottale-decimal è trasform numer bas ( sistem ottal ) numer bas diec ( sistem decimal ) . essend sistem numer posizional convert numer ottal numer decimal è sufficient moltiplic ogni cifr numer (d ) potenz 8 corrispondent (n ) , somm i risult . </answer_text><num_votes>0</num_votes></answer><answer id="A2790"><answer_text>esegu conversion ottal decimal si dev esegu ser moltipl elev valor dip posizion bit occup nell&#39; array (ricord posizion pes minor , ovver quand l&#39; esser elev zer , è relat all&#39; ultim cell dell&#39; array ) , dop aver esegu moltipl , si dev somm i div contrib leg bit dell&#39; array binar . risult otten è ciò cerc , ovver form decimal . </answer_text><num_votes>1</num_votes></answer><answer id="A2851"><answer_text>conversion ottal decimal avvien sequent manier : valor (più destr ) string bit numer ottal esser moltiplic numer 8 elev posizion bit , segu bit ecc . tutt quest valor veng poi somm uscit valor decimal . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2868"><question_text>qual è different tip &#39;struct&#39; &#39;typedef struct&#39; ? </question_text><answer id="A2798"><answer_text>struct defin tip dat (user-defined ) può esser utilizz dichiar variabil contestual definizion segu . typedef struct defin alias tip dat struct . esemp : typedef struct{ float x,y,z ; } coord ; coord è tip dato,quind può esser utilizz com tip variabil . &#34; typedef &#34;,coord sarebb variabil bas struttur contenent i dat x,y z . </answer_text><num_votes>0</num_votes></answer><answer id="A2767"><answer_text>innanzitutt è più corrett chiam ?struct ? non tip , costruttor tip , quant è costrutt permett raggrupp variabil tip divers . different ?typedef struct ? è può dichiar sol variabil leg struttur (quind vogl più variabil fatt quel mod cre altrett struct ) , mentr costrutt permett ridefin struct scelt ?utent dichiar moltepl variabil leg struttur , ovunqu codic , utilizz scelt com foss tip dat predefin . </answer_text><num_votes>0</num_votes></answer><answer id="A2836"><answer_text>&#34; struct &#34; si dichiar variabil struttur raggrupp insiem variabil tip divers , &#34; typedef struct &#34; si defin dichiar variabil , cas , tip struct . </answer_text><num_votes>1</num_votes></answer><answer id="A2807"><answer_text>typedef struct permett semplic dichiar nuov variabil tip struct ripet ogni volt &#34; struct &#34; fas dichiar . </answer_text><num_votes>0</num_votes></answer><answer id="A2764"><answer_text>espression esprim stess : &#34; typedef struct &#34; si defin &#34; struct &#34; com tip dat , cert variabil x potr esser dichiar com : struct x ; &#34; struct &#34; intend struttur dat form element non omogene . different sta tip linguagg usat : typedef struct{ int x ; char y ; } nomevar ; struct nomevariabile{ int x ; char y ; } </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2953"><question_text>consist variabil caratt enumer qual utilizz risult comod ? </question_text><answer id="A2848"><answer_text>variabil tip enumer può assum valor (un volt ) predetermin moment dichiar . particol , quest valor sol etichett , ciascun qual vien automat assoc numer progress part 0 . tip variabil è util quand oper numer fin cas possibil , esemp valor boolean (fals ver ) , giorn settiman , mes dell&#39; anno , ogni cas list fin . </answer_text><num_votes>3</num_votes></answer><answer id="A2835"><answer_text>variabil caratt enumer (enum ) descriv tip (com struct ) , serv dichiar variabil i valor &#34; possibil &#34; &#34; ristrett &#34; &#34; predetermin &#34; ( cio i valor spercific elenc ) . inoltr l&#39; uso enum è util perc permett scriv codic più chiar più esplic . </answer_text><num_votes>0</num_votes></answer><answer id="A2906"><answer_text>variabil caratt enumer durant l&#39; esecu programm puo&#39; assum valor qualsias , vien decis programm , realt valor numer int 0 n-1 variabil scelt . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2904"><question_text>qual&#39; è proced segu defin tip dat &#34; user-defin &#34; ? </question_text><answer id="A2927"><answer_text>defin tip dat c si utilizz parol chiav typedef . quest esser segu tip dat dall&#39; identif tip dat . esemp typedef int inter . dichiar variabil tip dat si usa sint nuovo_tipo_d nome_variabile.per esemp : inter numer typedef vien spess utilizz defin tip dat struct cos è sufficient , ogni qualvolt si intend dichiar variabil tal tip , utilizz tip dat riscriv inte struttur . </answer_text><num_votes>1</num_votes></answer><answer id="A2857"><answer_text>dichiar tip dat user-defined avvien solit part dichiar programm , dop costant prim variabil . parol chiav utilizz cas è &#34; typedef &#34; segu : 1 ) tip dat si vuol cre (ovver specif com è costru part tip esistent , sian built-in user-defined volt ) ; 2 ) tip ; 3 ) simbol &#34; ; &#34; . esemp : &#34; typedef int anno ; &#34; . mod attravers &#34; typedef &#34; è possibil assoc tip defin mediant costrutt &#34; struct &#34; , array puntator . </answer_text><num_votes>1</num_votes></answer><answer id="A2865"><answer_text>possibil proced defin tip dat user defin può esser definizion mediant l&#39; oper &#34; typedef &#34; struttur &#34; struct &#34; defin programm assegn tip dat scelt programm qual all&#39; intern programm serv defin variabil tip &#34; struct &#34; . </answer_text><num_votes>0</num_votes></answer><answer id="A2762"><answer_text>è necessar inizializz tip user-defined fuor main.c success dichiar . esemp cas struttur bisogn inizializz &#34; struct &#34; ogni part , singol variabil , poi si dichiar all&#39; intern main.c . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2952"><question_text>dat string binar 01010101 , qual numer decimal corrspond ipotes codific binar , modul segn complement ? </question_text><answer id="A2833"><answer_text>dat numer binar 01010101 , calcol cos numer decimal corrispond : 1*2^6=64 0*2^5=0 1*2^4=16 0*2^3=0 1*2^2=4 0*2^1=0 1*2^0=1 somm i var risult otten numer decimal 85 . quant riguard segn bast ved prim cifr (da sinistr ) è 0 numer sar posit è 1 sar negat , cas è posit . utilizz complement 2 otten numer binar 10101011 (bisogn invert 0 1 vicevers , somm 1 ) , fac i calcol com prim otten numer decimal 171. </answer_text><num_votes>0</num_votes></answer><answer id="A2849"><answer_text>codific binar modul segn corrispond numer 85 (posit ) ; idem codif complement 1 2 . essend posit infatt proced conversion non camb . </answer_text><num_votes>0</num_votes></answer><answer id="A2832"><answer_text>dat numer binar 01010101 , calcol cos numer decimal corrispond : 1*2^6=64 0*2^5=0 1*2^4=16 0*2^3=0 1*2^2=4 0*2^1=0 1*2^0=1 somm i var risult otten numer decimal 85 . quant riguard segn bast ved prim cifr (da sinistr ) è 0 numer sar posit è 1 sar negat , cas è posit . utilizz complement 2 otten numer binar 10101011 (bisogn invert 0 1 vicevers , somm 1 ) , fac i calcol com prim otten numer decimal 171. </answer_text><num_votes>3</num_votes></answer><answer id="A2897"><answer_text>string binar è codific binar , corrispondent numer decimal è = 1* (2^0 ) + 0* (2^1 ) + 1* (2^2 ) + 0* (2^3 ) + 1* (2^4 ) + 0* (2^5 ) + 1* (2^6 ) + 0* (2^7 ) = 85 , è codific modul segn : bit più signif (0 ) indic numer è posit codif appen usat = +85 , è codific complement 2 : essend bit più signif 0 , si proced normal codif perc = +85 . com cas string binar bit più signif 0 corrispond numer decimal ciascun quest divers codif . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2889"><question_text>poss inser com tip camp all&#39; intern struttur ? </question_text><answer id="A2895"><answer_text>i tip camp si poss inser all&#39; intern struttur i seguent : -tip semplic (inter caratter ) ; -tip struttural (array , ... ) ; -tip predefin linguagg ; -tip implement programm . </answer_text><num_votes>0</num_votes></answer><answer id="A2771"><answer_text>all&#39; intern struttur si poss defin variabil , dett camp , aggreg inform eterogene . tal variabil poss esser qualsias tip (int , char , float array ) . l&#39; access singol camp struttur avvien tram &#34; dot notation &#34; (ad esemp : nomestruttura.campo1 ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2859"><answer_text>poss utilizz manipol valor tip numer (int , doubl , float , long , ... ) string caratter (char , string ) . inoltr poss inser tip compost com array numer caratter . </answer_text><num_votes>1</num_votes></answer><answer id="A2796"><answer_text>struttur vien defin costrutt struct , oppur altern si poss implement costruttor tip typedef struct , è possibil cre insiem variabil correl poss esser tutt i tip prevvist linguagg c tip alfanumer numer , inoltr è possibil aggiung com &#39;typedef enum&#39; valor particolar parol , miglior leggibil programm . </answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L33" title="Strutture di Controllo, Puntatori" date="2013-10-25"><question id="QQ3114"><question_text>qual istuzion consent struttur controll ? qual defin compl teorem boehm jacopin ? </question_text><answer id="A3050"><answer_text>struttur controll &#34; if-els &#34; &#34; whil &#34; defin compl quant permett codific qualsias algoritm . </answer_text><num_votes>0</num_votes></answer><answer id="A3039"><answer_text>cre struttur controll poss utilizz *sequenz istruzion *cicl : for whil *selezion : if , if-els , do-whil , switc ... teorem bj if-els whil compl , ossi sufficient codific qualsias algoritm . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ3056"><question_text>dic &#34; teorem boehm-jacopin &#34; ? </question_text><answer id="A3087"><answer_text>teorem boehm-jacopin afferm qualunqu algoritm può esser implement utilizz sol struttur : sequenz (è normal elenc istruzion ) , selezion (if-els ) cicl (iter costrutt whil ) , applic ricors composizion istruzion elementar . quest struttur eqivalent struttur controll linguagg assembl struttur controll qualsias linguagg programm . </answer_text><num_votes>0</num_votes></answer><answer id="A3037"><answer_text>teorem boehm-jacopin enunc : &#34; algoritm puo&#39; esser implement utilizz sol struttur . sequenz , selezion cicl . &#34; dov sequenz e&#39; l&#39; insiem istruzion esegu nell&#39; ordin decis programm , selezion e&#39; scelt percors (es . if , if-els ) cicl e&#39; blocc istruzion esegu condizion permett (es . whil , for ) . quest fas e&#39; possibil cre algoritm esegu qualsias macchin . </answer_text><num_votes>1</num_votes></answer><answer id="A3066"><answer_text>teorem boehm-jacopin (enunc omonim informat 1966 ) afferm linguagg programm possied istruzion sequenz (di istruzion ) , selezion i cicl , è complet . quest sequenz istruzion è possibil codific ogni programm esegu calcol , quant quest istruzion equivalent istruzion linguagg assembler . teorem import teoric , quant permett comprend qual istruzion elementar ogni compil permett cap qual i linguagg complet . </answer_text><num_votes>1</num_votes></answer><answer id="A3056"><answer_text>teorem böhm-jacopin afferm qualsias algoritm può esser codific può esser implement utilizz struttur : sequenz selezion cicl debb esser applic comand semplic . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3059"><question_text>verr stamp vide ? comment rispost . typedef int tipod ; int main(int argc , char *argv[ ] ) { tipod *p ,dat ; tipod **dp ; dat = 1; p = &#38;dat ; dp = &#38;p ; printf ( &#34; % d\n &#34; , p ) ; printf ( &#34; % d\n &#34; , *p ) ; printf ( &#34; % d\n &#34; , dp ) ; printf ( &#34; % d\n &#34; , *dp ) ; printf ( &#34; % d\n &#34; , **dp ) ; system ( &#34; paus &#34; ) ; return exit_success ; } </question_text><answer id="A2965"><answer_text>vide stamp 5 valor : valor rappresent l&#39; indirizz dat valor rappresent valor dat valor rappresent l &#39;indirizz puntator punt dat valor rappresent l&#39; indirzz dat l&#39; valor rappresent valor punt puntator ossi valor dat =1 </answer_text><num_votes>1</num_votes></answer><answer id="A3006"><answer_text>1a rig verr stamp l&#39; indirizz variabil dat , perc puntator p è assegn l&#39; indirizz dat l&#39; oper &#38; . 2a rig verr stamp variabil punt p , ovver dat (1 ) . 3a rig verr stamp l&#39; indirizz p , sar l&#39; indirizz success prim rig (+4 bytes ) non è occup prim dat . 4a rig verr stamp l&#39; indirizz prim rig perc è valor punt dp (l&#39; indirizz dat ) . nell&#39; ultim verr stamp valor dat (1 ) perc è valor punt p. </answer_text><num_votes>0</num_votes></answer><answer id="A3084"><answer_text>esegu linguagg c , compil dà error quant manc : #includ &#60;stdi .h&#62; #includ &#60;stdlib.h&#62; vien corrett , risult è : 2686784 1 2686788 2686784 1 printf stamp ciò è conten memor rifer tipod p , ossi l&#39; indirizz dat . stamp ciò punt p , cio conten dat . , mostr ciò dp contien : l&#39; inidirizz p. com , visualizz conten p , cio l&#39; indirizz dat , essend puntator indirizz non dat . l&#39; infin stamp conten dat . </answer_text><num_votes>1</num_votes></answer><answer id="A2996"><answer_text>&#34; indirizz dat &#34; 1 &#34; indirizz p &#34; &#34; indirizz dat &#34; 1 e&#39; chiar esemp com funzion i puntator , util lavor funzion , procedur gestion memor . </answer_text><num_votes>0</num_votes></answer><answer id="A2966"><answer_text>vide stamp 5 valor : valor rappresent l&#39; indirizz dat valor rappresent valor dat valor rappresent l &#39;indirizz puntator punt dat valor rappresent l&#39; indirzz dat l&#39; valor rappresent valor punt puntator ossi valor dat =1 </answer_text><num_votes>0</num_votes></answer><answer id="A3065"><answer_text>vide stamp 5 valor : valor rappresent l&#39; indirizz dat ; valor rappresent valor dat ; valor rappresent l&#39; indirizz puntator punt dat ; valor rappresent l&#39; indirizz dat ; l&#39; valor rappresent valor punt puntator ossi valor dat . </answer_text><num_votes>2</num_votes></answer><answer id="A3031"><answer_text>seguent righ codic stamp tram printf valor variabil p non contien null , vien stamp valor variabil punt p , cio dat val 1 . printf stamp rispett variabil dp , non contien null variabil qual punt dp , cio p anch&#39; esso non contien null . l&#39; printf , , stamp puntator dp , ovver variabil punt dp , cio p , variabil punt p , cio dat val 1 . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3012"><question_text>compil costrutt &#34; switc &#34; si omett break cas , qual conseguent verrann apport programm ? cio &#39; puo&#39; esser util ? si , cas ? </question_text><answer id="A3047"><answer_text>&#34; break &#34; costrutt switc fa sì si esca dell&#39; istruzion un&#39; istruzion switc . si omett veng esegu tutt istruzion casist success . ciò può caus un&#39; esecu divers quell previst programm , consc usat può dar vantagg com l&#39; estension più casist . </answer_text><num_votes>0</num_votes></answer><answer id="A3096"><answer_text>com break com sapp consent uscir switch.nel cas si omett tal istruzion cas veng esegu istruzion success fann part cas .pu esser util cas si vogl esegu cas tutt istruzion dop esso , second valor ingress switc . es : switc ( ) { cas 0 : printf ( &#34; ciao\n &#34; ) ; break ; cas 1 : printf ( &#34; cia &#34; ) ; cas 2 : printf ( &#34; mario\n &#34; ) ; } a=0 vien esegu cas 0 , a=1 i cas 1 2 , =2 esegu cas 2 . </answer_text><num_votes>2</num_votes></answer><answer id="A3020"><answer_text>omett break cas verrann valut i cas success . break serv appunt uscir struttur casc non appen condizion desider è ver . è util inser non cad error . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3062"><question_text>int *a ; *a=20 ; quest scrittur è scorrett ,perc ? com poss risolv l&#39; error ? </question_text><answer id="A3021"><answer_text>puntator punt indirizz memor cas sarebb più appropr usar variabil puntator oppur far punt puntator (a ) variabil inizializz valor 20 . </answer_text><num_votes>0</num_votes></answer><answer id="A3085"><answer_text>precedent scrittur quand puntator vien dichiar prim rig &#34; int *a ; &#34; non sta punt null . poter esser utilizz puntator punt qualcos . l&#39; error commess consist non aver assegn indirizz memor puntator prim usarl . infatt scrittur : &#34; int *a ; *a=20 ; &#34; gener error (crash programm ) . scrittur corrett è esemp : int *a ; int x ; a=&#38;x ; *a=20 ; </answer_text><num_votes>3</num_votes></answer><answer id="A3002"><answer_text>scrittur è scorrett perc puntator *a non sta punt nessun variabil , bens valor specif , non è logic puntator . risolv dovre dichiar un&#39; altra variabil es . b , assegn valor b=20 , infin farl punt mod a=&#38;b . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3039"><question_text>nell&#39; utilizz puntator vuol dir incorr risc aliasing ? </question_text><answer id="A3100"><answer_text>linguagg programm c l&#39; aliasing puntator consist nell&#39; utilizz puntator different referenz stess variabil (quind stess posizion memor ) . cas si incorr risc compil poss gener error inattes oppur error run-tim . </answer_text><num_votes>1</num_votes></answer><answer id="A3051"><answer_text>aliasing si intend problem leg fatt oggett veng identific mod div . esemp : *pi= 1 *qi= 2 pi=q cas *pi=2 assegn valor *qi= 7 succed automat valor veng assegn *pi comport assegn esplic variabil punt qi determin assegn nascost variabil punt pi . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ3053"><question_text>qual cas risult util utilizz algoritm cicl ? </question_text><answer id="A3091"><answer_text>algoritm è prefer utilizz cicl quand sequenz oper esser ripet più . i cicl for , whil do-whil different : - cicl for è util quand numer iter è not prior - cicl whil è util quand , numer iter non è not , è necessar ripet un&#39; oper finc condizion espress &#34; whil (esp. ) &#34; risult fals - cicl do-whil permett otten risult cicl whil , mod più semplic , includ l&#39; oper , ven scritt prim whil , all&#39; intern do-whil . </answer_text><num_votes>3</num_votes></answer><answer id="A3027"><answer_text>programm , l&#39; iter , chiam cicl termin ingles &#34; loop &#34; , è struttur controll , all&#39; intern algoritm , ordin all&#39; elabor esegu ripetut sequenz istruzion , solit verific particolar condizion specific . esemp l&#39; inizializz element array . più import istruzion cicl &#34; for &#34; , &#34; whil &#34; &#34; do-whil &#34; . int i; for (i = valiniz; i &#60;= valfin ; i++ ) { //istruzion } whil (i &#60;= valfin ) { //istruzion i++ ; } do {//istruzion i++ ; } whil (i &#60;= valfin ) ; </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3041"><question_text>qual vantaggi/svantagg comport l&#39; alloc dinam memor ? com si effettu l&#39; alloc dinam memor c ? </question_text><answer id="A2989"><answer_text>alloc dinam memor c vuol dir utilizz mod flessibil : post occup quantit static stack , si alloc sol quantit necessar -graz sizeof- nell&#39; heap (più capient quant non defin prior ) , rend linguagg estrem portabil . l&#39; unic svantagg può esser attribu all&#39; ardu gestion puntator non dimentic respons liber memor termin dell&#39; utilizzo.per alloc : p= malloc(sizeof(int ) ) ; p puntator (a int ) int tip dat desider . liber : fre (p ) ; </answer_text><num_votes>0</num_votes></answer><answer id="A2984"><answer_text>i vantagg notevol , luog flessibil programm , esemp dov non not prior i parametr problem . i principal svantagg produzion garbag , uso inefficient memor , rifer fluttuant . l&#39; alloc memor vien effettu tram chiam funzion &#34; malloc(numero_bits_da_alloc ) &#34; , quest funzion restitu puntator anonim (indirizz ) heap , alloc i bits richiest . non è possibil alloc i numer bits richiest , vien restitu puntator null (ad ogni chiam verific ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3070"><answer_text>vantagg forn dall&#39; alloc dinam memor è possibil alloc dealloc eventual ridimension memor fas runtim (e non compil com memor static ) . svantagg present è cas puntator un&#39; are memor alloc dinam veng fatt punt altra are memor , part memor dinam non sar più access programm . c alloc dinamicam memor si usa costrutt tip p=malloc(sizeof(tipod ) ) dov p è puntator blocc memor alloc . </answer_text><num_votes>1</num_votes></answer><answer id="A3108"><answer_text>l&#39; alloc dinam si evit : - sprec memor dov sovradimension array - sottostim dimension array conseguent overflow - rallent oper array (ad esemp cancell element ) svantagg : - maggior compless scrittur codic - risc produzion garbag rifer fluttuant c/c++ l&#39; alloc dinam si effettu : &#39;malloc(sizeof(tipod ) ) &#39; oppur &#39;new tipod &#39; cre memor variabil tip tipod restitu l&#39; indirizz byte . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ3002"><question_text>alloc dinam memor : 1 ) qual zon memor può esser alloc dinam ? 2 ) dov avvien l&#39; alloc static ? 3 ) mod è possibil alloc static memor variabil ? </question_text><answer id="A3093"><answer_text>1 ) l&#39; heap è zon memor macchin astratt contien variabil cre dinam . 2 ) &#34; stack &#34; è zon ,invec , contien variabil dichiar var funzion variabil local . 3 ) possibil tip alloc , avveng zon precedent menzion : -l&#39; alloc static &#34; stack &#34; : esemp &#34; int a; &#34; -l&#39; alloc dinam nell&#39; &#34; heap &#34; : esemp &#34; a=malloc(sizeof(int ) ) ; &#34; . </answer_text><num_votes>0</num_votes></answer><answer id="A3109"><answer_text>1 ) si può alloc heap , run-tim . 2 ) l&#39; alloc static avvien dat segment , compile-tim . 3 ) mod alloc static variabil : - defin fuor qualsias funzion , main ( ) compres ; - anteporr definizion parol riserv static; </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3084"><question_text>sapp p q variabil tip puntator punt element array div , l&#39; istruzion p-q restitu ? </question_text><answer id="A3035"><answer_text>p q punt div element array , p-q restitu valor inter par numer element esistent l&#39; element punt p l&#39; element punt q, non different valor puntator . </answer_text><num_votes>1</num_votes></answer><answer id="A2963"><answer_text>restitu distanz i element . </answer_text><num_votes>1</num_votes></answer><answer id="A3083"><answer_text>p q punt element div array , l&#39; istruzion p-q restitu valor inter par numer element esistent l&#39; element punt puntator p l&#39; elemt punt q. l&#39; istruzion non restitu different valor puntator (cio indirizz ) . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ3123"><question_text>qual memor veng memorizz i puntator perc ? </question_text><answer id="A3102"><answer_text>i puntator veng salv memor steck , perc variabil com tutt quest destin conten indirizz memor . </answer_text><num_votes>0</num_votes></answer><answer id="A3005"><answer_text>i puntator identif serv legg scriv indirizz memor , veng memorizz &#39;stack &#39; , memor static gest pil . i puntator veng utilizz richiam cell &#39;heap&#39; , memor dinam cell non si assegn identif , poss esser punt puntator memor stack . quest gestion memor serv non alloc tropp cell memor variabil array , vann occup inter are memor , poi ven utilizz . </answer_text><num_votes>5</num_votes></answer></question><question id="QQ3013"><question_text>qual&#39; è l&#39; util puntator ? spieg com si può acced conten variabil tram puntator essa com otten l&#39; indirizz memor suddett variabil . </question_text><answer id="A3060"><answer_text>puntator è util cas alloc dinam memor . variabil puntator contien l&#39; indirizz memor variabil punt . otten l&#39; indirizz variabil si usa l&#39; oper &#38; . esemp assegn indirizz variabil puntator px : px = &#38;x ; acced conten cell , indirizz è memorizz variabil puntator px , si fa preced puntator l&#39; oper * (*px ) . </answer_text><num_votes>4</num_votes></answer><answer id="A3048"><answer_text>i puntator innanzitutt variabil conteng memor l&#39; indirizz un&#39; altra variabil poss esser qualsias tip . l&#39; utilizz puntator è l&#39; unic mod esprim alcun oper produc codic più compatt efficac . l&#39; utilizz dell&#39; oper * si ottien conten dell&#39; oggett punt puntator mentr otten l&#39; indirizz memor si utilizz l&#39; oper &#38; </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3024"><question_text>qualit tip oper è possibil nell&#39; ambit puntator ? ? ? </question_text><answer id="A3057"><answer_text>si poss usar modific permanent cell array passagg indirizz nell&#39; ambit funzion . iil valor assunt puntator è numer inter rappresent , byte , indirizz memor alcun programm ammett oper somm puntator valor inter (con risult puntator ) , oppur sottrazion puntator (con risult inter ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3079"><answer_text>7 tip oper : 1 ) p=&#38;x ; assegn p l&#39; indirizz x . &#39;&#38; &#39; indic indirizz . 2 ) * p=x ; &#39;* &#39; è simbol unar de-referenz (dereferenc ) ; indic conten variabil punt p assegn valor x . 3 ) p=q; assegn puntator p valor puntator q. 4 ) null , valor special rend indefin valor puntator . 5 ) oper confront (== ,&#60; , ... ) 6 ) aritmet puntator somm sottrazion indirizzi.l sottrazion array dà numer element . 7 ) alloc dinam memor . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ3064"><question_text>qual error si poss durant l&#39; utilizz puntator cre cos &#34; effett collateral &#34; (sid effects ) ? </question_text><answer id="A3098"><answer_text>utilizz i puntator è possibil incorr error aliasing ovver oggett può esser identific mod div . esemp puntator int*a ,*b andiam assegn = b l&#39; indirizz puntator conterr indirizz b punt inter b . cos fac si perd l&#39; inform punt inizial puntator . : *a=2 ; *b=1 ; = b ; perd *a = ? ? ? ? ? ? divent *a = 1; cors programm vad camb valor punt b andrò camb valor punt (sarann ugual ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3103"><answer_text>error più comun nell&#39; utilizz puntator è l&#39; &#34; aliasing &#34; ovver l&#39; uso più puntator un&#39; unic variabil , caus un&#39; assegn impropr . esemp : x,y numer inter b puntator inter -&#62; *a =x ; *b = y ; a=b ; avrem b punt stess variabil (y ) perd l&#39; indirizz x (se modif b , vien modific ) . x non sar punt nessun puntator men non dichiar puntator x . aliasing comport sprec memor quant usi 2 puntator arriv stess variabil . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3019"><question_text>perc quand pass funzion variabil rifer dobb più attenzion nell&#39; implement codic suddett funzion ?elenc almen vantagg svantagg passagg valor . </question_text><answer id="A3107"><answer_text>perc qualsias modif effettu variabil pass rifer modif valor variabil original (stess locazion memor ) modif variabil livell visibil (scop ) estern funzion . ***vantaggi*** - richied men memor passagg valor - passagg parametr rifer consent ritorn più risult chiamant ***svantaggio*** - modif accidental valor variabil pass rifer modif variabil dell&#39; inter programm conseguent risult errat . </answer_text><num_votes>4</num_votes></answer><answer id="A3061"><answer_text>passagg parametr avvien valore,l funzion ricev cop parametr salv locazion memor (divers dov risied parametr &#34; original &#34; ) vantagg metod è valor variabil programm chiamant non vien modific . passagg parametr riferimento,l funzion ricev l&#39; indirizz parametr . metod richied attenzion quant permett modif variabil livell visibil estern funzion . vantagg passagg valor è minor utilizz memor . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2997"><question_text>dichiar puntator &#34; tipod *puntator &#34; , tipod ,* puntator ? </question_text><answer id="A3122"><answer_text>sint propost : - l&#39; oper unar * indic si sta dichiar puntator , ovver variabil memorizz indirizz memor corrispondent un&#39; altra variabil ; - puntator indic l&#39; identif variabil tip puntator dichiar ; - tipod indic tipolog dat assoc variabil punt puntator , ovver corrispondent all&#39; indirizz memor puntator fa rifer . </answer_text><num_votes>3</num_votes></answer><answer id="A2991"><answer_text>tipod è tip (int,float,c ecc. . ) puntator punt , variabil memor punt puntator dev esser tipod puntator . * è l&#39; oper unar dereferenz , esso permett puntator right valu l&#39; indirizz variabil punt , dereferenz quell cell corrispond quell&#39; indirizz (ed assegn cert valor esemp ) . puntator è variabil tipod corrispond , right valu , indirizz variabil tip . </answer_text><num_votes>0</num_votes></answer><answer id="A3029"><answer_text>puntator è variabil right valu è tip dat contien un&#39; indirizz part memor . tipod indic puntator punt cell memor valor è tipod (es int ) . puntator è assoc puntator , vien decis programm pot utilizz all&#39; intern programm . caratt * è simbol dereferenz puntator , indic vogl &#34; legg &#34; valor right valu puntator . cas dichiar scriv puntator è variabil punt variabil tipod </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3100"><question_text>consist typedef ? qual e&#39; signific ? quand e&#39; utilizz ? </question_text><answer id="A3012"><answer_text>typedef permett cre tip attravers tip costrutt , particol può esser built-in(es : int ,char. . ) struttur (array e/o struct ) . particolar util struct , enum matric , quant poss esser utilizz cre tip array più compless (es : matric tridimensional ) semplific l&#39; uso costrutt (es : l&#39; enum permett non elenc ogni volt element ogni nuov variabil ) . </answer_text><num_votes>2</num_votes></answer><answer id="A3011"><answer_text>&#34; typedef &#34; permett assegn tip dat già esistent è principal utilizz &#34; struct &#34; , cre tip dat variabil eterogene (es . typedef struct{ ... } nuovonom ; ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3114"><answer_text>typedef è parol chiav linguagg programm c . scop typedef è diassegnaredeinom altern tip dat esistent , solit quell dichiar standard è tropp ingombr , magar confusional , oppur rend codic riutilizz più facil un&#39; implement un&#39; altra . </answer_text><num_votes>0</num_votes></answer><answer id="A3043"><answer_text>typedef è parol chiav linguagg programm c c++ . scop typedef è assegn nom altern tip dat esistent , solit quell dichiar standard è tropp ingombr , magar confusional , oppur rend codic riutilizz più facil un&#39; implement un&#39; altra . </answer_text><num_votes>0</num_votes></answer><answer id="A3000"><answer_text>typedef , letter : &#34; type definition &#34; , è com usat quand si bisogn defin tip dat non present nativ linguagg c . può esser usat rinomin tip dat nom più facil quell nat (ad esemp , rinomin tip &#34; int &#34; &#34; numeriinter &#34; ) , ver util sta nell&#39; usarl insiem nomin tip array matric (non dov poi riscriv parentes quadr ogni nuov variabil ) , enumer , struttur compless all&#39; intern più tip . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3103"><question_text>qual vantagg qual svantagg comport l&#39; utilizz puntator scorr i caratter string ? </question_text><answer id="A3059"><answer_text>scorr string si utilizz sempr puntator , quest array char (char a[100 ] , è puntator ) puntator string (char* s , s è puntator ) , ogni cas scorr string util i puntator poic i var caratter alfanumer si trov distanz defin l&#39; dall&#39; (dimension char=1byt ) , ovver 8 bit distanz , bast conosc puntator individu tutt i caratter success string . </answer_text><num_votes>1</num_votes></answer><answer id="A3015"><answer_text>utilizz puntator scorr i caratter string si agir conten cell dell&#39; array caratter punt quel moment ; è necessar cop puntator element string altriment scorr , puntator punt are memor success non si potrebb più acced tal are memor . </answer_text><num_votes>0</num_votes></answer><answer id="A3080"><answer_text>quand inizializz esemp struttur attravers l inizializz classic programm attu modif cop struttur dat programm main , è inizializz attravers puntator programm effettu modif all&#39; intern struttur stess . </answer_text><num_votes>0</num_votes></answer><answer id="A2998"><answer_text>vantagg principal consist non dover cop conten string prim scrorr perc puntator punt all&#39; indirizz dat (in cas i caratter string ) non valor dat . quest propriet è apprezz piccol programm , divent dover si vogl scorr i caratter string grand . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3111"><question_text>scrittur *p=x ; x=*p ; x*=p ; equivalent ? cas risult different , descriv caratterist . </question_text><answer id="A3099"><answer_text>scrittur non equivalent . scrittur *p=x indic puntator (*p ) punt all&#39; indirizz ugual x , mentr x=*p assoc x l&#39; indirizz punt *p . terz scrittur risult esser moltipl : x*=p equival x=x*p . es . *p=x ; x=23 -&#62; l&#39; indirizz punt è 23 ; x=*p ; *p=4 -&#62; l&#39; indirizz punt risult esser 4 ; x=3 ; x*=4 -&#62; x=3*4=12 ; </answer_text><num_votes>0</num_votes></answer><answer id="A3054"><answer_text>scrittur question non equivalent , infatt svolg ciascun un&#39; oper different : 1 ) * p=x assegn cell memor punt p valor variabil x 2 ) x =*p assegn variabil x valor conten cell memor punt p 3 ) x *=p equival scriv x=x*p assegn variabil x valor prodott sè stess valor variabil p. </answer_text><num_votes>2</num_votes></answer><answer id="A3064"><answer_text>scrittur signific complet different . signific prim scrittur (*p=x ) è p punt x . second è x è ugual valor punt p. mentr terz scrittur equival moltipl gen x=x*p . </answer_text><num_votes>0</num_votes></answer><answer id="A3432"><answer_text>scrittur *p=x indic puntator p punt cell memor contenent variabil x . scrittur x=*p , , indic variabil x si assegb conten cell memor punt p. terz scrittur indic variabil x è par sè stess moltiplic p. </answer_text><num_votes>0</num_votes></answer><answer id="A2994"><answer_text>3 istruzion non equivalent port 3 risult different . &#34; * p=x &#34; : &#39;p &#39; punt valor conten &#39;x&#39; perc cell memor indirizz &#39;x &#39; . esemp : x=10 ; *p=x ; =&#62; &#39;p &#39; è conten &#34; 10 &#34; &#39;p &#39; punt cell indirizz 10 . &#34; x=*p &#34; : &#39;x&#39; vien assegn valor conten cell punt &#39;p &#39; . esemp : *p=20 ; x=*p ; =&#62; &#39;x&#39; vien assegn &#34; 20 &#34; . &#34; x*=p &#34; : l&#39; istruzion equival &#34; x=x*p &#34; perc vien esegu moltipl valor &#39;x&#39; valor &#39;p &#39; . esemp : x=20 ; p=10 ; =&#62; &#39;x&#39; vien assegn 200. </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3126"><question_text>succed memor quand si utilizz puntator ? </question_text><answer id="A3119"><answer_text>vien defin variabil tip char** p(la dopp de-referenz (** ) indic p è variabil puntator ) , stiam dic compil p punt cell memor conten sar volt indirizz (in cas p sta punt all&#39; indirizz caratt ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3067"><answer_text>dichiar puntator esmpi int si cre variabil può conten l&#39; indirizz cell memor può conten l&#39; indirizz cell memor può conten variabil tip int. dereferenz sol volt si ottien indirizz , mentr dereferenz si ottien int. </answer_text><num_votes>1</num_votes></answer><answer id="A3049"><answer_text>quand si dichiar singol puntator , si riserv part memor tip dat vien richiam puntator . semplic , puntator , puntator assegn indirizz puntator inizial . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3055"><question_text>qual usi (ne puntator non ) può caratt &#39;* &#39; ? </question_text><answer id="A3032"><answer_text>caratt &#39;* &#39; funzion oper dereferenz . esemp : *a=16 ; quest rig codic dic cell indirizz è conten &#39;a &#39; andiam mett valor 16 . </answer_text><num_votes>1</num_votes></answer><answer id="A2980"><answer_text>caratt &#39;* &#39; può 3 usi : 1 ) simbol moltipl : moltipl right valu variabil ; 2 ) oper dereferenz (* ) : acced conten cell memor avent com indirizz right valu variabil a; 3 ) dichiar variabil puntator (int *a ) : dichiar variabil cell memor verr alloc indirizz un&#39; altra cell memor . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ3004"><question_text>consist l&#39; oper dereferenz ? </question_text><answer id="A3055"><answer_text>dereferenz (dereferencing ) è l&#39; oper permett poter modific mod dinam , funzion , variabil . l&#39; oper consist nell&#39; assegn valor variabil rifer , ovver utilizz puntator individu quell variabil . scrittur comun cas dat struttur è p-&#62;dat = valor . </answer_text><num_votes>1</num_votes></answer><answer id="A3062"><answer_text>l&#39; oper dereferenz è costitu oper unitar ?* ? preced variabil tip inter tip caratt . quest&#39; ultim , possibil inser test lunghezz divers qual dip vettor bisogn ricord test c&#39; è null indic termin string . </answer_text><num_votes>0</num_votes></answer><answer id="A3123"><answer_text>è l&#39; oper fondamental applic puntator consist produrr com risult l&#39; oggett vien punt puntator . simbol rappresent quest oper è &#34; * &#34; </answer_text><num_votes>3</num_votes></answer></question><question id="QQ3040"><question_text>com si effettu un&#39; oper assegn variabil tip puntator ? </question_text><answer id="A3104"><answer_text>variabil tip puntator si poss tip assegn , si può mod puntator punt cert valor (es . int *p ; *p=5 ; ) . oppur si può assegn l&#39; indirizz memor un&#39; altra variabil (es . int *p , x ; p=&#38;x ; ) puntator (es . int *p , *q; p=q; ) . </answer_text><num_votes>3</num_votes></answer><answer id="A2987"><answer_text>l&#39; oper assegn variabil tip puntator si fa utilizz l&#39; oper deferenz ( &#34; * &#34; ) prim variabil , indic valor assegnam variabil deferenz com si può ved seguent esemp : *x=5 </answer_text><num_votes>0</num_votes></answer><answer id="A3433"><answer_text>and then this toooooooooo threeeeeeeeeeeeeee </answer_text><num_votes>0</num_votes></answer><answer id="A2986"><answer_text>l&#39; oper assegn variabil tip puntator si fa utilizz l&#39; oper deferenz ( &#34; * &#34; ) prim variabil , indic valor assegnam variabil deferenz com si può ved seguent esemp : *x=5 </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3067"><question_text>funzion può restitu array com risult ? , perc ? si , com ? </question_text><answer id="A3081"><answer_text>restitu array part funzion può esser dat 4 metod : -returnstring ritorn un&#39; istanz class string librer standard ; -returnarray ritorn puntator array alloc dinam heap(un volt l&#39; array non serv più esser elimin evit sprec memor ) ; -setarray prend l&#39; indirizz array qual andrà scriv i dat (array già predispost evit sprec memor ) ; -returnstruct ritorn conten struttur defin (richied trasfer tutt i caratter ritorn funzion ) </answer_text><num_votes>0</num_votes></answer><answer id="A2981"><answer_text>non si può restitu array sè com tip ritorn funzion , si può pass com parametr (per rend l&#39; array modific ) com variabil ritorn puntator array consent poi nell&#39; ambient dov è avven l&#39; istanz funzion oggett gest . </answer_text><num_votes>1</num_votes></answer><answer id="A2969"><answer_text>funzion non può restitu array quant l&#39; invoc provoc l&#39; alloc nuov memor dov sarann cop i parametr pass qual andrà agir .pass array funzion verr cre cop sar poi modific . problem sta ritorn l&#39; array com risult funzion : essa ritorn puntator zon memor dell&#39; array (cop ) non l&#39; array modific si trov nell&#39; are memor sar dealloc termin funzion perd conten . ciò si pass l&#39; array rifer (puntator ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3036"><answer_text>c/c++ funzion non può restitu dirett array poss è far restitu funzion puntator element dell&#39; array quand vogl dobb ricord cos fondamental : -defin funzion com puntator tip dat form l&#39; array es : int* funz( .. ) { .. } -se funzion si ritorn puntator defin all&#39; intern funzion quest non funzion perc memor qual puntator è salv vien dealloc funzion (va usat funzion new usat memor heap ) </answer_text><num_votes>2</num_votes></answer><answer id="A3076"><answer_text>funzion potr restitu soltant puntator array funzion cre nell&#39; heap qual controll alloc dealloc . infatt non è possibil l&#39; assegn array , l&#39; are memor stack vien dealloc termin funzion stess . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3044"><question_text>com mai poss dir dicitur p[3 ] è equivalent scriv * (p+3 ) ? </question_text><answer id="A2968"><answer_text>quest scrittur è possibil poic c , relazion puntator vettor è cosi&#39; strett consent traduzion simultane . ovver , p[3 ] defin vettor p ampiezz 3 , mentr * (p+3 ) punt 3° element valor punt p. </answer_text><num_votes>0</num_votes></answer><answer id="A3075"><answer_text>dicitur p[3 ] compil all&#39; indirizz memor indic p , più i byte necessar memorizz tip dat è compost l&#39; array moltiplic [3 ] (la posizion richiest ) prend valor (la deferenz è implic dicitur ) . cas veng usat oper precedent &#34; ( ) &#34; indic posizion dat dell&#39; array richiest l&#39; oper &#34; * &#34; vien effettu deferenz . dicitur divers , effettu stess oper equivalent . </answer_text><num_votes>1</num_votes></answer><answer id="A3013"><answer_text>perc p è array &#34; punt &#34; element dell&#39; array ... second oper aument p posizion facc punt terz posizion </answer_text><num_votes>0</num_votes></answer><answer id="A2988"><answer_text>e&#39; possibil acced array mod different : scriv p[3 ] acced all&#39; element dell&#39; array posizion 3 (cio , cont 0! ) ; scriv * (p+3 ) esegu 2 oper : 1 ) part posizion punt p (cio posizion 0 dell&#39; array ) , spost avant 3 indirizz , fac cos rifer cell dell&#39; array posizion 3 (la quart , com ) . 2 ) l ?oper dereferenz ? * ? andrem legg valor cell memor abbiam appen individu punt 1 . </answer_text><num_votes>2</num_votes></answer><answer id="A3014"><answer_text>perc p è array &#34; punt &#34; element dell&#39; array ... second oper aument p posizion facc punt terz posizion </answer_text><num_votes>0</num_votes></answer><answer id="A2999"><answer_text>*p indic cell memor indirizz è conten p. p[3 ] : fa rifer 3 cell dell&#39; array . *p : punt &#34; p &#34; +3 , terz cell dell&#39; array . different sostanzial è risult più semplice-compatt più pratic utilizz . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2992"><question_text>signif dereferenz puntator ? </question_text><answer id="A2985"><answer_text>deferenz puntator signif acced conten variabil punt . l&#39; oper dereferenz è * (lo simbol usat l&#39; inizializz puntator ) esemp : int a; int *p ; //inizializz puntator p=&#38;a ; // assegn p l&#39; indirizz *p=10 ; // modif conten attravers dereferenz p </answer_text><num_votes>1</num_votes></answer><answer id="A2979"><answer_text>puntator indic l&#39; indirizz variabil fa rifer , dichiar : typedef tipod *tipopunt -tipod defin qual tip variabil può esser referenz -*tipopunt è l&#39; indirizz un&#39; altra variabil , tip è tipod l&#39; access variabil tip puntator avvien attravers l&#39; oper dereferenziazioneindic simbol &#34; * &#34; post prim dell&#39; identif puntator . </answer_text><num_votes>0</num_votes></answer><answer id="A3095"><answer_text>dereferenz puntator signif andar legg valor conten cell memor si trov all&#39; indirizz conten puntatore.per farl si utilizz l&#39; oper dereferenz &#34; * &#34; . </answer_text><num_votes>1</num_votes></answer><answer id="A3118"><answer_text>l&#39; oper de-referenz (o risolu rifer ) , è costitu oper unar ( cio oper ) applic puntator precedent inizializz permett otten com risult l&#39; oggett esso punt . sostanz dereferenz si intend l&#39; access cell memor punt puntator . dereferenz puntator non inizializz è error . esemp : int x=5 ; int *ptr=&#38;x ; (inizializz puntator ) int z=*ptr; (dereferenz puntator ) </answer_text><num_votes>1</num_votes></answer><answer id="A3007"><answer_text>termin dereferenz si vuol indic conten cell memor punt puntator . </answer_text><num_votes>0</num_votes></answer><answer id="A3069"><answer_text>esemp : ... int *p ; *p=7 ; ... p = puntator * = oper deferenz . brev referenz puntator signif denotare/indic conten cell memor avent com indirizz memor &#39;p &#39; . svel conten cell punt puntator &#39;p&#39; </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3043"><question_text>serv l&#39; oper sizeof ( ) tip dat restitu ? </question_text><answer id="A3040"><answer_text>l ?oper sizeof produc numer byte occup ciascun element array array compless . restitu integer </answer_text><num_votes>0</num_votes></answer><answer id="A3017"><answer_text>l&#39; oper sizeof ( ) restitu numer tip int , dat restitu e&#39; numer byte occup memor tip variabil inser com argoment funzion sizeof ( ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3016"><answer_text>l&#39; oper sizeof ( ) restitu numer tip int , dat restitu e&#39; numer byte occup memor tip variabil inser com argoment funzion sizeof ( ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3018"><question_text>perc quand si dichiar puntator bisogn indic tip dat punt ? </question_text><answer id="A2992"><answer_text>rispond esemp : tip doubl si rappresent 8 byte ; defin p com doubl *p , (p puntator doubl ) . l&#39; aritmet puntator , (p+3 ) è l&#39; indirizz element sequenz punt p. , dat ogni real occup byte , valor numer p+3 è valor numer p più 3*8 . valor p camb , , camb tip dat punt (per rappresent int , float , char doubl non occorr stess quantit memor , var tip dat tip dat ) . l&#39; import indic tip dat punt ! </answer_text><num_votes>3</num_votes></answer><answer id="A3106"><answer_text>perc &#39; cas debb svolg oper assegn incomb nell&#39; error incompatibil &#39; tip div dat . percu avend inter (int ) puntator inter (int *p ) quand andro &#39; l&#39; assegn (p=&#38;a ) non incomber &#39; nell&#39; error incompatibil &#39; tip div dat . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3034"><question_text>serv pass l&#39; indirizz variabil anzic valor stess funzion ? </question_text><answer id="A3078"><answer_text>attravers l&#39; uso puntator è possibil pass l&#39; indirizz variabil anzic valor stess risparm memor ; infatt pass rifer variabil (ovver l&#39; indirizz ) funzion acced manier più rapid memor può modific i valor interess . è import chiam funzion attravers indirizz non pass valor variabil poic utilizz quest?ultim metod può avven scamb conten are casual memor , provoc dann possibil ?inter sistem non programm . </answer_text><num_votes>0</num_votes></answer><answer id="A3072"><answer_text>pass l&#39; indirizz variabil anzic valor stess può esser util quant forn maggior flessibil velocizz oper variabil grand memor . esemp suppon variabil occup spaz , cop più punt programm conseguent sprec memor è più comod utilizz puntator punt all&#39; indirizz memor variabil . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ3049"><question_text>linguagg c/c++ simbol [* ] rappresent cos distint . illustr utilizz forn alcun esemp codic ogni funzion svolt . </question_text><answer id="A3058"><answer_text>linguagg c/c++ simbol unar [* ] puo&#39; esser utilizz istruzion distint : -l&#39; oper moltipl numer e/o variabil (a = 2*3 ; oppur = b*4 ) ; -l&#39; oper dereferenz , cioe&#39; creazion puntator , indic indirizz variabil (puo&#39; esser esso dichiar com variabil attravers typedef ) ( tipod *tipopunt ; ) ; -la scrittur codic programm com , esemp , inser comment piu&#39; righ codic attravers &#34; /* &#34; comment &#34; * / &#34; . </answer_text><num_votes>2</num_votes></answer><answer id="A3003"><answer_text>l&#39; aster linguagg c/c++ può esser simbol moltipl (1 ) , può rappresent puntator (2a ) puntator (2b ) oppur abbin &#34; / &#34; riduc part codic test semplic comment (3 ) . 1 . z = x*y-a 2a . int* 2b . char** string 3 . /* int a=7 ; printf ( &#34; % d &#34; , ) ; */ </answer_text><num_votes>1</num_votes></answer><answer id="A3033"><answer_text>linguagg c/c++ simbol [* ] rappresent : - prim l&#39; oper unar de-deferenz puntator usat dichiar puntator . puntator è variabil contien l&#39; indirizz memor un&#39; altra variabil . esp : char* ; - può esser usat com oper aritmet moltipl . esp : z=x*y ; - può esser usat insiem / comment più righ programm . esp : /*calcol lunghezz stringa*/ </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2999"><question_text>succed si diment più &#34; break &#34; costrutt &#34; switc &#34; ? </question_text><answer id="A3034"><answer_text>break è com permett uscir costrutt , infatt cas switc cas cas foss l&#39; entrat &#34; cas &#34; contenent seguent istruzion verrebb conclus tutt blocc compar ; inoltr è impost dir l&#39; istruzion break permett uscir costrutt div (ad esemp i cicl ) . non includ break più &#34; cas &#34; fa si compar continu i cas success ; non è dett ciò mal , per progett programm risult decis più intric . </answer_text><num_votes>1</num_votes></answer><answer id="A3071"><answer_text>diment più break costrutt switc , cas verific cas si diment break verr esegu l&#39; istruzion dov quel cas l&#39; istruzion cas success . esemp programm valut valor variabil inter (suppon int a=1 ) , cas blocc istruzion : switc ( ) { cas 0 : printf ( &#34; zer &#34; ) ; break ; cas 1 : printf ( &#34; &#34; ) ; cas 2 : printf ( &#34; &#34; ) ; break ; default : printf ( &#34; nessun precedent &#34; ) ; } programm esegu l&#39; istruzion cas 1 , l&#39; istruzion cas 2 . </answer_text><num_votes>3</num_votes></answer><answer id="A3018"><answer_text>l ?istruzion break permett uscir blocc switc , tal istruzion vien dimentic , veng esegu tutt istruzion segu cas desider (anc quell cas success ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3042"><question_text>oper deferenz necessar descriv l&#39; indirizz matric m[i ] [ j ] ? i array multidimensional poss esser descritt com puntator n-dimension ? </question_text><answer id="A3110"><answer_text>array multidimensional può esser descritt com puntator n-dimension quant ciascun element dell&#39; array non è array volt ; mod risult semplic poter rappresent matric com m[i ] [ j ] , è matric i righ j colonn . </answer_text><num_votes>1</num_votes></answer><answer id="A2974"><answer_text>descriv l&#39; indirizz matric è oppurtun seguent oper deferenz : * ( * (m+nc*i ) + j ) , dov m è matric nc numer colonn . </answer_text><num_votes>1</num_votes></answer><answer id="A2973"><answer_text>descriv l&#39; indirizz matric è oppurtun seguent oper deferenz : * ( * (m+nc*i ) + j ) , dov m è matric nc numer colonn . si , array multidimensional poss esser descritt com puntator n-dimension . utilizz formul cit posss cre n-dimension . </answer_text><num_votes>1</num_votes></answer><answer id="A2972"><answer_text>descriv l&#39; indirizz matric è oppurtun seguent oper deferenz : * ( * (m+nc*i ) + j ) , dov m è matric nc numer colonn . si , array multidimensional poss esser descritt com puntator n-dimension . utilizz formul cit posss cre n-dimension . </answer_text><num_votes>0</num_votes></answer><answer id="A3116"><answer_text>array rappresent intern compil com puntator prim locazion memor alloc . e&#39; possibil acced all&#39; array sint puntator : a[i ] &#38;#8594 ; * (a+ ) ma[ ] [ j ] &#38;#8594 ; ** (ma+i**j+j ) </answer_text><num_votes>1</num_votes></answer><answer id="A2975"><answer_text>descriv l&#39; indirizz matric è oppurtun seguent oper deferenz : * ( * (m+nc*i ) + j ) , dov m è matric nc numer colonn . si , array multidimensional poss esser descritt com puntator n-dimension . utilizz formul cit posss cre n-dimension . </answer_text><num_votes>1</num_votes></answer><answer id="A2983"><answer_text>descriv l&#39; indirizz matric è oppurtun seguent oper deferenz : * ( * (m+nc*i ) + j ) , dov m è matric nc numer colonn . si , array multidimensional poss esser descritt com puntator n-dimension . utilizz formul cit posss cre n-dimension . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3082"><question_text>si potrebb dir variabil tip array è puntator ? e&#39; possibil acced cell memor array matric utilizz oper dereferenz parentes quadr ? com ? </question_text><answer id="A3009"><answer_text>si punt prim cell memor . si è possibil acced utilizz oper dereferenz : * . </answer_text><num_votes>0</num_votes></answer><answer id="A3008"><answer_text>si , l&#39; array può esser defin com puntator . dichiar comport infatt l&#39; alloc memor variabil puntator rappresent dell&#39; array l&#39; are punt . puntator è inizializz l&#39; indirizz element dell&#39; array . ogni element dell&#39; array è access tram oper dereferenz ; esemp espression a[i ] * (a+ ) produc risult . </answer_text><num_votes>1</num_votes></answer><answer id="A2977"><answer_text>si,l variabil tip array è puntator , dell&#39; array infatt è puntator indirizz element dell&#39; array . sap è poi possibil acced valor conten singol cell dayt struttur usand oper defernz operzion puntator ; è possibil sap cell dat tip sempr tutt consecut . (esemp ( [i ] coincid * (a+ ) ia[ ] ) n.b. matric divent pò più compless perc puntator è si necess muov entramb direzion (rig colonn ) . </answer_text><num_votes>5</num_votes></answer></question><question id="QQ3091"><question_text>può esser effettu un&#39; assegn puntator variabil ? </question_text><answer id="A3088"><answer_text>puntator è variabil contien l&#39; indirizz memor un&#39; altra variabil . assegn puntator l&#39; indirizz variabil è necessar dichiar (per specific tip dat dovr punt ) eventual assegn cell memor . attravers l&#39; oper deferenz &#34; * &#34; è possibil acced cell punt assegn valor (ad esemp *p = x , mot si assegn valor x cell puntator fa rifer . ) </answer_text><num_votes>1</num_votes></answer><answer id="A3022"><answer_text>&#34; assegn puntator variabil &#34; si intend puntator può assum valor variabil si : c=3 *a=&#38;c era giust cas variabil assum valor punt puntator </answer_text><num_votes>0</num_votes></answer><answer id="A3023"><answer_text>assegn si intend puntator può assum valor punt puntator si : c=3 *a=&#38;c </answer_text><num_votes>0</num_votes></answer><answer id="A2997"><answer_text>sì , bast per ricord l&#39; oper &#34; * &#34; priorit oper matemat , esemp x=2 * *p equival dir x= 2* (*p ) </answer_text><num_votes>0</num_votes></answer><answer id="A2995"><answer_text>l&#39; assegn puntator variabil può esser sicur fatt spess è convenient 2 mot : question risparm memor fatt attravers l&#39; assegn puntator si modific dirett cell originar . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3073"><question_text>qual cas è util dichiar variabil contator &#34; i &#34; dirett all&#39; intern dell&#39; intest costrutt &#34; for &#34; ? esemp : for(int i=0 ; i&#60;10 ; i++ ) { //programm } </question_text><answer id="A2990"><answer_text>e&#39; util dichiar contator &#34; i &#34; dirett all&#39; intern cicl for quand si gran numer righ codic non si vuol ritorn cim programm dichiar tal variabil int. funzion quant mod si cre variabil local for vien dealloc appen cicl termin , si usa quand contator non serv success , util success cicl . </answer_text><num_votes>4</num_votes></answer><answer id="A3113"><answer_text>solit , comod , si dichiar variabil &#34; i &#34; all&#39; intern dell&#39; intest cas quell variabil vien utilizz all&#39; intern cicl non fuor . sè non camb null si dichiar prim (int i=0 ) nell&#39; intest si scriv i=0 . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3119"><question_text>tip assegn è fattibil puntator ? </question_text><answer id="A3001"><answer_text>linguagg c , graz all&#39; aritmet puntator , permett svolg un&#39; ampi gamm oper (tra assegn ) puntator costruzion più efficient dinam programm . infatt assegn semplic valor , variabil puntator [es : int *p ] poss memorizz l&#39; indirizz memor precis variabil [p=&#38;x ] zon memor alloc heap [p=new int] . inoltr l&#39; uso puntator risult indispens nell&#39; inizializz array (all&#39; intern funzion ) nell&#39; access camp struttur (mediant dot notation ) </answer_text><num_votes>1</num_votes></answer><answer id="A3105"><answer_text>puntator è possibil effettu div tip assegn , particol : - assegn ?indirizz variabil tram l&#39; oper unar &#38; ; - assegn valor puntator ; - assegn valor special null ; - assegn indirizz memor segu oper alloc esplic memor . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3063"><question_text>sens seguent codice/c vantagg dà ? typedef int *a ; dat rig vogl dichiar variabil b puntator inter scriv (chiar utilizz codic , non int *b ) ? poss omett * scriv b; ? poi vogl visualizz conten cell punt b com facc ? </question_text><answer id="A3082"><answer_text>seguent codic cre tip puntator inter . non si può scriv b; non si può omett simbol dereferenz . poss visualizz conten cell memor tram l&#39; utilizz dell&#39; oper sizeof . </answer_text><num_votes>0</num_votes></answer><answer id="A3097"><answer_text>codic sens , vantag è non scriv * ogni volt , per si tip dat non si cap dichiar puntator men . sarebb defin p_a . defin tip dat sar puntator intern si può omett * sar sufficent scriv b; equivalent scriv int* b; visualizz conten cell punt b è sufficent porr * davant b tratt com &#34; punt b &#34; . cas punt b (*b ) è tip inter printf ( ) bast usar %i stamp . printf ( &#34; punt b : %i &#34; , *b ) ; </answer_text><num_votes>4</num_votes></answer><answer id="A2982"><answer_text>eh non ricord ben </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3106"><question_text>cos&#39; è &#34; dot notation &#34; ? com si utilizz ? </question_text><answer id="A3120"><answer_text>&#34; dot notation &#34; è schem sintatt tipic linguagg c vien utilizz attravers l&#39; uso punt acced conten memor denot cert oggett . </answer_text><num_votes>2</num_votes></answer><answer id="A3045"><answer_text>dot notation si usa c acced singol camp struttur : si scriv l&#39; identif struttur segu punt dall&#39; identif camp desider . </answer_text><num_votes>1</num_votes></answer><answer id="A3044"><answer_text>dot notation si usa c acced singol camp struttur : si scriv l&#39; identif struttur segu punt dall&#39; identif camp desider . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3105"><question_text>serv l&#39; oper &#34; freccett &#34; ( -&#62; ) nell&#39; ambit puntator ? </question_text><answer id="A3019"><answer_text>l oper &#34; -&#62; &#34; serv acced camp struct tram puntator . si proced dereferenz puntator l oper * segu &#34; . &#34; es (* p ) .nom . c/c++ esist form compatt descriv quest oper è appunt l&#39; oper &#34; -&#62; &#34; ( freccett ) . cio scrittur (* p ) .nom p-&#62;nom equivalent . </answer_text><num_votes>1</num_votes></answer><answer id="A2970"><answer_text>siccom dot notation ( . ) precedent (* ) , necessar puntator , si usan dat struttur si avrebb scrittur estrem pesant complic sarebb esemp : (v* ) .prov , , com si not , richied l&#39; utilizz parentes sistem precedent . compil c/c++ aiut inser unic oper sintetizz entramb oper ( . ) (* ) . oper è appunt freccett ( -&#62; ) , qual non richied l&#39; utilizz parentes particolar attenzion . </answer_text><num_votes>0</num_votes></answer><answer id="A3010"><answer_text>l&#39; oper freccett è introdott semplific scrittur all&#39; intern funzion struttur pass rifer es : typedef struct{ int a; } struttur ; //senz oper freccett : void funzion (struttur *s ) { (* s ) .a=3 ; } //con oper freccett : void funzion (struttur *s ) { s-&#62;a=3 ; } funzion equivalent l&#39; oper freccett codic risult più leggibil </answer_text><num_votes>0</num_votes></answer><answer id="A2967"><answer_text>e&#39; util cas dovessim acced tram puntator element struct . infatt suppon dover acced ipotet camp &#34; * person .altezz &#34; , seguent scrittur compil non sarebb grad cap dereferenz . dett ciò esist tip notazion : &#34; ( *person ) .altezz &#34; oppur quell più utilizz &#34; persona-&#62;altezz &#34; .dunqu compil interpret &#34; person &#34; com puntator . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3051"><question_text>c si poss esegu oper somm puntator ? sì , mod ? </question_text><answer id="A3090"><answer_text>puntator non può esser somm puntator , esso può esser somm inter . risult somm è l&#39; indirizz dat puntator increment risult moltipl l&#39; inter specific dimension tip bas puntator espress byte . esemp , p è puntator tip inter int (int *p ) valor 1000 (p=1000 ) , essend byte dimension int , p+1 val 1002 , p+2 val 1004 , general p+n val 1000+n*2 . </answer_text><num_votes>0</num_votes></answer><answer id="A3041"><answer_text>/*le oper somm c possibil ; è necessar somm puntator memorizz varibial , perc cas contrar verrebber somm indirizz punt i puntator . esemp com si pot somm pumntator : */ #includ &#60;stdi .h&#62; #includ &#60;stdlib.h&#62; int main(int argc , const char * argv[ ] ) { int x=5 ; int* p_x = &#38; x ; int y=6 ; int* p_y = &#38; y ; int = *p_x+*p_y ; printf ( &#34; % d \n &#34;, ) ; return 0 ; } //version mac </answer_text><num_votes>0</num_votes></answer><answer id="A2964"><answer_text>si , siccom variabil puntator conteng indirizz non è numer , poss somm inter , vien usat sistem array , intatt vogl otten l&#39; element x : array [x ] , sistem somm all&#39; indirizz array x , cos otteng l&#39; indirizz posizion memor ricerc </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3046"><question_text>costrutt &#34; switc &#34; è divers costrutt &#34; if &#34; ? </question_text><answer id="A3111"><answer_text>maggior part cas switc cas - default fa if - else if - else patt si abbi oper uguagl (== ) . quest cas camb sint , (relat ) poch line codic cas l&#39; , quell switc cas risult più pul più sintet . </answer_text><num_votes>0</num_votes></answer><answer id="A3025"><answer_text>l&#39; if verif condizion pass com parametr è &#34; ver &#34; , tal cas effettu un&#39; azion ; cas contrar ( &#34; else &#34; ) effettu un&#39; altra (opzional ) . e&#39; possibil avval , inoltr , elseif, implement blocc if all&#39; intern precedent , è possibil costru if annid . costrutt switc consent anch&#39; esso valut un&#39; espression valor pass com parametr intraprend , bas valor tal espression parametr , azion different ; different dell&#39; if, comunqu , è più &#34; ordin &#34; . </answer_text><num_votes>0</num_votes></answer><answer id="A3028"><answer_text>costrutt &#34; switc &#34; different &#34; if &#34; , può valut sol variabil dipend tutt scelt fatt compil . inoltr ogni singol valor variabil può controll singol scelt , eccezion fatt com default controll tutt variabil non stat specific precedent . già conosc variabil gioc costrutt &#34; switc &#34; potrebb esser prefer quant garant controll singol variabil . tutt cas risult miglior costrutt &#34; if &#34; dat controll più variabil . </answer_text><num_votes>1</num_votes></answer><answer id="A2978"><answer_text>costrutt switc permett confront variabil tip inter (o caratt ) più inter (o caratter ) , consent confront più cas ; different costrutt if consent confront variabil qualunqu tip , tuttav cas confront . </answer_text><num_votes>0</num_votes></answer><answer id="A2976"><answer_text>costrutt &#34; switc &#34; è possibil confront variabil tip inter (o caratter ) inter (o caratter ) , contempl più cas ; different costrutt &#34; if &#34; dov è possibil confront qualunqu tip dat , tuttav contempl cas . </answer_text><num_votes>0</num_votes></answer><answer id="A3004"><answer_text>different if switc permett valut più condizion divers cicl . condizion switc poss per esser uguagl , mentr l&#39; if si poss disuguagl , maggior minor . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3124"><question_text>dat seguent dichiar : 1 ) char* stringa1= &#34; quest è string &#34; ; 2 ) char stringa2[100 ] ; 3 ) char stringa3 [ ]= &#34; quest è string &#34; ; 4 ) char* stringa4= new char[100 ] . qual principal different ? </question_text><answer id="A3092"><answer_text>è puntator element string , è array 100 caratter , mentr è array lunghezz verr defin compil . tutt struttur risied &#34; stack &#34; l&#39; è puntator array alloc dinam tram funzion new . puntator è stack mentr funzion risied nell&#39; &#34; heap &#34; </answer_text><num_votes>1</num_votes></answer><answer id="A3038"><answer_text>principal different sta gestion dichiar : prim veng gest mod static all&#39; intern stack , quart vien gest mod dinam nell&#39; heap . 1 3 equivalent , dichiar entramb array char dimension è ricav calcol fras inizializz aggiung caratt null . 2 si dichiar static array char 100 element , cas nell&#39; inizializz si dovr aggiung manual caratt null string evit problem gestion com string </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3047"><question_text>qual i vantagg cre funzion prend com input l&#39; indirizz dat si pass dat ? cas è predilig ? cas l&#39; altra ? </question_text><answer id="A3117"><answer_text>pass dat non si fa alloc quantit memor stess dimension quell partenz cop l&#39; inter conten . pass l&#39; indirizz è possibil si evit passagg si lavor dirett variabil &#34; original &#34; salvaguard conten . metod richied men memor può esser pericol alcun cas quant si agisc dirett variabil original . </answer_text><num_votes>0</num_votes></answer><answer id="A3121"><answer_text>cre funzion è possibil pass input quest puntator , mod allegger programm diminu quantit memor occup , poic puntator non contien effett dat , indirizz (più legger ) . alcun cas tuttav l&#39; utilizz puntator risc complic funzion rend men fruibil all&#39; utent , cre possibil effett collateral dov utilizz non corrett passagg indirizz . </answer_text><num_votes>0</num_votes></answer><answer id="A3063"><answer_text>passagg valor consent acced cop variabil , conseguent valor effett tal variabil non può esser modific . passagg indirizz implic passagg puntator all&#39; are memor richiest , pertant poss modific valor fuor chiam funzion . si prefer usar metod quand parametr ingress sturct array perc vogl modific conten , poic tram passagg valor si modif cop variabil funzion . </answer_text><num_votes>0</num_votes></answer><answer id="A3030"><answer_text>variabil tip puntator è variabil punt all&#39; indirizz memor . i vantagg nell&#39; usar i puntator funzion prim tutt si alloc dinam memor consent alloc quantit memor arbitrar , secondar si pass variabil non più fac cop essa pass rifer . l&#39; uso puntator general , funzion , si risparm memor rend util quand abbiam funzion array grand cas list . </answer_text><num_votes>0</num_votes></answer><answer id="A3115"><answer_text>funzion prend com input l&#39; indirizz dat richied men memor si pass dat , , consent modific valor variabil livell visibil estern funzion metod . inoltr , passagg indirizz , è necessar pass funzion argoment tip puntator , variabil può restitu più valor . approcc vien predilett quand si dev pass struttur array oppur quand si vuol modific , dall&#39; intern quell funzion , variabil pass . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3072"><question_text>stamp vide seguent framment codic ? perc ? void main ( ) { int *p , *q; int a[100 ] ; p = &#38;a [35 ] ; q = &#38;a [20 ] ; printf ( &#34; % d \n &#34;,p-q ) ; system ( &#34; paus &#34; ) ; } </question_text><answer id="A3086"><answer_text>framment codic stamp vide numer &#34; 15 &#34; . array vien alloc memor ser spaz adiacent l&#39; all&#39; indirizz sequenzial . assegnam &#34; p &#34; l&#39; indirizz 35° element dell&#39; array &#34; q &#34; assegnam l&#39; indirizz 20° , tram sottrazion &#34;p -q &#34; otterrem esatt distanz posizion i element dell&#39; array . </answer_text><num_votes>1</num_votes></answer><answer id="A3068"><answer_text>framment codic stamp vide &#34; 15 &#34; . perc variabil puntator p q vien assegn l&#39; indirizz memor cell array , dist 15 posizion . infatt , quand si dichiar variabil &#34; &#34; , è array 100 inter , programm alloc stack spaz necessar ,cio 100 cell consecut omogene tip &#34; int &#34; ( 4 byte ciascun ) . variabil &#34; p &#34; &#34; q &#34; veng rispett assegn posizion 36 posizion 21 dell&#39; array , corrispond posizion memor dist 15 inter . </answer_text><num_votes>1</num_votes></answer><answer id="A2993"><answer_text>verr stamp numer 15 , perc è numer puntator tip int a[35 ] a[20 ] . 35-20 = 15 . andassim stamp indirizz p q vedr 60 byte different . dat puntator inter 4 byte , abbiam 60/4 = 15 . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3075"><question_text>spieg different cicl &#34; whil &#34; , &#34; do-whil &#34; &#34; for &#34; . qual cas prefer utilizz perc ? </question_text><answer id="A3074"><answer_text>tutt i cicl veng usat gestion iter codic . cicl whil si rend necessar ripet blocc istruzion finc condizion valut è ver . quand numer iter è not prior è prefer l&#39; uso cicl for , permett manier più sintet racchiud l&#39; assegn , l&#39; increment dell&#39; indic condizion valut . cicl do-whil vantagg esegu indipendent condizion valut ser istruzion almen volt : risult particolar util controll dell&#39; input . </answer_text><num_votes>1</num_votes></answer><answer id="A2971"><answer_text>different quest 3 costrutt non molt , dat intercamb (fann ) . i cicl &#34; whil &#34; &#34; for &#34; pratic ident , &#34; for &#34; offre per scrittur più ordin più facil lettur . cicl &#34; do-whil &#34; different è prefer gest l&#39; input semplic fatt istruzion conten corp cicl sarann sicur esegu almen volt . </answer_text><num_votes>0</num_votes></answer><answer id="A3101"><answer_text>cicl for è particolar util quand numer iter è not prior . cicl whil , , è utilizz cas numer iter non è not non si è sicur condizion ingress cicl soddisfatt almen volt . do-whil è analog whil , si usa si è sicur cicl veng esegu almen volt . </answer_text><num_votes>0</num_votes></answer><answer id="A3089"><answer_text>cicl whil , verific condizion , esegu l&#39; istruzion condizion è ver . cicl do-whil esegu l&#39; istruzion volt verific condizion , poi si comport esatt com cicl whil . cicl for esegu l&#39; istruzion tant quant impost condizion . cicl do-whil si utilizz cas si richied almen valor tastier , cicl for si utilizz quand si conosc prior numer sar esegu l&#39; istruzion . cicl whil si utilizz cas . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3071"><question_text>spieg different puntator puntator esemp pratic utilizz oper si poss applic . </question_text><answer id="A3053"><answer_text>i puntator fondamental variabil l ?unic different consist fatt essi non conteng valor numer puntator (oss indirizz ) locazion memor dov è memorizz cert valore,in parol puntator contien l&#39; indirizz memor un&#39; altra variabile.tal valor può esser intero,real caratt .invec puntator serv punt puntator punt indirizz . esemp puntator è int* x esemp puntator è int** x c consent esegu oper somm sottrazion </answer_text><num_votes>2</num_votes></answer><answer id="A3073"><answer_text>non esist different puntator dopp puntator , quant puntator puù punt qualsias variabil quest può esser puntator si cre puntator . i puntator singol veng utilizz l&#39; assegn indirett valor variabil ciò puntator singol è variabil contien l&#39; indirizz variabil semplic . i dopp puntator veng utilizz quand si usan funzion contenent string quant permett richiam var posizion string dover utilizz increment . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2996"><question_text>dichiar variabil inter int i=5 ; variabil puntator int *pi; dov l&#39; indirizz variabil i val 200030 , contien pi dop ciascun seguent istruzion ? ) &#38;pi = ++ ( &#38;pi ) ; b ) pi = &#38; ( i+1 ) ; </question_text><answer id="A3042"><answer_text>cas ) si dovrebb increment &#34; &#34; l&#39; indirizz cell memor puntator &#34; pi &#34; , sebben improb inutil realizz . cas b ) puntator &#34; pi &#34; verrebb assegn valor dell&#39; indirizz &#34; i &#34; increment sempr , cio 200034 dat int occup 4 bit ciascun . struttur comunqu andrebb scritt seguent mod : pi = &#38;i + 1; cio parentes perc altriment puntator cerc l&#39; indirizz dat chiam (i+1 ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3026"><answer_text>prov compil entramb istruzion , è possibil not : ) cas vien dat seguent error : &#34; lvalu required as increment operand &#34; . signif non è possibil increment l&#39; indirizz variabil (in cas puntator numer inter ) . b ) i n cas , è tip error : &#34; lvalu required as unary &#39;&#38; &#39; operand &#34; . non possibil assegn risult oper aritmet puntator , poic esso non è dot indirizz , sol valor numer . </answer_text><num_votes>3</num_votes></answer></question></lecture><lecture id="L29" title="Introduzione al C, Codifica Algoritmi in C" date="2013-10-04"><question id="QQ2499"><question_text>quant riguard l&#39; ordin array , qual è different bubbl sort merg sort ? qual è più efficient ? </question_text><answer id="A2406"><answer_text>bubbl sort funzion mod : ogni copp element adiacent list vien compar essi nell&#39; ordin sbagl veng invert . l&#39; algoritm scorr poi tutt list finc non veng più esegu scamb , situazion indic list è ordin . merg sort funzion mod : sequenz ordin lunghezz 0 1 , è già ordin . altriment sequenz vien divis met , ogni sottosequent vien ordin applic l&#39; algoritm infin sottosequent veng fus . bubbl sort è più efficient merg sort . </answer_text><num_votes>1</num_votes></answer><answer id="A2529"><answer_text>l&#39; algoritm bubbl sort scamb posizion element dell&#39; array adiacent non ordin quand non si trov più element ordin . merg sort l&#39; array (se contien più element ) vien suddivis sub-array lunghezz è met inizial , quest veng ordin mod ricors (cio semplific volt volt ) success si fond (merg ) unic array ordin . bubbl sort l&#39; efficient diminu all&#39; aument quantit dat ordin , contrar merg sort mantien l&#39; efficient costant . </answer_text><num_votes>3</num_votes></answer><answer id="A2362"><answer_text>bubbl sort preved confront copp element adiacent list , essi si trov nell&#39; ordin sbagl veng invert . l&#39; algoritm prosegu fas ordin tutt element esamin . merg sort lavor grupp element , ciascun qual vien ordin indipendent dall&#39; . sottosequent veng poi combin , individu volt volt minim ordin list conseguent . metod più efficient è merg sort , quant rend necessar minor numer oper . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2474"><question_text>spieg different usar : whil &#60;condizione&#62; &#60;istruzione&#62; usar : do &#60;istruzione&#62; whil &#60;condizione&#62; </question_text><answer id="A2380"><answer_text>quand utilizz cilc whil compil può non esegu mai istruzion conten cicl condizion non si verif mai (è sempr fals ) , mentr quand utilizz cicl do - whil compil esegu sempr , almen volt , istruzion conten cicl (finc condizion divent fals ) . esemp : condizion è sempr fals cicl whil istruzion non veng mai esegu , mentr cicl do - whil istruzion veng esegu volt . </answer_text><num_votes>1</num_votes></answer><answer id="A2422"><answer_text>cicl whil preved prim si pong condizion (espression boolean racchius parentes tond ) poi si specifichin istruzion parentes graffe.con cicl fintantoc &#39; condizion e&#39; ver vien esegu l&#39; istruzione.il costrutt do-whil fa segu parol chiav do l&#39; istruzion parentes graff , whil condizione.con costrutt l&#39; istruzion vien esegu almen volt ripet quand condizion divent fals .entramb i cicl port risult permett stesur piu&#39; ordin codic . </answer_text><num_votes>1</num_votes></answer><answer id="A2383"><answer_text>cas vien immediat valut condizion , quest è fals istruzion conten all&#39; intern cicl whil non veng esegu . cas istruzion veng esegu almen volt poi vien valut condizion . entramb i cas istruzion conten all&#39; intern cicl veng ripet finc condizion riman ver . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2429"><question_text>oper assegn x++ ++x svolg stess funzion ? assum x=3 , qual è different stamp &#34; printf ( &#34; % d &#34; , x++ ) &#34; stamp &#34; printf ( &#34; % d &#34; , ++x ) &#34; ? </question_text><answer id="A2387"><answer_text>different i 2 oper è x++ prim val variabil x poi increment valor , mentr l&#39; oper ++x prim increment variabil poi val . esemp &#34; printf ( &#34; % d &#34; , x++ ) &#34; verr stamp valor &#34; 3 &#34; poi verr increment variabil mentr &#34; printf ( &#34; % d &#34; , ++x ) &#34; verr stamp valor già increment &#34; 4 &#34; . </answer_text><num_votes>0</num_votes></answer><answer id="A2514"><answer_text>different i oper somm sta fatt scriv x++ , valor x vien increment dop l&#39; utilizz variabil x , mentr form prefiss ++x , x vien increment valor x vien denot dop l&#39; increment . mod scrittur printf , vien stamp valor assegn x prim x veng increment . cas ciò vien stamp è valor x dop esso l&#39; increment . </answer_text><num_votes>0</num_votes></answer><answer id="A2516"><answer_text>si scritt com istruzion cioe&#39; rig termin punt virgol , perc &#39; entramb increment x , altriment fann part un&#39; istruzion ?x++ ? valor x prim dell&#39; increment ?++x ? valor x dop l&#39; increment . si c&#39;e &#39; different stamp : nell&#39; istruzion &#34; printf ( &#34; % d &#34; , x++ ) &#34; valor x vien stamp e&#39; ?3 ? perc x e&#39; prim dell&#39; increment ; nell&#39; istruzion &#34; printf ( &#34; % d &#34; , ++x ) ? valor x vien stamp e&#39; ?4 ? perc x e&#39; dop l&#39; increment . </answer_text><num_votes>0</num_votes></answer><answer id="A2381"><answer_text>oper increment x++ ++x,svolg stess funzion ,increment x un&#39; unit . è different scrittur : x++ è defin post increment , cio , compil esegu prim l&#39; istruzion dov è present variabil dop increment . scrittur ++x si defin pre increment , cio , compil prim increment variabil poi esegu l&#39; istruzion contien . assum x=3,esegu printf ( &#34; % d &#34; , x++ ) visualizz valor 3(dop quest&#39; istruzion x=4 ) . quand esegu printf ( &#34; % d &#34; , ++x ) visualizz valor 4(variabil pre increment ) . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2442"><question_text>qual oper applic variabil tip puntator ? </question_text><answer id="A2413"><answer_text>oper applic : -assegn (tram &#38; ) assegn l&#39; indirizz variabil . (es : p=&#38;x , dov p è puntator tip inter ) . -dereferenz (tram * ) . (es : x=*p ) . -asegn valor puntator . (es : p=q ) -confront puntator . (es : p==q ) -oper aritmet (somm sottrazion ) . (es : p= a+1 è equivalent p=a [1 ] ) </answer_text><num_votes>2</num_votes></answer><answer id="A2432"><answer_text>impotr oper applic variabil tip punttor è * , necessar esegu l&#39; oper dereferenz . fondamental è &#38; , applic variabil prelev l&#39; indirizz (magar assegn variabil tip puntator ) . si segnal poi oper : ++ -- ! size_of (altr oper unar ) = += -= assegn , ovvi necessar moltissim oper + , - util correl array puntator == , != , &#62; , &#60; , &#60;= , &#62;= confront &#38;&#38; || logic boolean ) [ ] . -&#62; notazion suffiss * / % moltipl ? : condizional </answer_text><num_votes>2</num_votes></answer><answer id="A2503"><answer_text>oper applic i puntator : dereferenz cio l&#39; assegn puntator right-valu variabil (esemp x=3 , x=*p conseguent *p punt valor 3 ) ; l&#39; assegn indirizz , cio puntator vien assegn l&#39; indirizz variabil cio left-valu essa (esemp p=&#38;x ) p è salv l&#39; indirizz cell memor occup variabil x ; inoltr è possibil somm sottrarr quantit puntator qual punt all&#39; indirizz memor success precedent . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2436"><question_text>qual e&#39; different compil interpret programm ? qual i vantagg svantagg ? infin , qual cas e&#39; adott soluzion all&#39; altra ? </question_text><answer id="A2379"><answer_text>cas vien &#34; gener &#34; qualcos è &#34; dirett &#34; usabil (esegu ) processor ; cas c&#39; è mezz programm (l&#39; interpr ) fa sì codic (tipic test ... cas vm è &#34; linguagg macchin virtual &#34; necess comunqu interpr ) facc effett qualcos . </answer_text><num_votes>0</num_votes></answer><answer id="A2396"><answer_text>i linguagg compil veng scritt editor si occup controll correttezz codic poi compil , ogni istruzion vien trasform corrispondent codic linguagg macchin può esser esegu processor . i linguagg interpret veng elabor vol veng esegu istruzion cos com descritt codic sorgent controll error . vantagg linguagg interpret elev portabil immediatezz , mentr compil richied minor processor svolg error </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2439"><question_text>different cicl for cicl whil ? </question_text><answer id="A2488"><answer_text>cicl for cicl whil equivalent infatt cicl for può esser riscritt usand cicl whil vicevers .son per div struttural .infatt cicl for struttur tip for(inizializz ; condizion ; increment ) { &#60;istruzione&#62; ; } mentr cicl whil struttur tip whil ( condizion ) { istruzion ; } </answer_text><num_votes>0</num_votes></answer><answer id="A2391"><answer_text>cicl for l&#39; inizializz variabil contator , test condizion ingress cicl l&#39; increment variabil contator veng effettu all&#39; iniz : for(inizializz ;condizion ;increment ) { istruzion } . cicl whil condizion vien post all&#39; inizio(whil (condizion ) { istruzion } ) , mentr variabil utilizz com contator esser scritt all&#39; intern cicl l&#39; increment variabil stess . sol cicl for vien utilizz quand numer ripetizion è not , mentr cicl whil quand non si conosc . </answer_text><num_votes>1</num_votes></answer><answer id="A2408"><answer_text>livell sintatt equivalent . ogni for può esser tradott whil essi equivalent livell linguagg macchin . tuttav whil è solit prefer quand condizion test è condizion logic non dirett leg numer iter esegu ; vicevers for è solit utilizz quand si vuol iter numer precis . quest , per , è question comod non obblig . esemp traduzion for -&#62; whil for(inizializz ; test ; step ) { ... } = inizializz whil (test ) { ... step } </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2435"><question_text>qual principal istruzion linguagg c ? elencal descrivil brevement . </question_text><answer id="A2364"><answer_text>principal istruzion c : istruzion assegn vien utilizz assegn variabil valor un&#39; espression ; istruzion ingress uscit consent legg scriv valor variabil standard input standard output ; istruzion compost qual l&#39; istruzion condizional consent esegu divers sequenz istruzion bas valor verit condizion l&#39; istruzion iter permett ripetizion dell&#39; esecu sequenz istruzion ogni volt cert condizion è verific . </answer_text><num_votes>1</num_votes></answer><answer id="A2505"><answer_text>istruzion : - assegn , si attribu variabil valor tip ; - lettur , si può ricev valor standard input eventual assegn variabil ; - scrittur , si può stamp valor standard output ; - condizional , permett esegu divers istruzion second valor variabil un&#39; espression (se ver si esegu cert istruzion , fals ) ; - iter , permett ripet più ser istruzion . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2459"><question_text>vuol dir scritt : &#34; # includ &#60;stdi .h&#62; &#34; </question_text><answer id="A2450"><answer_text>&#34; stdi .h &#34; , signif &#34; standard input-output header &#34; , è l&#39; header fil librer standard c contien definizion macr , costant dichiar funzion tip usat var oper input/output . </answer_text><num_votes>0</num_votes></answer><answer id="A2478"><answer_text>signif si poss utilizz all&#39; intern programm funzion dichiar librer standard c stdi .h , sta &#34; standard input-output header &#34;, contien definizion macr (insiem comand ) , costant dichiar funzion tip usat var oper input/output . </answer_text><num_votes>2</num_votes></answer><answer id="A2377"><answer_text>post prim funzion &#34; main &#34; , impon programm usar librer standard propr c , l&#39; input l&#39; output . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2448"><question_text>consist procedur programm top-down ? qual vantagg port cas vien utilizz ? </question_text><answer id="A2366"><answer_text>e&#39; tecnic consist defin strateg risolu problem general attravers livell dettagl sempr più precis , scompon problem sottoproblem particolar . procedur programm top-down god seguent vantagg : 1 . nett semplif problem codic graz possibil suddivid più (ognun propr task ) ; 2 . facil manutenzion codic ; 3 . problem è chiar tutt quand part programm . vien usat quand si risolv problem sempr più compless . </answer_text><num_votes>0</num_votes></answer><answer id="A2494"><answer_text>programm top-down è stil programm problem compless , algoritm proced vien suddivis sottoproblem più piccol più semplic implement linguagg desider . i vantagg programm top-down : -permett concentr aspett più signif ; -rend l&#39; algoritm semplic più leggibil ; -la risolu può esser modific si modif struttur general dell&#39; algoritm risolut ; -la risolu sottoproblem può esser riutilizz problem . </answer_text><num_votes>3</num_votes></answer><answer id="A2374"><answer_text>top-down signif letteral &#34; dall&#39; alto vers bass &#34; rappresent mod scriv programm . e&#39; util scomporr grand &#34; problem &#34; tant problemin minor tratt volt . scorr vers bass , compil legg codic dar com soluzion somm tutt i problemin scompost l&#39; abil programm . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2554"><question_text>cos&#39; è &#34; tip &#34; dat ? </question_text><answer id="A2461"><answer_text>tip dat è form quel dat può assum . parol indic l&#39; insiem valor variabil risult espression poss assum oper effettu tal valor . , esemp , dichiar variabil tip inter (int ) , i valor quest variabil può assum sol i numer inter . parol assegn quest variabil espression risult numer virgol , compil dar messagg error quant tip dat variabil è inter . </answer_text><num_votes>3</num_votes></answer><answer id="A2370"><answer_text>c tip dat e&#39; caratterizz i valor puo&#39; assum varianil . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2573"><question_text>different usar l&#39; istruzion switc piuttost ser if else nidific ? </question_text><answer id="A2447"><answer_text>line general istruzion prestazion simil . tuttav condizion casist tutt form &#34; x==k &#34; l&#39; istruzion switc risult più leggibil immed . cas è consigl usar switc è quand variabil controll fa part funzion , quand quest verrebb richiam soltant volt , mentr l&#39; istruzion if-els verrebb richiam ogni &#34; if/else-if/els &#34; . infin mentr l&#39; istruzion switc esce ( &#34; break &#34; ) cicl volt esegu &#34; cas &#34; , l&#39; if-els confront esegu tutt condizion . </answer_text><num_votes>0</num_votes></answer><answer id="A2392"><answer_text>livell risult final , livell ottimizz programm puliz codic e&#39; prefer utilizz costrutt switc , perc &#39; evit compil imbatt casist qual si sarebb trov legg tutt if-els andand legg casist interess . </answer_text><num_votes>1</num_votes></answer><answer id="A3438"><answer_text>ser if-els qual vogl confront singol valor inter div valor costant altern può esser realizz mediant com condizional &#34; più vie&#34; switc . l&#39; enunc switc si può usar circost limit . i valor i qual si può confront selettor dev esser costant tip inter , char enumer : non si può usar switc esemp selettor tip doubl string . quand è lec , non i cas è opportun l&#39; istruzion switc sostitu l&#39; istruzion if-els (esemp rang valor int ) </answer_text><num_votes>0</num_votes></answer><answer id="A2375"><answer_text>different è stilist : è più leggibil switc if nidific . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2509"><question_text>si intend , linguagg programm c , tip fondamental tip deriv ? </question_text><answer id="A2436"><answer_text>classific i tip dat si distingu tip fondamental (o semplic ) tip deriv (o struttur ) . i tip fondamental serv rappresent inform semplic com i numer inter , i caratteri; rientr quest categor i tip : char , int , float , doubl quest stess l&#39; aggiunt &#34; qualif tip &#34; com signed unsigned , short long . i tip deriv serv rappresent inform compless tram costruzion struttur dat compless part tip semplic ; rientr quest categor : array , struttur puntator . </answer_text><num_votes>2</num_votes></answer><answer id="A2411"><answer_text>i tip dat tipolog variabil utilizz programma.in c &#39;tip fondamental &#39; (int , char , float.. ) si intend quell variabil rappresent inform semplici,mentr &#39;tip deriv &#39; (array , struct , puntator . . ) variabil rappresent inform costitu dall&#39; aggreg div component .infatt different fondamental quest tip dat sta fatt l&#39; inform conten variabil semplic è logic indivis , mentr quell conten variabil struttur può esser scompost component . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2478"><question_text>si intend &#34; macchin astratt c &#34; ? </question_text><answer id="A2376"><answer_text>informat termin macchin astratt indic modell teoric hardw softw , grad esegu oper , memorizz risult segu fluss dell&#39; algoritm . attravers l&#39; uso macchin astratt è possibil calcol quantit risors necessar esegu determin oper , dover costru sistem real . più famos esemp macchin astratt è macchin turing . </answer_text><num_votes>3</num_votes></answer><answer id="A2404"><answer_text>e&#39; insiem struttur dat algoritm permett esegu programm c , permett trasform input output </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2432"><question_text>cos&#39; è linguagg assembler funzion ? </question_text><answer id="A2469"><answer_text>linguagg assembler e&#39; piu&#39; vicin linguagg macchin scop general consent programm ignor form binar linguagg macchin . ogni codic oper linguagg macchin vien sostitu , linguagg assembler , sequenz caratter rappresent form mnemon (simbol ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2515"><answer_text>linguagg assembler è rappresent simbol (mnemon ) codif binar usat calcol (linguagg macchin , binar ) . tip linguagg utilizz simbol , registr , etichett utilizz codif binar (la qual è salv memor ) invi richiest cpu . l&#39; assembler è programm traduc codic linguagg assembler linguagg macchin funzion è propr quell far comunic linguagg alto livell cpu . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2561"><question_text>com poss defin struttur all&#39; intern dell&#39; ambient programm c , vantagg comport ? </question_text><answer id="A2441"><answer_text>più semplic dat struttur è l&#39; arrey . esso è raccoglitor tant variabil si distingu indic indic parentes . volt dichiar compil riserv memor spaz sufficient memorizz variabil </answer_text><num_votes>0</num_votes></answer><answer id="A2372"><answer_text>costruttor tip struct c permett defin struttur aggreg element tip div ; tal element si chiam camp struttur . infatt , cas , risult tutt imposs struttur l&#39; inform mediant meccan dell&#39; array , poic esso richied tutt i element sian omogene . i valor tip costru mediant struct costitu sequenz valor , i valor camp , appartenent tip qualsias . fatt struct costruttor tip implic esso può esser impieg esatt com array . </answer_text><num_votes>3</num_votes></answer><answer id="A2423"><answer_text>si può defin struttur attravers tip struct . mod è possibil incapsul grupp variabil correl , raggrupp quell apparteng logic oggett . programm guadagn leggibil , sfrutt rappresent gerarc dat . e&#39; util quand si gest inform (anc eterogene ) caratterizz per dat . cos è possibil assegn (o pass a/da funzion ) tutt part aggreg unic dat . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2445"><question_text>si intend strong typing loos typing linguagg programm ? </question_text><answer id="A2489"><answer_text>c loos typing si intend i tip dat variabil non dev necessar esser dichiar . strong typing si intend i tip dev esser dichiar (c++ ) ; different risied scelt decisional progett linguagg , può vol più men flessibil all&#39; intern esso . metod loos typing programm può commett error tip potrebber compromett l&#39; esecu programm , strong typing costrett segu regol rigid , , non permett risolv veloc problem . </answer_text><num_votes>1</num_votes></answer><answer id="A2481"><answer_text>&#34; strong typing &#34; si intend linguagg programm i tip variabil dev esser dichiar non poss camb , contrar linguagg programm &#34; loos typing &#34; permett camb tip variabil . esemp linguagg loos typing è possibil camb tip risult division integer , qual sarebb anch&#39; esso integer , variabil tip float semplic attravers l&#39; oper &#34; cast float &#34; . quest oper &#34; casting &#34; non sarebb possibil linguagg strongly typed . </answer_text><num_votes>1</num_votes></answer><answer id="A2398"><answer_text>strong typing vin utilizz c++ jav signif variabil dev esser dichiar non poss camb . loos typing vien utilizz linguagg javascript . quest termin veng utilizz critic esalt linguagg , classific bas ala sicurezz . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2473"><question_text>perc quand si usa funzion scanf string non serv mett &#38; indic l&#39; indirizz variabil risult inser tastier esser memorizz ? </question_text><answer id="A2462"><answer_text>string non è necessar &#38; perc esse funzion già puntator non c&#39; è bisogn si indic qual esser l&#39; indirizz rifer variabil . anzi mett quest si indic l&#39; indirizz prim cell compil sa già qual cell conteng element success dell&#39; array . </answer_text><num_votes>1</num_votes></answer><answer id="A2361"><answer_text>string è un&#39; array char . com not un&#39; array è identific l&#39; indirizz cell memor element dell&#39; array . variabil s inizializz array char funzion stregu puntator punt cell memor . si può conferm andand far inizializz compil array char (ex char s[ ]= &#34; prov &#34; poi fac print &#34; printf ( &#34; % d &#34;, s ) &#34; si può not com numer programm restitu non i valor salv string bens l&#39; indirizz prim cell dell&#39; array (&#38; s [0 ] ) . </answer_text><num_votes>2</num_votes></answer><answer id="A2476"><answer_text>quand si usa funzion scanf, variabil string esser indic l ?oper indirizz &#38; , quant , string (ed general array ) denot già indirizz (l ?indirizz element ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2434"><question_text>cos&#39; è tip struttur , serv com vien dichiar c ? </question_text><answer id="A2500"><answer_text>c programm possibil &#39; usar costrutt struct defin struttur dat divers tip . com struct inser part dichiar , cioe&#39; part prim main . inoltr dat variabil tip struct , l&#39; access camp , avvien mediant &#34; dot notation &#34; , &#34; chiav &#34; acced inform specif eterogene e&#39; compost . </answer_text><num_votes>1</num_votes></answer><answer id="A2531"><answer_text>tip struttur è tip vien espress dichiar programm , può plasm bas esigent . c vien dichiar mod : struct nome_struttura{ tipo1 nomecampo1 ; tipo2 nomecampo2 ; .... } nome_var ; </answer_text><num_votes>1</num_votes></answer><answer id="A2382"><answer_text>tip struttur è tip dat contien tip dat . serv cre variabil conteng var camp leg quell variabil , esemp memorizz var parametr oggett . vien dichiar tram com typedef struct {camp } ; </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2521"><question_text>quand è consigl utilizz cicl whil , quand cicl for? </question_text><answer id="A2427"><answer_text>quand numer cicl esser ripet è not cicl for è più facil scriv , modific , controll . quand cicl ripet finc val cert condizion ciò dip qualcos non preved , non si sa quant cicl esegu , si usa comun cicl whil . </answer_text><num_votes>2</num_votes></answer><answer id="A2454"><answer_text>cicl for è indic oper si conosc numer ripetizion esegu . cicl whil è particolar util quand si ripet un&#39; oper moltepl , non si conosc quant ; inoltr è consigl quand si modific esecu numer cicl esegu . infin cicl whil è possibil cre cicl for , mentr l&#39; invers non è possibil . </answer_text><num_votes>0</num_votes></answer><answer id="A2425"><answer_text>cicl whil vien utilizz ripet l&#39; esecu blocc istruzion ogni qual volt condizion risult esser ver . cicl for preved l&#39; inizializz variabil dipend tutt cicl segu condizion dall&#39; increment (sempr variabil ) .vi è poi blocc istruzion dev esser esegu tutt condizion risult esser ver . cicl for è consigl quand è già not numer ripetizion necessar cicl , mentr whil si usa quand ripetizion dipend valor non not . </answer_text><num_votes>0</num_votes></answer><answer id="A2499"><answer_text>cicl whil rip ser comand finc condizion inizial risult ver . utilizz cicl programm non conosc numer iter total , nè men sap tal cicl sar esegu volt . cicl for rip ser comand numer precis bisogn già conosc tutt quest dat . userem whil preved infin error part utent inser valor rispett determin condizion , mentr userem for programm qualcos precis com array . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2455"><question_text>e&#39; possibil implement pezz codic assembler sorgent scritt c c++ ? </question_text><answer id="A2467"><answer_text>linguagg c è med livell astrazion superior linguagg assembler . mot codic c esser compres esegu calcol bisogn esser &#34; tradott &#34; linguagg bassissim livell (quest è comp compil ) . implement codic c codic astrazion inferior (sintatt semant different ) non sarebb decifr compil , non riusc rend esegu . conseguent codic &#34; mist &#34; abbiam scritt rest inutilizz . </answer_text><num_votes>0</num_votes></answer><answer id="A2388"><answer_text>si , è possibil implement comand assembler all&#39; intern programm c/c++ . ciò può esser fatt utilizz funzion asm ( ) (esemp : asm( &#34; codic assembler &#34; ) ; ) . </answer_text><num_votes>3</num_votes></answer><answer id="A2369"><answer_text>si , è possibil graz all&#39; assembler inlin permett compil corrett codic assembly inser sorgent scritt c c++ . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2451"><question_text>costrutt if-els annid tip : if (c1 ) if (c2 ) else ram else qual if esser attribu ? </question_text><answer id="A2353"><answer_text>cas costrutt else si rifer if (c2 ) poic compil attribu if più vicin . </answer_text><num_votes>0</num_votes></answer><answer id="A2371"><answer_text>part else è annid struttur if (c1 ) , si rifer struttur if (c2 ) . condizion if (c2 ) non è verific nemmen quell else , esclusion si verific condizion if (c1 ) </answer_text><num_votes>0</num_votes></answer><answer id="A2437"><answer_text>costrutt if-els annid , com nell&#39; esemp , l&#39; else si rifer all&#39; if più vicin (in cas if (c2 ) ) , moment non parentes graff modific l&#39; appartenent dell&#39; else if (per esemp if (c1 ) ) . </answer_text><num_votes>2</num_votes></answer><answer id="A2354"><answer_text>cas costrutt else si rifer if (c2 ) poic compil .attribu if più vicin . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2427"><question_text>qual mot l&#39; identif predefin &#34; main &#34; vien dichiar com numer inter &#34; int &#34; ? serv struttur (int argc , char *argv[ ] ) segu ? </question_text><answer id="A2456"><answer_text>l&#39; indic predefin &#34; main &#34; vien dichiar com numer inter quant obbligator restitu inter segnal condizion error . struttur (int argc , char *argv[ ] ) , &#34; argc &#34; è numer parametr programm , mentr &#34; argv &#34; è l&#39; array contien quest programm . </answer_text><num_votes>0</num_votes></answer><answer id="A2389"><answer_text>l&#39; identif main vien defin &#34; int &#34; poic &#39; puo&#39; restitu codic numer error sistem oper . argc arggv argoment line com . int argc contien numer string inser ?utent line com char *argv[ ] e&#39; l ?array contien string inser ?utent line com (ogn element ?array è puntator caratt ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2355"><answer_text>l&#39; identif main vien defin &#34; int &#34; poic &#39; puo&#39; restitu codic numer error sistem oper . argc arggv argoment line com . int argc contien numer string inser ?utent line com char *argv[ ] e&#39; l ?array contien string inser ?utent line com (ogn element ?array è puntator caratt ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2410"><answer_text>l&#39; identif main è tip int quant è funzion ritorn valor inter ,0 default,il qual chiud l&#39; esecu programm tram controll part compil (se è 0 chiud programm ) . struttur (int argc , char *argv[ ] ) pass programm i parametr inser line com moment richiest esecu sistem oper . argc contien numer parametr rig com ,inclus programm . argv e&#39; array puntator char . ogni puntator referenz parametr form string . </answer_text><num_votes>0</num_votes></answer><answer id="A2367"><answer_text>parol chiav inizial int rappresent tip valor restitu funzion . cas special main , esso vien interpret com valor restitu dall&#39; inter programm sistem oper . coerent convenzion universal circ i valor restitu programm sistem , main restitu sempr numer inter . argc contien numer paramentr rig com , inclus programm . pertant argc e&#39; sempr &#62;= 1 . argv e&#39; array puntator char . ogni puntator referenz singol parametr line com sottoform sempr . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2475"><question_text>cos&#39; è programm ? </question_text><answer id="A2474"><answer_text>programm è sequenz fin istruzion risolv problem oper struttur dat alto livell , memor fisic . i programm , inoltr , ricev valor ingress , produc valor uscit , chiar , non ambigu esegu termin numer fin pass . scritt linguagg programm comprens calcol </answer_text><num_votes>1</num_votes></answer><answer id="A2435"><answer_text>programm informat può esser defin com algoritm compless post form comprens computer (scritt tram linguagg programm ) . &#34; programm &#34; è insiem ordin istruzion espress specif regol not prior tram esecutor (computer ) elabor soluzion i problem post . termin collabor l&#39; hardw macchin poter restitu risult part dat ingress . </answer_text><num_votes>3</num_votes></answer><answer id="A2458"><answer_text>programm è form ser algoritm veng elabor calcol svolg determin azion richiest dall&#39; utent . ciò bisogn riusc &#34; tradurr &#34; algoritm linguagg comprens calcol quest ser comand è ver propr programm invi i var dat calcol cpu . </answer_text><num_votes>0</num_votes></answer><answer id="A2424"><answer_text>programm è sequenz fin istruzion risolv problem , soddisf cert criteri(com ricezion valor ingress produzion valor uscit ;termin dop cert numer pass ) oper struttur dat . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2546"><question_text>different c&#39; è cicl &#34; whil &#34; cicl &#34; do whil &#34; ? </question_text><answer id="A2495"><answer_text>i cicl simil different cicl &#34; do-whil &#34; esegu sempr almen volt corp cicl (le istruzion ) . infatt , condizion è fals , cicl &#34; whil &#34; non esegu mai istruzion , cicl &#34; do-whil &#34; esegu volt . inoltr cicl &#34; do-whil &#34; è più util quand numer iter è not . cicl whil : contator = valore_inizial ; whil (contator &#60;= valore_final ) { istruzion contatore++ ; } cicl do-whil : contator = valore_inizial ; do { istruzion contatore++ ; } whil (contator &#60;= valore_final ) ; </answer_text><num_votes>0</num_votes></answer><answer id="A2439"><answer_text>cicl whil esegu ser istruzion finc condizion valut è ver . tip cicl condizion è valut prim esegu sequenz istruzion . quand numer iter è not prior è util usar cicl do whil . cicl do whil , può esser utilizz post cicl whil , esegu anch&#39; esso ser istruzion si ripet ogni iter . contrar cicl whil , cicl condizion è valut ogni iter . </answer_text><num_votes>2</num_votes></answer><answer id="A2517"><answer_text>quand uso dowhil so blocc istruzion sar esegu almen volt , mentr utilizz whil c&#39; è possibil non dover esegu mai codic blocc . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2447"><question_text>qual different array , vettor string linguagg programm c ? </question_text><answer id="A2472"><answer_text>array è struttur dat omogene element tip . vettor è array monodimensional (es . int vettor [10 ] ) . esist array multidimensional com matric (es . m[10 ] [10 ] ) array tridimensional (es . t[10 ] [10 ] [10 ] ) . string , , è tip dat &#34; user defin &#34; defin memorizz string (sequenz carratter ) . realt sting è array char è defin cos : typedef char stringa[20 ] ; </answer_text><num_votes>1</num_votes></answer><answer id="A2455"><answer_text>array è sequenz cell memor consecut omogene qualsias tip , esemp : tip [n ] ; tip può esser char , int , float ecc ... è indic l&#39; array n numer element nell&#39; array , dat si consider 0-esim numer element sar : n+1 . string è sequenz caratter immagazzin cell consecut , esemp : printf ( &#34; cia &#34; ) ; cia è string caratter . array tip char spess denomin com string . vettor è array numer (inter float ) caratt geometr . </answer_text><num_votes>0</num_votes></answer><answer id="A2468"><answer_text>vettor array c usat com termin interscamb ; vettor è più tendent &#34; interpret geometr &#34; (dall nozion vettor n-dimensional ) , sostanz è sempr array . vettor array c usat com termin interscamb ; vettor è più tendent &#34; interpret geometr &#34; (dall nozion vettor n-dimensional ) , sostanz è sempr array . </answer_text><num_votes>0</num_votes></answer><answer id="A2533"><answer_text>array , matric , c è ser element tip è colloc locazion memor contigu facil access tram indic . vettor è sinonim array ; talvolt vien differenz concettual c sostanzial linguagg alcun caratterist array semplic non , qual esemp capac esser ampli contratt bas esigent . string è tutt effett array caratter assum nom distint comod . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2555"><question_text>serv i puntatori,in qual cas veng usat ? </question_text><answer id="A2451"><answer_text>puntator è variabil contien l&#39; indirizz memor un&#39; altra variabil . programm c essi l&#39; unic mod esegu alcun oper , inoltr , produc codic sorgent compatt efficac . veng usat moment richiest compil vettor , struttur funzion . </answer_text><num_votes>1</num_votes></answer><answer id="A2428"><answer_text>puntator è variabil memorizz indirizz memor , poss acced tram l&#39; oper de-referenz (* ) . i puntator usat : 1 . gestion struttur dinam . 2.pass variabil funzion indirizz permett camb valor variabil contrar quand si effettu passagg valor 3.possibil riserv nuov memor durant l&#39; esecu programm 4.facilit condivision dat different part programm 5.far rifer grand struttur dat mod compatt . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2441"><question_text>è array ? qual cas risult util impieg ? </question_text><answer id="A2453"><answer_text>array è tip dat struttur , sort raccoglitor programm includ insiem variabil tip comun . ogni variabil si distingu indic tram qual è possibil l&#39; access ogni element . dichiar tal struttur avvien mediant specif tip dat includ , dell&#39; array numer element , corrispond numer cell memor compil riserv . ricord vien defin array n element ,l &#39; indic quest andrann 0 n-1 . </answer_text><num_votes>0</num_votes></answer><answer id="A2530"><answer_text>array è raccoglitor variabil omogene , memorizz cell memor consecut . dat ogni variabil occup post divers memor , vien applic indic ognun , qual indic posizion (dell variabil ) all&#39; intern dell&#39; array . acced variabil desider --&#62; nomearray[ind ] . array è util quand si vuol oper più variabil tip , evit dichiar volt volt variabil serv . </answer_text><num_votes>2</num_votes></answer><answer id="A2496"><answer_text>array è più semplic tip dat struttur , consist ser continu cell consecut omogene . quand si dichar , esemp , array a[10 ] , compil identif spaz 10 cell (dall posizion 0 9 ) utilizz dal&#39; utent , mentr numer 10 è riserv sistem inseris codic &#39;\0 &#39; defin . array poss esser utilizz com &#34; contenitor &#34; moltissim impieg , esemp organiz tutt i vot student , com foss cartell contien tutt i valor poss esser &#34; lett &#34; success . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2523"><question_text>consist tecnic valut &#34; pigr &#34; (lazy-evaluation ) utilizz c/c++ ? </question_text><answer id="A2397"><answer_text>durant valut condizion programm (legg sx vers dx ) ritien condizion appen lett risult verific conclud valut consider rest poic riten superflu . es : x=5 ; if (x&#60;10 || x=1 ) { .... } cas prim condizion è ver non occorr analizz second . </answer_text><num_votes>1</num_votes></answer><answer id="A2460"><answer_text>lazy-evalutation consist posticip valut comput quand risult comput è realment usat . quest tecnic aument performanc programm (non valut i component non necessar comput ) riduc possibil incontr error valut condizional comput . </answer_text><num_votes>0</num_votes></answer><answer id="A2445"><answer_text>valut pigr è strateg valut ritard valut un&#39; espression fintantoc valor non è richiest evit esegu più volt stess valut , diminu cos esecu . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2514"><question_text>qual oper possibil inter array ? è possibil esemp cop stamp inter array piuttost tutt i element sequenz (attravers cicl ) ? </question_text><answer id="A2508"><answer_text>non previst oper inter array ; pertant è necessar realizz programm mediant cicl permett iter tutt i singol element array consider . </answer_text><num_votes>2</num_votes></answer><answer id="A2493"><answer_text>element array tip &#34; int &#34; possibil tutt normal oper aritmet . ciascun element ?intern ?array si acced tram indic ( inter &#62;= 0 ) . segu è cicl stamp array 5 righ 5 colonn numer inter precedent inizializz . com è possibil ved necessar cicl stamp array form matric , altriment è sufficient cicl . for (i=0 ; i&#60;5 ; i++ ) { for (k=0 ; k&#60;5 ; k++ ) { printf ( &#34; % d &#34;, array[ ] [ k ] ) ; } printf ( &#34; \n &#34; ) ; } </answer_text><num_votes>0</num_votes></answer><answer id="A2483"><answer_text>programm c non è possibil oper (ad esemp printf scanf ) inter array . stamp conten si serv cicl &#39;for&#39; permett scorr i var element compong l&#39; array . esemp voless stamp conten v[10 ] (array inter ) : for(i=0,i&#60;10,i++ ) { printf ( &#34; % d &#34;, v[i ] ) ; } per si voless stamp , esemp , valor dell&#39; array si scriv : printf ( &#34; % d &#34;, v[3 ] ) ; </answer_text><num_votes>2</num_votes></answer><answer id="A2466"><answer_text>array dev&#39; esser inizializz cicl for; cicl esegu l&#39; assegn valor fas success stamp . estrarr valor dall&#39; array si utilizz parentes quadr l&#39; indic . struttur dell&#39; array può infin esser utilizz definizion matric . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2495"><question_text>abbiam vist metod dichiar struttur : struct nome{ .... , struct { ... prim punt virgol , poi l&#39; metod typedef struct{ ..., infin struttur stess . spieg principal different quest metod sopratutt i vantagg svantagg tal metod . </question_text><answer id="A2426"><answer_text>scriv struct x{ .. } x1 ; x è struttur , x1 variabil . uso struct x{ .. } ; main dichiar variabil mod : struct x x1 ; x1.campo=valor ; facc quest dichiar struct { .. } x1 ; x1 è variabil poss inizializz dirett i camp struct : x1.campo=valor ; usand typedef struct{ .. } ; dichiar variabil bast semplic scriv main s1,s2,s3,sn ; s1.campo=valor ; i vantagg nell&#39; usar typedef relat all&#39; ordin , leggebil comprension codic . </answer_text><num_votes>1</num_votes></answer><answer id="A2519"><answer_text>sint &#34; struct nome0{ .. } &#34; non si dichiar variabil tip struct struttur &#34; nome0 &#34; (quind success dichiar variabil scriv &#34; struct nome0 nome_var &#34; ) , &#34; struct { .. } nome1 &#34; vien dichiar variabil tip struct si chiam &#34; 1 &#34; struttur non mentr &#34; typedef struct { .. } nome_tipod &#34; si cre tip variabil defin dell&#39; utent si chiam &#34; nome_tipod &#34; . prim equivalent mentr terz vantagg permett success rius tip dat &#34; nome_tipod &#34; </answer_text><num_votes>2</num_votes></answer><answer id="A2490"><answer_text>struct consent grupp variabili,anc tip diverso,aggreg insiem unic è tip struct veng dichiar etichett struttur serv com abbrev success dichiarzion (non costrutt ) typedef struct permett cre tip dat complessi,il scop è assegn nom altern tip dat esistent ,solit quell dichiar standard è tropp ingombr vantagg : variabil dichiar struttur si poss usar tutt main </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2525"><question_text>qual cas variabil veng dichiar global (fuor metod &#34; main &#34; ) local (dentr metod &#34; main &#34; ) ? </question_text><answer id="A2498"><answer_text>veng defin global quand sens quest variabil poss ven utilizz ogni funzion fuor main main . mentr veng defin local quell variabil utilizz è relat all&#39; intern main poss esser vist . </answer_text><num_votes>0</num_votes></answer><answer id="A2368"><answer_text>variabil global util quand più funzion utilizz stess dat , svantagg impieg memor tutt dur programm non quand è necessar . l&#39; uso variabil global dov potrebb esser usat local rend funzion men general perc funzion implic conoscent element estern funzion . inoltr usand molt variabil global si risc perd controll ciò può port error dov effett collateral indesider imprev . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ2443"><question_text>si intend &#34; pseudo-cod &#34; ? </question_text><answer id="A2459"><answer_text>pseudo-cod si intend linguagg informal si avvicin linguagg programm , è più astratt quant serv esclus all&#39; uom fars un&#39; ide scrittur algoritm . </answer_text><num_votes>1</num_votes></answer><answer id="A2465"><answer_text>&#34; pseudo-cod &#34; si intend linguagg programm rappresent serv dar ide progett andra ? scritt linguagg c ver propr . </answer_text><num_votes>0</num_votes></answer><answer id="A2484"><answer_text>pseudocod si intend tip linguagg util rappresent algoritm , può affianc sostitu diagramm blocc . linguagg si inser descrizion linguagg natural dell&#39; algoritm stesur programm linguagg alto livell . non è compil interpret macchin , serv rend l&#39; ide sequenz istruzion programm dovr esegu . </answer_text><num_votes>1</num_votes></answer><answer id="A2520"><answer_text>si intend linguagg non dirett esegu calcol , util per descrizion algoritm . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2486"><question_text>aucced si omett break all&#39; intern costrutt switc ? </question_text><answer id="A2475"><answer_text>si omett &#34; break &#34; controll pass blocc &#34; cas &#34; ?altr : moment foss già stat trov soluzion , assenz &#34; break &#34; , compil andrà verific tutt &#34; cas &#34; . sostanzial l&#39; utilizz &#34; break &#34; molt permett evit dispend inutil risors . </answer_text><num_votes>1</num_votes></answer><answer id="A2415"><answer_text>succed si avrà un&#39; esecu casc tutt i cas success scelt è indispens mett far si salt istruzion conten success cas vad dirett all&#39; istruzion success switc . </answer_text><num_votes>0</num_votes></answer><answer id="A2414"><answer_text>costrutt switc macchin valut l&#39; espression dop parol switc . valor appartien insiem costant specific mediant clausol cas , macchin esegu sequenz istruzion riport dop l&#39; insiem costant quell ram cas success . evit &#34; fenomen casc &#34; mod istruzion assoc all&#39; insiem valor costant selezion sian esegu , si posizion un&#39; istruzion break , l&#39; effett far salt istruzion success ram cas . </answer_text><num_votes>1</num_votes></answer><answer id="A2405"><answer_text>break è part costrutt switc qual fa si dop aver trov caso/risult adatt all&#39; espression inser , cicl termin continu controll inutil i cas success . esemp : switc (espression ) { cas val1 : blocc istruzion 1; break ; cas val2 : blocc istruzion 2 ; break ; default : ... } l&#39; espression equival val1 , dop aver esegu blocc istruzion 1 , break termin cicl switc . non foss present , cicl andrebb controll l&#39; espression equival val2 . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2464"><question_text>qual&#39; è different variabil semplic variabil struttur ? partcol vorre cap essenzial different utilizz . </question_text><answer id="A2532"><answer_text>variabil semplic conteng sol inform individu è sufficient . variabil struttur richied struttur intern permett efficient memorizz inform altrettant efficient individu inform memorizz . semplic individu l&#39; inter archiv ,poss richied nom indici,in mod tal ogni part individu . </answer_text><num_votes>0</num_votes></answer><answer id="A2431"><answer_text>variabil semplic cio tip built-in(es int , char ecc ) disposizion spaz memor limit dipendent tip dat (es int dispon 16bit ) , è possibil salv dat .un variabil struttur com l&#39; array permett disposizion più locazion memor (stabil nell&#39; indic ) salv i dat (sempr dat cell memor ) .si utilizz variabil struttur quand si dev valorizz dat avent comun attinent (es nome-cognom person ) , si necess valor è prefer utilizz variabil built-in . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2563"><question_text>si differenz codif asci quell unicod ? perc second pres sopravvent prim ambit web ? </question_text><answer id="A2477"><answer_text>asci e&#39; codic standard americ scamb inform può esser standard (7 bit = 128 combin ) oppur estes (8 bit = 256 combin ) . unicod è codif permess rappresent ogni simbol esistent var lingu mond attravers codic 2 byte (16 bit = 65535 combin ) . unicod pres sopravvent ambit web asci perc &#39; e&#39; possibil utilizz piu&#39; caratter divers codif utilizz fann rifer grand tabell unicod . </answer_text><num_votes>2</num_votes></answer><answer id="A2521"><answer_text>pratic codic asci è codic può 7 8 bit (standard estes ) , occup relat spaz nlla memor , tuttav non è grad rappresent tutt i caratterer esistent . codic unicod , , può 16 32 bit , simbol aggiunt si prefigg comp copr tutt i simbol (compres ideogramm ) occup , chiar , maggior spaz memor . unicod sta prend sopravvent quant è utilizz ret internet , esemp , poter rappresent lingu caratter special . </answer_text><num_votes>2</num_votes></answer><answer id="A2464"><answer_text>codif serv entramb rappresent i caratter . mentr codif asci utilizz 8 bit ( può rappresent massim 256 caratter , numer simbol ) , quell unicod utilizz 16 ( è stat aggiorn pot utilizz 21 ) , pot cos codific 65.536 caratter . unicod è utilizz internet perc ewb bisogn necessar rappresent i caratter divers lingu . </answer_text><num_votes>1</num_votes></answer><answer id="A2457"><answer_text>codif asci si differenz ?unicod fatt ultim 128 caratter (de 256 rappresent 8 bit ) si differenz lingu applic divers , mentr l ?unicod mir includ tutt i caratter unic codif , seppur più bit . standard unicod super l&#39; asci com codif web propr quest maggior capac espress comod codif standard tutt . rest fatt part 8 bit ?unicod (utf-8 ) ripr miglior schem asci . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2453"><question_text>dat quest porzion codic : int flag=1 ; whil (flag!=0 ) { scanf( &#34; % d &#34; , &#38;flag ) ; } dir perc seguent codic non è algoritm , cio qual regol definizion algoritm viol . </question_text><answer id="A2525"><answer_text>regol principal perc algoritm poss esser defin tal e&#39; esser compost &#34; sequenz precis fin oper &#34; esegu determin comp . codic propost , fa esegu cicl si concluder &#39; quand l&#39; utent inserir &#39; valor 0 , numer oper non è defin . inoltr codic non svolg nessun comp rilev , assegn valor variabil valor dovr &#39; esser forz cos 0 perc programm termin . </answer_text><num_votes>1</num_votes></answer><answer id="A2416"><answer_text>algoritm è defin com sequenz precis oper , comprens esecutor defin sequenz fin pass . com si può not porzion codic soprast viol l&#39; ultim regol , infatt , intern c&#39; è cicl whil infin qual rend quest righ codic sequenz istruzion infin . </answer_text><num_votes>0</num_votes></answer><answer id="A2449"><answer_text>algoritm esser defin tal esser compost sequenz precis fin oper realizz comp . codic esam propon cicl si rip l&#39; utent dig numer &#34; 0 &#34; , pertant cicl potenzial potrebb esser infin non compost ser &#34; fin &#34; oper . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2571"><question_text>contraddistingu livell astrazion linguagg c ? </question_text><answer id="A2417"><answer_text>livell astrazion è medio-alt poic linguagg si discost alquant linguagg macchin , lasc sistem gestion aspett com l&#39; alloc gestion memor , registr indirizz memor . </answer_text><num_votes>0</num_votes></answer><answer id="A2506"><answer_text>pot espress linguagg si manifest tip dat oper esprim , cio l&#39; insiem istruzion previst esprim controll fluss esecuzione.l caratterist principal linguagg c seguent :l&#39; elev pot espress (tip dat primit tip dat defin dall&#39; utent ) , caratterist bass livell ,lo stil programm incoragg svilupp programm pass raffin success infin sint defin formal . </answer_text><num_votes>2</num_votes></answer><answer id="A2443"><answer_text>c vien consider linguagg alto livell , ovver più vicin linguagg uman , più capibil , esso permett programm &#34; bass livell &#34; , esemp usand i puntator poss gest memor piac , più bass livell . oggi c vien utilizz , perc softw cre è snell . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2568"><question_text>qual è different &#34; # defin 20 &#34; &#34; const int = 20 &#34; vist entramb i mod è costant valor 20 ? </question_text><answer id="A2421"><answer_text>com &#34; # defin &#34; è dett preprogramm , è dirett compil defin &#34; macr &#34; (string ) , cas &#34; &#34; , compil , fas compil sostitu &#34; string sostitu &#34; , cas &#34; 20 &#34; . non vien alloc alcun valor memor . scriv &#34; const int = 20 &#34; signif dichiar costant tip inter identific &#34; &#34; valor &#34; 20 &#34; . cas compil predispon locazion memor scriv valor &#34;20 &#34; riman costant durant l&#39; esecu programm possibil esser modific . </answer_text><num_votes>2</num_votes></answer><answer id="A2429"><answer_text>dichiar costant tram &#34; # defin &#34; preved i valor assegn costant veng sostitu fas compil . cas dichiar &#34; const &#34; , , valor assegn vien archiv zon memor . consegu l&#39; uso &#34; # defin &#34; diminu l&#39; occup memor rend più veloc programm , poic durant l&#39; esecu , quand si utilizz tal costant , non è necessar ricerc i valor memor . </answer_text><num_votes>0</num_votes></answer><answer id="A2527"><answer_text>#defin è un&#39; istruzion fa part precompil : compil esegu sostitu &#39;a&#39; 20 all&#39; intern codic prim compil (pu , minim part , rend po&#39; più veloc l&#39; esecu ) . const , , costant vien elabor sol volt vien alloc spaz conten cell memor vien richiam codic tal indirizz . inoltr compil esegu controll valid costant . &#34; const&#34; quand vien applic variabil , quest cess esser modific avrem fatt costant . </answer_text><num_votes>1</num_votes></answer><answer id="A2507"><answer_text>&#34; # defin 20 &#34; è com si dà prim main , precompil , valor &#34;20 &#34; vien fisic sostitu codic dov comp &#34; &#34; . cas si tratt variabil vien sostitu all&#39; occorent , fas ottimizz , ultim fas compil . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2470"><question_text>caratterist linguagg c è quell esser &#34; cas sensit &#34; . signif ? </question_text><answer id="A2386"><answer_text>caratterist c è esser &#34; cas sensit &#34; , ciò signif lett maiuscol minuscol import . esemp dichiar variabil com &#34; val &#34; è divers &#34; val &#34; &#34; val &#34; . </answer_text><num_votes>0</num_votes></answer><answer id="A2394"><answer_text>signif compil distingu lett minuscol mauscol . scriv esemp printf printf printf cas complet div . permett identific parol chiav non poss esser utilizz ambit (tip nome_var nome_funzion ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2395"><answer_text>linguagg programm c si dic &#34; cas sensit &#34; poic riesc distingu i caratter maiuscol quell minuscol , caratterist pecul linguagg programm . </answer_text><num_votes>0</num_votes></answer><answer id="A2399"><answer_text>signif linguagg riconosc lett minuscol quell maiuscol , cio cas dichiar variabil &#34; letter &#34; &#34; letter &#34; compil c non dar error avrà alloc momor spaz variabil &#34; letter &#34; un&#39; spaz variabil &#34; letter &#34; . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2490"><question_text>mod poss usufru puntator gestion array ? </question_text><answer id="A2452"><answer_text>linguagg c , array non è sequenz element posizion mod contigu memor . propr quest caratterist dell&#39; array , poss not com strett colleg concett puntator : array non è puntator ser element . l&#39; uso puntator è indispens qualsias oper atta gestion dell&#39; array : l&#39; ordin ,l &#39; ispezion qualsias algoritm oper array fa attravers i puntator element e\o utilizz l&#39; aritmet puntator . </answer_text><num_votes>1</num_votes></answer><answer id="A2485"><answer_text>innanzitutt voless individu l&#39; n-esim element all&#39; intern un&#39; array &#34; &#34; poss usar indistint scrittur a[n ] oppur utilizz i puntator scrittur * (a+ n ) . inoltr puntator &#34; i &#34; &#34; n &#34; punt cell memor un&#39; array different i-n darebb com risult numer element present cell memor . </answer_text><num_votes>1</num_votes></answer><answer id="A2513"><answer_text>graz puntator è possibil complet gestion array . oper esegu puntator defin aritmet . esemp : istruzion &#34; p=&#38;a [0 ] &#34; , &#34; p=a &#34; (notazion equivalent ) , dov &#34; p &#34; è puntator &#34; &#34; array , è possibil punt element dell&#39; array . increment poi puntator (p++ ) si andrà punt success element dell&#39; array , mod sar possibil punt qualsias element . poi andrem esegu l&#39; istruzion &#34; x=*p &#34; , assegn valor conten l&#39; indirizz qual punt puntator . </answer_text><num_votes>3</num_votes></answer><answer id="A2480"><answer_text>l&#39; identif array fung puntator element , non è possibil modific valor , i puntator poss esser utilizz punt tutt element dell&#39; array . bisogn porr per particol attenzion dimension dell&#39; array , evit oltrepass i &#34; confin &#34; memor . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2503"><question_text>mod decodific numer decimal tip real form binar : decodif virgol fiss virgol mobil . consist com funzion rappresent virgol mobil ? qual i vantagg decodif virgol fiss ? </question_text><answer id="A2385"><answer_text>innanz tutt rappresent virgol fiss virgol mobil si poss rappresent numer razional approssim numer real . rappresent virgol mobil non decid prior quant bit verrann riserv part inter part decimal numer contrar rappresent virgol fiss . rappresent virgol mobil permett miglior precision mantiss . </answer_text><num_votes>0</num_votes></answer><answer id="A2463"><answer_text>rappresent virgol mobil numer real sistem numer decimal può esser vist com : r=m*10^n dov m, dett matiss è numer frazionar cio compres -1 1 , 10 rappresent bas (o radic ) elev n , numer inter segn , dett esponent . tip rappresent si vantagg virgol fiss poter codific numer grand numer piccol numer bits disposizion . quest ragion si utilizz tip rappresent . </answer_text><num_votes>2</num_votes></answer><answer id="A2526"><answer_text>codif virgol mobil vien esegu 32 bit , msb(bit più signif ) rappresent segn numer , i success 8 bit rappresent valor dell&#39; esponent ( part rappresent segn ) , i restanti23 bit rappresent mantiss ) . vantagg utilizz quest decodif è è possibil rappresent insiem numer real più grand virgol fiss . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2476"><question_text>different c&#39; è variabil puntator ? </question_text><answer id="A2434"><answer_text>variabil è valor memorizz &#34; locazion memor &#34; variabil , mentr puntator dic qual qual &#34; locazion memor &#34; è scritt valor variabil . </answer_text><num_votes>0</num_votes></answer><answer id="A2358"><answer_text>mentr variabil contien valor , potrebb esser tip char , int , doubl , float etc ... puntator contien l&#39; indirizz variabil contenent determin valor . </answer_text><num_votes>0</num_votes></answer><answer id="A2393"><answer_text>variabil identif cert tip dat cell memor . puntator tien cell memor l indirizz altra variabil . puntator variabil indirizz dev esser tip . i puntator gest oper unar * &#38; prend rispett i right left valu variabil punt . puntator valg regol algebr , si gioc indirizz non valor variabil . memor utilizz variabil puntator è sempr stess quantit , dip tip prescelt . </answer_text><num_votes>3</num_votes></answer><answer id="A2433"><answer_text>variabil è valor memorizz &#34; locazion memor &#34; variabil , mentr puntator dic qual qual &#34; locazion memor &#34; è scritt valor variabil . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2570"><question_text>perc scriv whil ( ) si otterr uscit programm cicl infin ? </question_text><answer id="A2378"><answer_text>part presuppost scriv whil ( ) compil dar error ,dat whil parentes necess condizion (altr è error ) ; comunqu , parentes mett costant !=0 cicl whil cicl all&#39; infin dat quell condizion è sempr ver , mett parentes whil 0 , uscir immediat cicl dat c 0 equival fals tutt rest ver . cicl whil termin non appen val condizion com fals , esemp int a=5;b=3 ; whil (a=b ) {blocc istruzion } . </answer_text><num_votes>0</num_votes></answer><answer id="A2363"><answer_text>linguagg programm c , ogni cicl whil è costitu whil (condizion ) parentes graff istruzion esegu . non inser nessun condizion , whil ( ) , compil dar error sint non potr esegu programm (è errat dir dar cicl infin ) . e&#39; possibil cre cicl infin inser parentes condizion sempr ver oppur qualsias valor purc divers 0 (es . whil (a&#62;a-1 ) oppur whil (1 ) ) . whil (0 ) , , programm consider condizion errat non entrer mai cicl . </answer_text><num_votes>1</num_votes></answer><answer id="A2438"><answer_text>scriv whil ( ) { } non si ottien uscit cicl infin ; si vien gener un&#39; error fas compil perc risult mancant condizion cicl whil . si ottien cicl infin scriv whil (1 ) { } perc condizion sempr valor &#34; 1 &#34; è sempr ver ( !=0 ) . calcol non uscir mai cicl whil volt è entrat . contrar cicl whil (0 ) { } non verr mai esegu perc condizion sar sempr fals . sar cicl &#34; inutil &#34; perc calcol non avrà mai possibil mand esecu </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2513"><question_text>quand si programm si utilizz variabil e/o costant : serv variabil costant , differ caratterizz ? </question_text><answer id="A2401"><answer_text>variabil costant serv memorizz tener tracc valor determin are memor .ogn variabil costant è caratterizz tip dat specif com dev poss esser gest i dat all&#39; intern esse.l different principal è utilizz ,infatti,dur l&#39; esecu programm valor conten all&#39; intern variabil poss esser modific mentr i valor costant no(l costant defin prior programm ) . dichiar variabil : tipo_d dichiar costant : #defin tipo_d </answer_text><num_votes>0</num_votes></answer><answer id="A2384"><answer_text>durant l&#39; esecu programm l&#39; utilizz variabil è fondamental permett logaritm camb risult final . different : variabil poss camb valor dat stat assegn durant l&#39; esecu programm , inoltr tip dat si poss attribu . costant valor rigid tutt dur programm non dispong tutt i tip dat non inter . sebben costant abbi stess funzion variabil , utilizz rend programm più ordin affid . </answer_text><num_votes>0</num_votes></answer><answer id="A2518"><answer_text>costant dat usabil sol lettur si defin sempr fuor main mediant com specif #defin mentr variabil contenitor conten puo camb veng defin specific tip dat dev conten . prim usat esemp cicl array defin numer ripetizion numer element valor fiss qual esemp p grec , variabil si usan dat contator tipic . </answer_text><num_votes>1</num_votes></answer><answer id="A2492"><answer_text>variabil costant utilizz c memorizz numer ,caratter string . com sugger , variabil volt dichiar tip , poss camb infin valor semplic dichiar valor . costant manteng sempr valor assegn moment dell&#39; inizializz non permett modif . variabil poss esser dichiar inizializz seguent mod tip nomevariabile=valor ; esemp int a=1 ; costant mod possibil : const int c=3 ; oppur , prim main : #defin c 3 ; </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2416"><question_text>qual fas principal nell&#39; esecu programm ? descrivil </question_text><answer id="A2446"><answer_text>3 fas esecu : fetc : l&#39; indirizz prim istruzion vien inser programcounter . cu cop conten pc nell&#39; ar vien lett quell&#39; indirizz ; tal dat vien conserv dr . conten dr vien ricop ir . frattemp pc si è aggiorn locazion success . decod : l&#39; istruzion vien interpret , prelev eventual memor dat necessar . exec : i dat veng caric registr cu invi alu com esecu dell&#39; oper . risult sar conten registr . psw verr aggiorn </answer_text><num_votes>2</num_votes></answer><answer id="A2528"><answer_text>fas principal esecu programm : - edit : programm vien cre memorizz disc - loader : programm vien caric - exec : programm vien esegu </answer_text><num_votes>0</num_votes></answer><answer id="A2522"><answer_text>fas principal nell&#39; esecu programm &#34; fas fetc &#34; , qual mediant registr &#34; program counter &#34; si individu l&#39; indirizz dell&#39; istruzion vien post bus indirizz attravers bus dat l&#39; istruzion individu vien port registr istruzion ; &#34; fas interpret &#34; qual l&#39; unit controll (uc ) decodif l&#39; istruzion registr istruzion corrent (cir ) ; infin &#34; fas esecu &#34; uc gener sequenz segnal esegu l&#39; istruzion . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2440"><question_text>perc linguagg c vien defin alto livell ? </question_text><answer id="A2491"><answer_text>c , linguagg macchin assembly , vien consider linguagg alto livell quant permett astrarr alcun problem com gestion memor , istruzion linguagg definizion dell&#39; algoritm . sar infatt compil , non programm , gest quest problemat . tuttav c risult più vicin linguagg macchin linguagg (pascal basic ) vien infatt spess identific com linguagg med livell . </answer_text><num_votes>1</num_votes></answer><answer id="A2511"><answer_text>realt linguagg c è defin med livell . perc si trov posizion intermed i linguagg bass livell (com assembler , più vicin calcol ) quell alto livell (più lontan linguagg macchin ) . trov spiegazion , esemp , fatt c permett interven sull&#39; alloc memor , pur distanz notevol linguagg macchin . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2418"><question_text>scrittur programm quant incid l&#39; ottimizz funzional ? si ottimizz volt è res funzion già sed scrittur inizial ? </question_text><answer id="A2487"><answer_text>ottimizz si intend process si increment sensibil prestazion programm sostitu alcun costrutt equivalent più efficienti.l funzional è grad programm risolv i problem propost . l&#39; ottimizz avvien programm già scritt funzion si compon tipic fas : collaud prestazional , analis prestazion , ottimizz algoritm , ottimizz indipendent piattaform , ottimizz dipendent piattaform softw ottimizz dipendent piattaform hardw . </answer_text><num_votes>1</num_votes></answer><answer id="A2440"><answer_text>non so cap domand , rispond ciò compres . si ottimizz già sed scrittur inizial , è possibil , risparm . si accorg , dop aver scritt programm , esist altern più ottimal , si , si proced l&#39; ottimizz . chiar funzional è import , tuttav , com tutt cos , ciò si vuol men cost men risors , è . </answer_text><num_votes>0</num_votes></answer><answer id="A2512"><answer_text>sicur l&#39; ottimizz è import , quant consent utilizz risors miglior mod ; per , caus dell&#39; elev funzional richiest , non è possibil effettu buon ottimizz poic grav funzional ; rispost univoc non esist , poic dip esigent vien cre quel programm . l&#39; ottimizz vien fatt fas dipendent filosof dall&#39; abitudin programm ; personal ottimizz già fas scrittur , spess termin scrittur riesc miglior ulterior programm . </answer_text><num_votes>1</num_votes></answer><answer id="A2402"><answer_text>scrittur programm è essenzial analizz problem progett l ?algoritm funzional poi verr tradott programm computer . è import funzional dat programm super-efficient ritorn risult tropp approssim non serv è import l ?ottimizz , perc programm corrett non funzion non serv . line massim si ottimizz già sed scrittur . è possibil comunqu ottimizz ulterior programm volt è funzion . </answer_text><num_votes>0</num_votes></answer><answer id="A2403"><answer_text>scrittur programm è essenzial analizz problem progett l ?algoritm funzional poi verr tradott programm computer . è import funzional dat programm super-efficient ritorn risult tropp approssim non serv è import l ?ottimizz , perc programm corrett non funzion non serv . line massim si ottimizz già sed scrittur . è possibil comunqu ottimizz ulterior programm volt è funzion . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2560"><question_text>com si dichiar puntator ? </question_text><answer id="A2479"><answer_text>dichiar puntator si fa segu variabil tip puntator (p ) tip rifer appartenent , esemp puntator contien l&#39; indirizz variabil inter si dichiar cos : int* p; dov l&#39; oper * (oper non referenz ) mand conten dell&#39; oggett punt p. p può possibil valor : p : conten valor variabil p (indirizz locazion memor punt ) ; &#38;p : indirizz fisic locazion memor p; *p : conten locazion memor punt ; </answer_text><num_votes>1</num_votes></answer><answer id="A2373"><answer_text>puntator si dichiar usand l&#39; oper aster (* ) , qual restitu conten dell&#39; oggett punt puntator . tradott c : tipod *tipopunt (es : int *puntator ) </answer_text><num_votes>1</num_votes></answer><answer id="A2400"><answer_text>dichiar puntator seguent form : ------------------------------------tipod *puntatore------------------------------ -- dov : 1 ) &#34; tipod &#34; defin vers qual tip variabil esso &#34; può punt &#34; ; 2 ) &#34; puntator &#34; è l&#39; identif variabil puntator ; 3 ) ? * ? si chiam oper unar de-referenz . ? import ten present programm defin puntator determin tip poi utilizz punt oggett tip , si potrann otten error esecu avvert fas compil . </answer_text><num_votes>3</num_votes></answer><answer id="A2442"><answer_text>puntator è variabil memorizz l&#39; indirizz locazion memor , cio l&#39; indirizz variabil . puntator esser dichiar com qualsias altra variabil , quant anch&#39; esso è variabil . esemp : int *p ; dichiar specif variabil tip : puntator inter . l&#39; introdu caratt * davant variabil indic si tratt puntator tip dichiar . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2460"><question_text>qual fas svilupp programm c ? consist ? </question_text><answer id="A2420"><answer_text>fas svilupp programm c : 1-edit : consist creazion memorizz codic 2-preprocess : consist prepar process codic 3-compilation : consist compil , cio creazion var oggett codic memorizz 4-link : consist colleg oggett codic rispett librer 5-load : consist caric codic esegu output 6-exec : consist nell&#39; esecu codic </answer_text><num_votes>0</num_votes></answer><answer id="A2523"><answer_text>fas svilupp programm c : edit,preprocess,compilation ,link ,load ,exec . nell&#39; edit programm vien cre nell&#39; editor salv , preprocess veng inclus fil (es : librer standard ) sostitu simbol special segu particolar dirett ,nell fas compil vien tradott programm linguagg macchina,nel linking si risolu rifer funzion variabil defin altrov (es . librer standard ) , loading si caric memor codic esegu , mentr programm vien esegu fas exec . </answer_text><num_votes>1</num_votes></answer><answer id="A2510"><answer_text>fas svilupp programm c : -la fas editing ,ovver scrittur codic , attravers l&#39; editor vien cre programm memorizz sull&#39; hard disk ; -la fas preprocessing cio fas preelabor codic ; -la fas compil dov compil cre codic oggett memorizz disc ; -la fas colleg si colleg codic oggett librer ; -la fas caric qual vien caric programm memor ; -la fas esecu ,l &#39; ultim fas cpu prel ciascun istruzion memor esegu </answer_text><num_votes>1</num_votes></answer><answer id="A2365"><answer_text>fas svilupp programm c : edit , preprocess , compilation , link , load exec . fas &#34; edit &#34; programm vien cre nell&#39; editor memorizz disc ; fas &#34; preprocess &#34; programm preprocessor elabor codic , conseguent fas &#34; compilation &#34; compil cre codic oggett memorizz disc ; fas &#34; link &#34; vien colleg codic oggett librer , success &#34; load &#34; programm vien caric memor , infin , fas &#34; exec &#34; cpu prend ogni istruzion esegu . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2467"><question_text>qual error più facil commett lavor string c risult esser piuttost insid poic non veng rilev compil ? </question_text><answer id="A2360"><answer_text>l&#39; error più difficil individu è l&#39; omission simbol &#34; &#38; &#34; quand si acquis tastier tram scanf. compil non ril com error , programm smett funzion moment incontr . bisogn sempr ricord prim posizion string corrispond valor 0 dell&#39; indic , l&#39; ultim valor n-1 : l&#39; spaz serv infatt simbol &#34; \0 &#34; indic termin string . e&#39; facil dimentic inser &#34; \0 &#34; string quand quest vien inizializz manual (ad esemp cicl for whil ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2504"><answer_text>error più facil commett è omett i dopp apic all&#39; iniz string . omett programm non dar error memorizz com variabil . </answer_text><num_votes>0</num_votes></answer><answer id="A2356"><answer_text>l&#39; error più difficil individu è l&#39; omission simbol &#34; &#38; &#34; quand si acquis tastier tram scanf. compil non ril com error , programm smett funzion moment incontr . bisogn sempr ricord prim posizion string corrispond valor 0 dell&#39; indic , l&#39; ultim valor n-1 : l&#39; spaz serv infatt simbol &#34; \0 &#34; indic termin string . e&#39; facil dimentic inser &#34; \0 &#34; string quand quest vien inizializz manual (ad esemp cicl for whil ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2524"><answer_text>string è compost caratter , non bisogn inser &#34; &#38; &#34; com scanf. non ten cont l&#39; ultim posizion string caratt è occup da&#34; \o &#34; . string numer compost n element , dimentic element vettor nomin 0 n-1 . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2533"><question_text>qual different esist l&#39; istruzion condizional &#34; if &#34; l&#39; istruzion iter (cicl ) &#34; whil &#34; ? </question_text><answer id="A2497"><answer_text>if (espression ) { istruzione_1 ; } else{istruzione_2 ; } esegu l&#39; istruzion un&#39; unic volt , volt valut l&#39; espression , quest risult ver . altriment , vien esegu l&#39; istruzione_2 , present . mancanz { } , if innest , part else vien abbin sempr all&#39; ultim if post blocc . whil (espression ) { istruzion ; } rip l&#39; istruzion fintant l&#39; espression non risult fals . </answer_text><num_votes>1</num_votes></answer><answer id="A2390"><answer_text>if val condizion qual , soddisfatt , svolg comp assegn sol volt mentr whil continu svolg finc condizion assegn non è più ver . esemp assegn condizion i&#60;10 i=5 l&#39; istruzion if svolg comp sol volt (o mai i&#62;10 ) mentr whil continu farl all&#39; infin men valor i non camb assum valor maggior 10 (o com if non svolg nessun comp i&#62;10 già partenz ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2412"><answer_text>entramb costrutt controll fluss programm , utilizz esegu sottoprogramm verific determin condizion . costrutt &#34; if &#34; preved l&#39; esecu sottoprogramm esso assoc sol volt mett disposizion &#34; second scelt &#34; , ovver sottoprogramm esegu cas condizion dell&#39; &#34; if &#34; non veng rispett . costrutt &#34; whil &#34; , , implement cicl consent esegu sottoprogramm assoc piu&#39; segu , quand condizion ingress cicl vien rispett . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2529"><question_text>qual&#39; è different oper increment x++ ++x ? val mod i oper decrement x -- --x ? </question_text><answer id="A2430"><answer_text>consider x variabil tip inter l&#39; espression x++ ved l&#39; increment x 1 denot prim dell&#39; increment , mentr cas ++x si sempr l&#39; increment 1 , denotaziin vien effettu dop l&#39; increment . esemp : x=5 ; printf ( &#34; % d &#34; , x++ ) ; // cas vide verr stamp valor x prim dell&#39; increment , ossi 5 . //in istant x com valor 6 . printf ( &#34; % d &#34; , ++x ) ; // stamp vide valor x dop l&#39; increment , ossi 7 analog val x -- --x dell&#39; increment 1 si decrement un&#39; unit . </answer_text><num_votes>0</num_votes></answer><answer id="A2470"><answer_text>different oper increment x++ ++x sta valut valor x prim dop l&#39; increment . val i oper decrement . &#34; x++/x -- &#34; signif &#34; val x poi incrementa/decrement valor &#34; . &#34; ++x/--x &#34; signif &#34; incrementa/decrement x poi valutan valor &#34; . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2415"><question_text>cos&#39; è serv getc ( ) ? com si leg eof ? </question_text><answer id="A2501"><answer_text>getc ( ) è funzion standard library , richiam l&#39; #includ , consent lettur standard input caratt poi restitu com inter . eof sta end of fil , cio fil è valor particol vien ritorn funzion getc ( ) quand vien raggiunt fil , cio quand non più dat input . </answer_text><num_votes>0</num_votes></answer><answer id="A2418"><answer_text>getc ( ) è un&#39; istruzion permett legg l&#39; input buffer . a=getc ( ) ; legg caratt buffer assegn variabil . l&#39; eof (end of fil ) è caratt special segn input caratter , serv compil controll quand fin fas input proced sezion success programm </answer_text><num_votes>0</num_votes></answer><answer id="A2407"><answer_text>funzion getc ( ) serv legg caratter tastier salv com inter all&#39; intern variabil , all&#39; occorrent stampabil attravers com putc ( ) . eof (end of files ) è special com (ctlr+z ) defin com un&#39; inter fil &#39;stdi .h &#39; , non utilizz variabil tip char , risult util funzion getc ( ) dat i valor lett veng salv com inter . es : #includ &#60;stdi .h&#62; /* cop l&#39; input nell&#39; output termin ctrl+z*/ main ( ) { int c; whil ( ( c = getc ( ) ) != eof ) putc (c ) ; } </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2481"><question_text>definizion array . c com si acced precis cell array ? </question_text><answer id="A2486"><answer_text>informat array &#34; vettor &#34; è struttur dat compless , static omogene , usat linguagg programm chiar ispir nozion matemat vettor , (o matric , cas array bidimensional ) .l&#39; array è inoltr classific com costruttor tip : ovver , esso consent defin tip dat part (com aggreg valor ) tip preesistenti.in c si acced precis cell array tram l&#39; indic &#34; i &#34; , es : a[i ] . infin pot utilizz bisogn dichiar , es : int a[10 ] . </answer_text><num_votes>1</num_votes></answer><answer id="A2409"><answer_text>l&#39; array c è meccan permett costru tip dat i element sequenz omogene valor appartenent unic tip . acced cell tip array si può cos : int string [12 ] ; string [6 ] punt 5 element string (se string [n ] punt n-1 ) avrà valor inter tip int. </answer_text><num_votes>0</num_votes></answer><answer id="A2359"><answer_text>acced precis cell array bisogn specific identif l&#39; array numer è l&#39; indic cell seguent sint : nomearray [indic ] ; ricord indic cell part zer poss esser sol posit . cas array bidimensional , , indic sarann : nomearray [indice ] [indiceb ] ; </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2485"><question_text>qual è numer massim cell array ? dev&#39; esser sempr inclus tip atruttur compless ? </question_text><answer id="A2471"><answer_text>int list [20 ] ; list è array 20 element omogene tip ciascun element è int. i 20 element ordin access graz valor indic precis posizion dell&#39; element si desider consider . variabil verr usat com indic indic l&#39; element dell&#39; array esser tip integral;l&#39; indic var 0 valor racchius [ ]-1 . array dimension fiss , infatt dimension dell&#39; array esser costant inter , estrem variabil indic dell&#39; array non poss camb durant l&#39; esecu programm . </answer_text><num_votes>0</num_votes></answer><answer id="A2419"><answer_text>quand vien defin un&#39; array si decid numer cell esso destin , ricord i valor numer prim cell è dedic valor 0 quell tip char l&#39; ultim è dedic &#34; \0 &#34; . part fondamental è l&#39; indic , consent individu var cell dell&#39; array . </answer_text><num_votes>0</num_votes></answer><answer id="A2502"><answer_text>numer massim cell array e&#39; indic dall&#39; utent e&#39; defin all&#39; iniz programm , cio &#39; comport l&#39; impossibil &#39; modific success . cas array caratter numer element conten e&#39; n+1 . tip struttur compless esser sempr inclus caratt special null . </answer_text><num_votes>0</num_votes></answer><answer id="A2482"><answer_text>line teoric array può occup tutt memor disposizion ram , esser funzional conten numer limit element (non i 100 ) . moment dichiar è indispens indic quant cell sar compost numer costant defin prim main . bisogn ricord tuttav cas array caratter (string ) l&#39; ultim cell dovr esser riserv caratt null &#39;\0 &#39; indic string ; inoltr cell veng numer indic part 0 non 1 . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2433"><question_text>perc linguagg c , nonost invent decin anni fa è complet utilizz , almen alcun camp ? </question_text><answer id="A2473"><answer_text>linguagg c vien utilizz perc efficac efficient . livell med astrazion è possibil gest memor manier dirett . rientr linguagg compil (di tip strong typing ) è utilizz svilupp sistem oper modern è inoltr portabil macchin real all&#39; altra . linguagg c è implement c++che offre librer più ampi programm oggett . inoltr è prefer , nell&#39; industr nell&#39; accadem , possibil realizz progett compless . </answer_text><num_votes>1</num_votes></answer><answer id="A2509"><answer_text>linguagg c è utilizz perc è linguagg flessibil vicin macchin , usat svilupp unix sistem oper più modern com windows mac os x . caratterist import linguagg c è indipendent dall&#39; hardw , cio i codic portabil macchin real un&#39; altra . </answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L31" title="Istruzioni Condizionali, Array" date="2013-10-11"><question id="QQ2702"><question_text>qual mot non si può oper l&#39; assegn array ? ( esemp si array inter x y , non si può scriv x=y ) </question_text><answer id="A2633"><answer_text>non si può oper l&#39; assegn array , cio dat array b , è error scriv a=b , poic array è sequenz cell consecut omogene . otten array ugual bisogn esegu cicl for , grad assegn element dell&#39; array . esemp dat a[dim ] , b[dim ],i dovr scriv : int a[dim ] ; int b[dim ] ; int i; for(i=0;i&#60;dim;i++ ) { b[i ] =a [i ] ; } mod otteng vettor ugual ogni element . </answer_text><num_votes>1</num_votes></answer><answer id="A2580"><answer_text>array corrispond blocc memor compost tant locazion quant lunghezz dell&#39; array . mot si può acced singol element array utilizz indic corrispond posizion cell memor dell&#39; array . cop l&#39; inter conten array è necessar utilizz cicl (per esemp cicl for ) si individu ogni valor tram l&#39; indic cicl . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2744"><question_text>perc &#39; prim scrittur risult miglior second nonost risult ? 1 . if (a&#62;b ) printf ( &#34; maggior b \n &#34; ) ; else if (a&#60;b ) printf ( &#34; b maggior \n &#34; ) ; else printf ( &#34; ugual b \n &#34; ) ; 2 . if (a&#62;b ) printf ( &#34; maggior b \n &#34; ) ; if (a&#60;b ) printf ( &#34; b maggior \n &#34; ) ; if (a==b ) printf ( &#34; ugual b \n &#34; ) ; </question_text><answer id="A2694"><answer_text>prim &#34; scrittur &#34; è prefer second perc utilizz if-els nidific , opportun utilizz parentes , permett otten &#34; scrittur &#34; più semplic leggibil parit risult . </answer_text><num_votes>1</num_votes></answer><answer id="A2636"><answer_text>prim è miglior perc rend codic più leggibil capibil lettor , perc if-els si un&#39; unic istruzion (if-els ) second istruzion (els ) non serv compost cio abbi anch&#39; essa condizion perc entra gioc quand condizion if è fals . cas semplif programm . </answer_text><num_votes>1</num_votes></answer><answer id="A2610"><answer_text>perc second scrittur ogni cas veng valut tutt condizion ogni cas , mentr è ver prim non veng valut . è ver second veng valut prim è ver l&#39; ultim veng valut tutt . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2611"><question_text>different c&#39; è nell&#39; incolonn più istruzion condizional sequenz comporr più istruzion condizional nidific ? </question_text><answer id="A2639"><answer_text>comporr istruzion condizional nidific è men leggibil part dell&#39; oper , struttur vien elabor esegu più veloc . un&#39; istruzion nidific è esemp : if ( ... ) { ... } else if ( ... ) { ... } un&#39; istruzion condizional incolonn è struttur più leggibil (e più semplic scriv ispezion manual ) , più lent nell&#39; esecu . esemp struttur incolonn è : if ( ... ) { ... } if ( ... ) { ... } </answer_text><num_votes>3</num_votes></answer><answer id="A2565"><answer_text>cas bisogn star attent non veng introdott variabil istruzion potrebber modific signific istruzion condizional , second opzion si preved men dispersion istruzion men possibil error , inoltr si manifest error , ricerc risult più semplic immed . </answer_text><num_votes>1</num_votes></answer><answer id="A2622"><answer_text>un&#39; istruzion condizional consent esegu divers sequenz istruzion bas valor verit condizion . e&#39; costitu if , segu blocc istruzion cas ver , else , cas fals (che può manc ) . si più istruzion incolonn , si avra &#39; if segu else , ecc . si istruzion nidific , prim ram else prim istruzion pon un&#39; altra istruzion condizional . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2618"><question_text>succed quand si cerc inser più dat quant poss conten array (cos&#39; è l&#39; overflow ) ? </question_text><answer id="A2671"><answer_text>inser numer maggior dat numer cell conten nell&#39; array , cio sto andand scriv zon memor fuor dell&#39; array , i dat verrann semplic pers . siccom cell dov scritt i dat , non access . è pericol siccom è possibil andar modific involontar cell memor (cos evit ! ) . tip error vien usual commess quand si pens prim cell dell&#39; array indic 1 , realt prim cell indic 0! ! ! ! ! </answer_text><num_votes>2</num_votes></answer><answer id="A2741"><answer_text>spess non &#34; sprec &#34; cell memor veng usat array dimension conten , oppur si diment l&#39; ultim cell utilizz array n element è quell posizion n-1 può accad veng inser più dat quant array poss conten . cas compil non trov quantit cell necessar dov poter immagazzin tutt i dat risc perd dat e/o modific cell memor compromett memor calcol . molt i calcol si trov quest situazion blocc l&#39; esecu programm . </answer_text><num_votes>1</num_votes></answer><answer id="A2703"><answer_text>quand l ?array è dichiar , compil alloc blocc memor conten l ?array ;se c è vettor n element element è posizion 0 l&#39; posizion n-1.il c non effettu alcun controll lim array . parol è possibil inizializz array dimension n più n valor alcun messagg error compil ; è comp programm garant tutt array sian abbast grand conten ciò cre </answer_text><num_votes>0</num_votes></answer><answer id="A2729"><answer_text>i dat verrann scritt cell memor seguent , qual non essend stat riserv l&#39; array potreber conten dat variabil , provoc risult inaspett . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2670"><question_text>caratterizz array caratter ? </question_text><answer id="A2588"><answer_text>array n caratter può esser usat memorizz string più cort . cas , cell k-esim (k essend lunghezz string ) concettual vuot : pratic inutilizz conteng valor casual . array tip caratt esser sempr racchius virgolett semplic , esemp : ?a ? . array numer inter real , poss defin array caratteri; esemp : char s[ ]={ &#39; c &#39; , &#39;i &#39; , &#39;a &#39; , &#39;o &#39; } dov s è array caratter form 4 element : s[0 ] = &#39;c &#39; ; s[1 ] = &#39;i &#39; ; s[2 ] = &#39;a &#39; ; s[3 ] = &#39;o &#39; ; </answer_text><num_votes>0</num_votes></answer><answer id="A2630"><answer_text>array caratter (char ) puo&#39; esser utilizz rappresent string , cioe&#39; succession caratter , com es . &#34; world &#34; ; tip array e&#39; caratterizz dall&#39; esistent vincol consistent fatt l&#39; ultim posizion dell&#39; array conten valor special null ( &#34; \0 &#34; ) . tal valor serv var funzion manipol string cap dov fin string . numer caratter necessar memorizz string n caratter e&#39; n+1 ; es . memorizz string &#34; world &#34; (5 caratter ) si inizializz array 6 caratter (5+null ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2587"><answer_text>array n caratter può esser usat memorizz string più cort . cas , cell k-esim (k essend lunghezz string ) concettual vuot : pratic inutilizz conteng valor casual . array tip caratt esser sempr racchius virgolett semplic , esemp : ?a ? . array numer inter real , poss defin array caratteri; esemp : char s[ ]={ &#39; c &#39; , &#39;i &#39; , &#39;a &#39; , &#39;o &#39; } dov s è array caratter form 4 element : s[0 ] = &#39;c &#39; ; s[1 ] = &#39;i &#39; ; s[2 ] = &#39;a &#39; ; s[3 ] = &#39;o &#39; ; </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2729"><question_text>unic array può conten variabil tip divers (int , float , char ecc... ) ? perc ? </question_text><answer id="A2625"><answer_text>unic array non può conten variabil tip divers , perc altriment non sarebb array non avrebb funzion corrett . definizion sapp array è variabil struttur contenent insiem valor tutt tip (omogene ) , individu unic collett (identif ) ; utilizz variabil int non poss utilizz variabil tip char . </answer_text><num_votes>1</num_votes></answer><answer id="A2606"><answer_text>no; array c definizion è insiem più dat omogene insiem dat tip . infatt definizion array linguagg programm [per esemp &#34; int array[n ] &#34; ] si necess primis scriv l&#39; unic tip dat l&#39; array può conten . ovvi è possibil array tutt i tip dat bas non ; quell &#34; cre &#34; programm , i qual volt poss esser non omogene conten dat tip different (ved typedef ) . l&#39; array rest comunqu omogen perc a[0 ] ,a [1 ] , ecc tutt ugual . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2673"><question_text>valut espression , si intend &#34; associat &#34; ? qual cas utilizz divent fondamental ? </question_text><answer id="A2740"><answer_text>associat si intend valut più espression oper bolean , ovver cas different , com esemp valut numer è compres intervall . </answer_text><num_votes>0</num_votes></answer><answer id="A2627"><answer_text>associat si intend direzion bisogn valut oper (da destr sinistr sinistr destr ) . divent import quand bisogn valut un&#39; espression contenent div oper (+ ,&#38; , ! ,++,etc ... ) . esemp l&#39; oper assegn (= ) è right-assoc cio assegn valor dell&#39; espression destr c&#39; è sinistr (right to left ) . oper left-assoc (left to right ) com oper + ,&#62; , || , valut si effettu part sinistr . </answer_text><num_votes>0</num_votes></answer><answer id="A2648"><answer_text>linguagg c defin : - precedent oper , qual cert oper maggior priorit ; - associat , ovver ordin oper div , avent stess priorit , veng assoc . utilizz divent fondamental cas non veng modific l&#39; ordin valut dell&#39; espression , attravers l&#39; utilizz parentes . </answer_text><num_votes>0</num_votes></answer><answer id="A2693"><answer_text>l&#39; associat defin vers compil val espression , cio sinistr destr oppur destr sinistr . divent fondamental l&#39; utilizz quand un&#39; espression present oper grupp precedent , mod sap qual ordin oper verrann svolt . esemp : a+b-2 ; l&#39; espression vien esegu sinistr vers destr , (a+b ) success risult vien sottratt 2 . </answer_text><num_votes>2</num_votes></answer><answer id="A2553"><answer_text>associat si intend procedur assegn vers valut espression (da sinistr destr ) . divent fondamental quand valut oper grupp . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2668"><question_text>quand luog error segment ? può verific linguagg c ? </question_text><answer id="A2637"><answer_text>l&#39; error segment luog quand programm tent acced posizion memor qual non è permess acced , oppur tent acced manier impropr . error si verif spess linguagg c; esemp quand rifer puntator manier errat : char *s= &#34; string &#34; ; /*puntator string posizion segment sol lettur dell&#39; esegu , quand si esegu programm sol s.o. mapp zon sol lettur , imped modifica*/ *s=&#39;a &#39; ;/*tent scriv memor sol lettur caus errore*/ </answer_text><num_votes>3</num_votes></answer><answer id="A2726"><answer_text>error segment luog quand programm tent acced posizion memor qual non è permess accedere,quest può accad spess cas array l&#39; error può verific c . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2765"><question_text>e&#39; possibil modific grandezz array moment , dop averl dichiar ? </question_text><answer id="A2666"><answer_text>linguagg c non è possibil modific dimension array dop averl dichiar , poic macchin riserv fisic spaz precis memor . per non confus l&#39; alloc dinam memor , dov comunqu dimension dell&#39; array vien determin fas esecu . </answer_text><num_votes>4</num_votes></answer><answer id="A2561"><answer_text>, non è possibil modific grandezz un&#39; array , sebben esist array dinam lunghezz dell&#39; array è defin un&#39; espression variabil , consent bypass problem inizial non conosc grandezz l&#39; array </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2612"><question_text>l&#39; istruzion : int [3 ] = {1 , 2 } ; provoc error ? valor conten a[0 ] a[1 ] a[2 ] ? </question_text><answer id="A2730"><answer_text>, l&#39; istruzion è corrett verr esegu error . tuttav essa vien dichiar array 3 element , i prim inizializz . mot , mentr a[0 ] sar = 1 a[1 ] = 2 , a[3 ] rimarr valor apparent casual , ovver conten cell memor dedic tal variabil . </answer_text><num_votes>2</num_votes></answer><answer id="A2555"><answer_text>quest istruzion non provoc error . prim element dell&#39; array assegn element compres parentes graff , mentr element non è assegn è valor qualsias era già conten all&#39; intern cell memor alloc element . </answer_text><num_votes>1</num_votes></answer><answer id="A2683"><answer_text>quest istruzion non provoc error quant semplic si assegn 2 valor array 3 valor , cio &#39; signif a[3 ] non e&#39; inizializz . infatt a[0 ] =1 , a[1 ] =2 a[2 ] avra &#39; valor casual quant e&#39; locazion memor non inizializz </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2626"><question_text>spieg different costrutt &#34; if &#34; costrutt &#34; if-els &#34; . </question_text><answer id="A2692"><answer_text>costrutt &#34; if &#34; vien utilizz situazion è necessar verific condizion è ver . costrutt &#34; if-els &#34; , permett verific condizion è ver cas fals , esegu blocc istruzion . </answer_text><num_votes>5</num_votes></answer><answer id="A2581"><answer_text>costrutt if possibil &#39; controll sol condizion costrutt if-els possibil verific condizion . nell&#39; if-els verific condizion postagl si andra &#39; esegu com normal if , non verific essa si andra &#39; esegu codic else permett implement if-els nidific esso , mod tal riusc ricopr n condizion . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2782"><question_text>mod si può increment precedent all&#39; intern un&#39; espression ? </question_text><answer id="A2597"><answer_text>non sens parl &#34; increment &#34; precedent , espression , si può per modific natural ordin precedent oper l&#39; uso parentes . </answer_text><num_votes>1</num_votes></answer><answer id="A2680"><answer_text>si può increment precedent all&#39; intern un&#39; espression utilizz l&#39; oper &#34; + &#34; apparten grupp addit . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2784"><question_text>com veng valut espression ? oper tip com si comport ? </question_text><answer id="A2706"><answer_text>espression veng valut com val matemat ; esist precedent quest poss esser modific tram l&#39; utilizz ( ) . quand oper si tratt &#34; oper increment decrement &#34; : essi rispett aument diminu l&#39; unic oper prend . rappresent ++ -- ; quest poss esser utilizz prim , dop variabil (a=--x , a=x -- ) rispett signif : x vien decrement prim valor veng cop , vien prim cop valor x poi vien increment valor x </answer_text><num_votes>0</num_votes></answer><answer id="A2710"><answer_text>espression veng valut bas all&#39; ordin precedent : oper suddivis grupp caratterizz precedent , veng valut prim quell precedent superior success quell precedent inferior . cas oper appartenent grupp precedent vien utilizz propriet assoc determin vers valut (da destr sinistr ) . l&#39; ordin precedent può esser modific utilizz parentes ( ) usat aument leggibil espression . </answer_text><num_votes>2</num_votes></answer><answer id="A2620"><answer_text>tutt oper si poss trov un&#39; espression suddivis grupp caratterizz precedent . quell precedent superior veng valut prim quell precedent inferior . cas oper grupp precedent vien utilizz l&#39; &#34; associat &#34; , determin vers valut (da destr sinistr ) . cio vien dat più import , second grupp , all&#39; oper sta più destr sinistr . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2629"><question_text>qual è different array matric ? </question_text><answer id="A2566"><answer_text>matric è sottocas array ; array è vettor può più dimension ; array 2 dimension corrispond propr matric . </answer_text><num_votes>0</num_votes></answer><answer id="A2568"><answer_text>different sta array è struttur dat compless monodimensional matric è &#34; array array &#34; , cio struttur dat bidimensional . </answer_text><num_votes>0</num_votes></answer><answer id="A2614"><answer_text>array è struttur dat form sequenz cell consecut omogene , contenent cio variabil (un cell ) tip . matric è semplic array multidimensional (soprattutt bidimensional ) , rifer nozion matemat matric . different sta fatt matric (o più ) indic (ogn indic è dimension ) ogni element è identific combin valor tutt indic vettor . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ2658"><question_text>elenc i mod è possibil inizializz array . </question_text><answer id="A2646"><answer_text>array può esser inizializz fas dichiar seguent mod (nell&#39; esemp array inter ) : int array[5 ] ={1 ,-4 ,6,5,0 } ; mod ciò consist nell&#39; utilizz cicl for , oppur whil , magar funzion rand ( ) assoc var element costituent l&#39; array numer casual : int i; srand(time(0 ) ) ; for (i=0;i&#60;5 ;i++ ) { array [i ] =rand ( ) ; } </answer_text><num_votes>1</num_votes></answer><answer id="A2679"><answer_text>array può esser inizializz mod : esplicit durant creazion tram costant inizializz dat , oppur durant l&#39; esecu programm tram assegn inser dat all&#39; intern dell&#39; array . </answer_text><num_votes>0</num_votes></answer><answer id="A2684"><answer_text>inizializz array signif assegn ciascun element valor . tal oper è effettu moment l&#39; array vien dichiar , esemp tram l&#39; istruzion : &#39;&#39; int array[4 ] = {3 ,9,1,7 } &#39;&#39; . oppur è effettu all&#39; intern programm tram l&#39; ausil cicl com whil for. esemp è : int array [6 ] ; int i; for(i=0 ; i&#60;6 ; i++ ) { array [i ] = rand ( ) % ( max-min+1 ) + min } esemp assegn valor casual , compres valor massim (max ) minim (min ) , ogni element dell&#39; array . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2637"><question_text>si intend array multidimensional ? </question_text><answer id="A2711"><answer_text>ambient c si prim tutt pens array dimension e&#39; array monodimensional i element volt array . premess ciò , array multimensional si poss utilizz costru matric grigl . esemp a[2 ] [3 ] defin array bidimensional 2x3 vien organizz com rettangol : a[0 ] [0 ] a[0 ] [1 ] a[0 ] [2 ] a[1 ] [0 ] a[1 ] [1 ] a[1 ] [2 ] vien util ricord c conserv n cell righ comunqu numer 0 n-1 . </answer_text><num_votes>0</num_votes></answer><answer id="A2600"><answer_text>array multidimensional è array qualsias numer dimension è intend com array array . util cre matric . esemp array tip : int matric [n ] [ m ] (con n m costant ) rappresent array multidimensional (bidimensional ) identif matric ( inter ) n righ m colonn . </answer_text><num_votes>0</num_votes></answer><answer id="A2546"><answer_text>c si poss defin array bidimensional : int a[n ] [ m ] corrispond matric 10 righ 5 colonn ,è possibil usar array più dimension aggiung copp più parentes quadr : float a[10 ] [5 ] [20 ] .il calcol comunqu memorizz tutt mod lineare,un dop l&#39; altra . </answer_text><num_votes>0</num_votes></answer><answer id="A2659"><answer_text>array multidimensional (ò n-dimensional ) pratic array contenent n-element volt si present sottoform array . c mod si poss rappresent facil matric tabell i element apparteng tutt tip : int nomearray[ ] [ j ] inoltr pass array multidimensional funzion bast indic numer colonn dat i element memorizz ram rig rig : int f(int a[ ] [35 ] ) { .. } pertant l&#39; eccess memor richiest si sconsigl l&#39; utilizz array più 3 indic (ò dimension ) </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2783"><question_text>scriv un&#39; espression permett otten numer righ array multidimensional utilizz funzion sizeof ( ) . </question_text><answer id="A2674"><answer_text>#defin dim 20 int main ( ) { int ar[dim ] [dim ] [dim ] ; int righ ; righe=sizeof( ) / sizeof(ar[0 ] ) ; //n°cell alloc l&#39; inter array/n°cell alloc rig printf ( &#34; nr righe=% d\n &#34;, righ ) ; system ( &#34; paus &#34; ) ; return 0 ; } </answer_text><num_votes>2</num_votes></answer><answer id="A2708"><answer_text>funzion sizeof ( ) serv conosc lunghezz un&#39; array static , è possibil ricav dimension un&#39; array multidimensional (conosc com matric ; esemp : matt [ ] [ ] ) indic funzion rig specif . esemp : righ = sizeof(matt [ ] ) / sizeof(matt[ ] [0 ] ) ; </answer_text><num_votes>3</num_votes></answer><answer id="A2658"><answer_text>int a[17 ] ; int n = sizeof( ) ; essend int 4 byte n sar ugual 68 . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2675"><question_text>si intend &#34; condizion &#34; (o &#34; espression boolean &#34; ) è costitu ? </question_text><answer id="A2650"><answer_text>un&#39; espression boolean è un&#39; espression può com risult soltant ver fals . essa è compost proposizion (ver fals ) qual si applic oper logic and , or not . nell&#39; espression , dop aver risolt parentes , not precedent and or , and precedent or . </answer_text><num_votes>0</num_votes></answer><answer id="A2641"><answer_text>&#34; condizion &#34; si intend fattor fondamental determin funzion costrutt qual : if-els , whil , for ecc ... condizion è solit compost variabil , costant oper tip : &#60;= , == , &#62;= ecc ... condizion (es : == b ) vien soddisfatt , solit programm pass all&#39; istruzion success , altriment rip cicl salt line codic . </answer_text><num_votes>0</num_votes></answer><answer id="A2736"><answer_text>?espression boolean è ?espression oper i valor binar 0 1 (rispett fals ver ) . oper veng utilizz ?algebr bool not (oper unar ) , and or (oper binar ) ; quest oper ?amb linguagg programm si traduc i caratter ! (not ) , &#38;&#38; (and ) , || (or ) . oper segu precis ordin precedent god propriet commut , assoc distribut nonc idempotent (a+a= ) element neutr (a+0= ) ; si avvalg inoltr legg de morgan . </answer_text><num_votes>5</num_votes></answer><answer id="A2567"><answer_text>un&#39; espression boolean è espression restitu com valor ver fals (1 0 , si ecc . ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2612"><answer_text>espression boolean è tip espression può restitu valor , vero(1 ) fals (0 ) , verific men dat condizion . essa è costitu condizion , verif risult . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2715"><question_text>volt defin un&#39; array , è possibil var dimension ? si com ? </question_text><answer id="A2634"><answer_text>si , è possibil var dimension array dop averl defin . ciò è necessar defin array tram variabil puntator . mod è possibil var dimension dell&#39; array durant programm semplic gest puntator assegn all&#39; array . </answer_text><num_votes>1</num_votes></answer><answer id="A2602"><answer_text>l&#39; array trov spaz memor esecu non compil , spaz dimension anch?ess not durant l&#39; esecu , si può modific l&#39; indic dell&#39; array dichiar inizial .bast sostitu valor d&#39; array parentes quadr . </answer_text><num_votes>1</num_votes></answer><answer id="A2731"><answer_text>sì è possibil , è necessar defin l&#39; array dichiar puntator element , esprim dimension funzion &#34; malloc ( ) &#34; , esemp : int *v ; v=malloc(10*sizeof(int ) ) ; compil riserv spaz memor atto conten array 10 element inter part dall&#39; indic punt &#34; v &#34; . var dimension è necessar &#34; rialloc &#34; , ovver spost altra zon memor spaz sufficient conten (se rest dov&#39; è scrivess cell sucess sporc memor ) , : v=realloc(v ,20*sizeof(int ) ) ; (+10 elem ) </answer_text><num_votes>2</num_votes></answer><answer id="A2744"><answer_text>normal dimension array è defin tram costant memor vien alloc durant fas compil . utilizz i puntator funzion malloc ( ) , per , è possibil cre vettor dimension poss esser defin fas esecu particol puntator si assegn puntator valor malloc(x*sizeof(typ ) ) ; x=numer element (defin input ) type=tip element quel puntator sar effett vettor x element tip &#34; type &#34; , x defin fas esecu </answer_text><num_votes>0</num_votes></answer><answer id="A2653"><answer_text>volt defin array , è sempr possibil modific dimension , esser costant inter , maggior zer , racchius all&#39; intern copp parentes quadr , scritt immediat destr dell&#39; identif dell&#39; array . infatt , moment dichiar tal array , var dimension bast semplic modific valor costant racchius parentes quadr ; esemp , array 20 element , array[20 ] , ridurr propr dimension 10 element , trov scritt array[10 ] . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2671"><question_text>esist numer massim cell array ? </question_text><answer id="A2675"><answer_text>si , poic memor non è illimit . </answer_text><num_votes>0</num_votes></answer><answer id="A2691"><answer_text>c non esist numer massim cell array , quant si può continu rend sempr più grand estes propr array , continu alloc memor ; avessim memor infin avremm infin numer cell array . </answer_text><num_votes>3</num_votes></answer><answer id="A2645"><answer_text>esist numer massim cell erray dip dimension ram . </answer_text><num_votes>0</num_votes></answer><answer id="A2643"><answer_text>esist numer massim cell erray dip dimension ram . </answer_text><num_votes>1</num_votes></answer><answer id="A2644"><answer_text>esist numer massim cell erray dip dimension ram . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2625"><question_text>linguagg programm c è &#34; cas sensit &#34; ? si intend &#34; cas sensit &#34; ? </question_text><answer id="A2662"><answer_text>signif semplic distingu lett maiuscol minuscol : int x ; int x ; si può , perc x x variabil distint ! </answer_text><num_votes>0</num_votes></answer><answer id="A2608"><answer_text>si dic cas sensit ogni oper analis test distingu parol ugual bas all&#39; uso lett maiuscol minuscol . linguagg c riesc identific divers lett maiuscol minuscol . risult import , esemp , cas password , res sensibil affinc più difficil risal tentat </answer_text><num_votes>1</num_votes></answer><answer id="A2584"><answer_text>linguagg c è &#34; cas sensit &#34; , cio veng distint i caratter maiuscol quell minuscol . conseguent parol caratter minuscol (o rispett maiuscol ) avrann signific different quell caratt maiuscol ( rispett minuscol ) , pur avend medesim lett . </answer_text><num_votes>0</num_votes></answer><answer id="A2558"><answer_text>si intend linguagg è grad riconosc maiuscol minuscol . perc 2 variabil inizializz maiuscol l&#39; altra minuscol sarann divers occup porzion memor different . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2698"><question_text>quand è possibil utilizz com switc ( ) post sequenz if ( ) ? </question_text><answer id="A2695"><answer_text>l&#39; istruzion if ( ) è costru scegl l&#39; esecu un&#39; istruzion altern un&#39; altra second valor cert condizion . cas per altern scegl poss esser moltepl ognun possibil caratter dev esser esegu azion divers . tratt cas gen costrutt if ( ) può risult tedios innatural . vien utilizz com switc ( ) , struttur controll tip selett . </answer_text><num_votes>1</num_votes></answer><answer id="A2678"><answer_text>quand lavor valor un&#39; unic variabil poss sostitu if ( ) switc ( ) . infatt scriv if (a=3 ) { printf ( &#34; a=3 &#34; ) ; } ; else if (a=4 ) { printf ( &#34; a=4 &#34; ) } ; qiest cas si esegu istruzion specific second valor variabil , avrebb più sens , esemp , ver fals . blocc if è equivalent seguent switc ( ) { cas 3 : printf ( &#34; a=3 &#34; ) ; cas 4 : printf ( &#34; a=4 &#34; ) ; break; } . cas avevam possibil , switc può risult comod quand numer numer cas aument . </answer_text><num_votes>0</num_votes></answer><answer id="A2560"><answer_text>com switc vien utilizz quand si ristrett rang possibil soluzion . mentr if si verif condizion è ver fals , switc si val condizion funzion risult otten veng esegu determin istruzion . switc inoltr contien com break , inser blocc istruzion . utilizz fa avanz oper success , altriment torn valut cas si è possibil impost switc . cas switc si può inser com default inglob rest </answer_text><num_votes>0</num_votes></answer><answer id="A2737"><answer_text>l&#39; utilizz costrutt &#34; switc &#34; è comod sostitu ser comand &#34; if &#34; . mentr l&#39; &#34; if &#34; verif condizion è ver fals , &#34; switc &#34; , dat condizion , verif più cas relat essa . per &#34; switc &#34; può esser utilizz alcun cas , : - vien valut variabil - ogni valor variabil utilizz determin sol istruzion . dell&#39; istruzion esegu , &#34; break &#34; determin l&#39; uscit costrutt &#34; switc &#34; . scelt final , &#34; default &#34; , determin l&#39; oper esegu qualor nessun cas foss rispett . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2632"><question_text>perc volt dichiar array non è più possibil var dimension ? </question_text><answer id="A2676"><answer_text>array static , volt dichiar grandezz dell&#39; array , compil riserv spaz memor necessar memorizz quest&#39; (cos com farebb ogni altra variabil dichiar ) non è più possibil modific segu . array dinam sar possibil modific dinam dimension . </answer_text><num_votes>4</num_votes></answer><answer id="A2722"><answer_text>non è possibil dichiar array , anzi , gen non è possibil dichiar un&#39; altra volt stess variabil . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2655"><question_text>memorizz string qual sostanzial different l&#39; utilizz com scanf ( ) com gets ( ) ? quand convien utilizz all&#39; altra ? </question_text><answer id="A2577"><answer_text>funzion gets è utlizzz legg strig tip char contenet caratter . è usat poi funzion gets legg tutt i caratter caratt &#34; \0 &#34; conten string , altriment scanf interromp lettur string quand inser esemp &#34;a -cap &#34; . convien utilizz com gets string tip char funzion scanf string numer . </answer_text><num_votes>0</num_votes></answer><answer id="A2647"><answer_text>scanf ( ) legg caratter tastier singol parol non è possibil memorizz un&#39; inter rig form più parol (non compr spaz ) . gets ( ) legg caratter standard input quand non incontr caratt newlin fil (eof ) inser com caratt caratt null ( &#39; \0 &#39; ) . convien utilizz gets memorizz inter righ , scanf, , singol parol . scanf ( ) inoltr ammett array tutt tipolog dat (purc all&#39; intern dell&#39; array sian present dat tip ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2670"><answer_text>gets ( ) permett inser più parol all&#39; intern string , legg fil stdin caratt nuov line fil , termin automat caratt string &#34; \0 &#34; . utilizz com scanf ( ) , contrar , non è possibil acquis più parol (in quant caratt spaz vien consider com valor string veng manten fil stdin eventual rimanent parol ) . gets è sempr convenient memorizz string caratter , scanf è prefer singol parol necessar tip dat . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2755"><question_text>variabil tip array contien indirizz cell memor oppur conten ? perc ? </question_text><answer id="A2591"><answer_text>array non è tip costruttor tip . dichiar esemp l&#39; array tip inter int array[10 ] si predisporrann memor 10 cell , 0 9 , dov l&#39; array funzion propr com puntator 10 cell predispost memor tip inter . array[0 ] sar puntator prim cell cos via array[9 ] punt all&#39; ultim cell memor . </answer_text><num_votes>2</num_votes></answer><answer id="A2721"><answer_text>variabil tip array contien indirizz memor non conten perc conten può var verr camb conten cell camb l&#39; indirizz . </answer_text><num_votes>0</num_votes></answer><answer id="A2576"><answer_text>variabil tip array contien l&#39; indirizz element dell&#39; array . esso è puntator tutt effett . acced all&#39; array mediant parentes quadr (es . myarray[n ] ) , non facc spost l&#39; indirizz punt myarray avant n (n dimension word : int , char , float , doubl second tip dell&#39; array ) . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2766"><question_text>qual vantagg comport l&#39; alloc dinam vettor ? ? quest&#39; ultim cre problem fas compil programm part compil ? ? esemp alloc dinam array tip int. </question_text><answer id="A2717"><answer_text>vantagg più evident consist definizion alloc esatt memor opportun l&#39; esecu richiest . memor vien infatt utilizz durant esecu programm , evit fas compil si sprechin risors . limit principal consist necess scriv opportun righ codic aggiunt , rallent compil . int *p ; p=(int* ) malloc (5*sizeof(int ) ) ; garant spaz necessar 5 inter </answer_text><num_votes>2</num_votes></answer><answer id="A2638"><answer_text>l&#39; alloc dinam vettor permett non defin prior dimension .quest vien realizz attravers specif funzion (malloc sizeof ) l&#39; utilizz puntator .se l&#39; array cos cre per non vien inizializz potrebb port qualc problem quant memor utilizz alloc potrebb esser &#34; sporc &#34; . int *array ; (puntator inter ) int dim; (dimension dell&#39; array ) array = (int* ) malloc(dim*sizeof(int ) ) ; (riserv memor dim &#34; spaz &#34; dimension int assegn puntator array posizion memor element ) </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2781"><question_text>mod programm può defin &#34; tip &#34; ? </question_text><answer id="A2673"><answer_text>typedef tip nomenuovotip esemp : typedef char nomistudent [lunghezza_massim ] </answer_text><num_votes>0</num_votes></answer><answer id="A2682"><answer_text>dichiar tip consist parol chiav typedef , segu rappresent costruzion tip , dall&#39; identif tip simbol &#34; ; &#34; chiud dichiar . signif tip può esser defin semplic dand tip già esistent . </answer_text><num_votes>0</num_votes></answer><answer id="A2599"><answer_text>mod principal programm defin tip è mediant dichiar tipo,c consist parol chiav &#34; typedef &#34; segu rappresent costruzion tip (oss specif com esso è costru part tip già esistent ) , dall&#39; identif tip simbol &#34; ; &#34; chiud dichiar . c è possibil defin tip usar parol chiav &#34; typedef &#34; tuttav quest costruzion consent maggior uniform stil definizion tip assoc identif appropr . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2733"><question_text>e&#39; possibil sap prior lunghezz dat array gia inizializz terz precedent ? </question_text><answer id="A2548"><answer_text>si , è possibil conosc dimension array attravers funzion &#39;sizeof ( ) &#39; . quest funzion restitu dimension byte porzion memor occup dall&#39; oggett funzion , gen si utilizz l&#39; espression dimensione=sizeof(array ) / sizeof(array[0 ] ) ; conosc numer &#34; slot &#34; dell&#39; array . </answer_text><num_votes>0</num_votes></answer><answer id="A2709"><answer_text>e&#39; possibil conosc lunghezz , tuttav si present div scenar : (i ) l&#39; array static è inizializz , sar defin numer element , si può otten dimension legg l&#39; inizializz . (ii ) l&#39; array è array char si può conosc lunghezz string scorr cont element caratt null \0 . (ii ) defin array è possibil calcol dimension attravers funzion sizeof (&#60; nomearray&#62; ) semplic elebor valor restitu . funzion restitu spaz byte utilizz memor . </answer_text><num_votes>3</num_votes></answer><answer id="A2589"><answer_text>sì perc inizializz array static bisogn specific numer element , chiunqu può ricav dimension legg l&#39; inizializz . </answer_text><num_votes>0</num_votes></answer><answer id="A2690"><answer_text>l&#39; array è array char (quind string ) è possibil otten dimension string stess attravers cicl whil scorr element string finc non si incontr caratt &#34; \0 &#34; . l&#39; array è form esemp numer inter , calcol dimension dell&#39; array si può usar com sizeof( ) dov è vettor vogl conosc dimension . </answer_text><num_votes>0</num_votes></answer><answer id="A2590"><answer_text>sì perc inizializz array static bisogn specific numer element , chiunqu può ricav dimension legg l&#39; inizializz . </answer_text><num_votes>0</num_votes></answer><answer id="A2547"><answer_text>sì , è possibil conosc lunghezz array attravers funzion &#34; sizeof ( ) &#34; . quest funzion restitu dimension byte occup dall&#39; oggett funzion , gen si utilizz l&#39; esperession &#34; dimensione=sizeof(array ) / sizeof(array[0 ] ) ; &#34; mod otten l&#39; esatt numer &#34; slot &#34; contien l&#39; array . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2640"><question_text>perc quand si assegn array string (esemp : scanf( &#34; % s &#34; , string ) ) , non si utilizz caratt special &#39;&#38; &#39; ? si intend quand si utilizz caratt &#39;&#38; &#39; ? </question_text><answer id="A2619"><answer_text>quand si assegn array string , non si utilizz l&#39; oper &#38; , quant , string (ed general array ) denot già indirizz (l&#39; indirizz element ) . caratt &#38; si utilizz , com scanf, assegn indirizz funzion . </answer_text><num_votes>2</num_votes></answer><answer id="A2573"><answer_text>l&#39; oper scanf string non richied l&#39; utilizz caratt &#39;&#38; &#39; , poic string puntator . cas caratt &#39;&#38; &#39; serv indirizz variabil . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ2667"><question_text>perc l&#39; indic array non è compres 1 n , 0 n-1 ? </question_text><answer id="A2571"><answer_text>perc l&#39; indic array part numer 0 n-1 poi l&#39; ultim cell dell&#39; array è riserv caratt string è not &#34; \0 &#34; </answer_text><num_votes>0</num_votes></answer><answer id="A2688"><answer_text>perc i creator linguagg programm decis cos , convenzion . </answer_text><num_votes>1</num_votes></answer><answer id="A2549"><answer_text>perc c array è essenzial puntator cell memor , element conten array è salv memor esatt punt [0 ] . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2664"><question_text>array è possibil dat tip div ? </question_text><answer id="A2743"><answer_text>array non è possibil dat tip div ; caratterist dell&#39; array è propr l&#39; omogen . dichiar si determin tip dat l&#39; array conten . esemp si può prend consider array char ; ogni cell occup memor 1 byte (8 bit ) . si voless prov inser valor tip int (2 byte ) cell dell&#39; array incontr problem : dat tip int non sarebb soltant conten cell si vorrebb immagazzin cell seguent sarebb un&#39; error . </answer_text><num_votes>1</num_votes></answer><answer id="A2685"><answer_text>tip dat struttur array e&#39; omogene sequenz cell consecut . non e&#39; possibil intern dat tip divers , fas dichiar si scegl tip dat conterr l&#39; array dichiar . </answer_text><num_votes>2</num_votes></answer><answer id="A2575"><answer_text>, caratterist dell&#39; array è l&#39; omogen dat esso conten : tutt i valor immagazzin tip . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2709"><question_text>dop ser if , l&#39; else qual if vien attribu ? </question_text><answer id="A2556"><answer_text>si intend ser costrutt if annid all&#39; intern dell&#39; , part else verr attribu all&#39; costrutt if dichiar . </answer_text><num_votes>0</num_votes></answer><answer id="A2545"><answer_text>presenz if nidific l&#39; else si rifer costr if , trov presenz ser costrutt if non nidific l&#39; else final e&#39; rifer all&#39; costrutt if . </answer_text><num_votes>1</num_votes></answer><answer id="A2698"><answer_text>dop ser costrutt if , l&#39; else vien attribu sempr all&#39; if piu&#39; vicin men non divers specific eventual parentes graff . ogni mod e&#39; util porr sempr parentes graff mod tal l&#39; istruzion risult piu&#39; chiar programm dovrebb modific legger . </answer_text><num_votes>2</num_votes></answer><answer id="A2672"><answer_text>dop ser if nidific ,l &#39; istruzion else è sempr rifer all&#39; ultim istruzion if comp codic . cas si vogl rifer l&#39; else penultim if è necessar chiud blocc istruzion tal if prim dell&#39; else inser } . ved esemp : if (cond1 ) { istruz1 if (cond2 ) { istruz2 } // mett } else si rifer if (cond1 ) elimin l&#39; ultim parentes graff else{ istruz3 } } </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2661"><question_text>si intend &#34; lazy evaluation &#34; rifer valut condizion c ? </question_text><answer id="A2652"><answer_text>&#34; lazy evaluation &#34; si intend possibil valut un&#39; espression moment quest è richiest strett necessar . mod &#34; strict (o eager ) evaluation &#34; si poss otten miglior prestazion punt vist dell&#39; uso memor dell&#39; uso risors sistem (si evit valut avveng più quand non necessar ) . possibil nat gest valut mod non è present tutt i linguagg può esser comunqu implement . </answer_text><num_votes>2</num_votes></answer><answer id="A2569"><answer_text>&#34; lazy evaluation &#34; si indic strateg valut qual un&#39; espression vien comput moment quest è richiest . ciò permett un&#39; ottimizz prestazion perc evit un&#39; espression veng comput più quand non necessar . &#34; strict evaluation &#34; , si benef quant riguad l&#39; impront memor programm , quant conc richiest prestazion vers calcol . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2674"><question_text>perc dichiar qualsias array si usa defin numer massim element può conten quand si potrebb semplic dichiar array dinam ? </question_text><answer id="A2607"><answer_text>cert si usa dichiar static array , perc que cas magar si sa già dimension massim serv mod non si utilizz ,appunt , l&#39; alloc dinam risult po&#39; più difficil (per neo-pragramm ) , cas tal memor alloc non veng dealloc programm si risc lasc inutilizz chè sarebb sprec . </answer_text><num_votes>0</num_votes></answer><answer id="A2686"><answer_text>utilizz array defin numer massim element programm vien esegu mod più immed memor alloc già conosc macchin . invers array dinam comport ogni esecu programm far stim memor necessar possibil utilizz più cell necessar sian insufficient (overflow quand numer cell richiest superior quell dispon ) . comunqu scriv programm tip dell&#39; dip programm è consapevol risc . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2672"><question_text>fa&#39; compil quand vien dichiar array ? </question_text><answer id="A2618"><answer_text>quand vien dichiar array compil riserv memor spaz sufficient memorizz n variabil sar compost l&#39; array (nel cas l&#39; array static ) . quest cell sarann consecut prim avrà indic 0 (per acced sar sufficient richiam dell&#39; array fa puntator , esemp : a[0 ] ) mentr l&#39; ultim n-1 . cas l&#39; array dinam compil trov spaz dimension (n ,not ) durant l&#39; esecu . </answer_text><num_votes>3</num_votes></answer><answer id="A2564"><answer_text>quand vien dichiar array compil riserv memor ser cell consecut bas numer element dichiar assegn prim cell , indic 0 , puntator (il dell&#39; array ) . mod tutt l&#39; array verr richiam compil utilizz l&#39; indirizz salv puntator acced prim cell si spost poi quell success second dell&#39; element dovr oper . </answer_text><num_votes>1</num_votes></answer><answer id="A2714"><answer_text>quand si dichiar array (per esemp array[n ] ) compil riserv memor spaz memor sufficient memorizz n variabil tip dichiar . tal cell memor si acced tram indic , indic parentes quadr , individu l&#39; element richiest . indic element vann 0 n-1 (per acced element dell&#39; array bisogn scriv array[0 ] ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2639"><question_text>qual è different string array caratter ? fai esemp . </question_text><answer id="A2696"><answer_text>string non è tip dat defin dall&#39; utent corrispond array caratter , caratt final è null cio caratt &#34; \0 &#34; string lunghezz n contien n+1 caratter . string può esser defin dall&#39; utent typedef esemp : typedef char string [n ] ; l&#39; array caratter si dichiar semplic l&#39; espression tip dat char corrispond caratter es . char vett[n ] ; </answer_text><num_votes>1</num_votes></answer><answer id="A2544"><answer_text>string dev termin caratt termin &#39;\0 &#39; , mentr array caratter è contenitor più caratter </answer_text><num_votes>0</num_votes></answer><answer id="A2699"><answer_text>array caratter può esser usat rappresent string , l&#39; unic different è cas string vien aggiunt valor null indic string . cas string lunghezz n si dovr riserv spaz memor par n+1 , via caratt null . esemp : char string [ ]= &#34; cia &#34; ; equival dichiar array caratter chiam &#34; string &#34; sar compost 5 element . </answer_text><num_votes>1</num_votes></answer><answer id="A2626"><answer_text>linguagg c non esist tip string , è possibil definirlo/cr attravers array caratter . esemp vogl cre string &#34; cia &#34; , dobb utilizz array com : char parol [4 ] . l&#39; array esser element perc l&#39; ultim casell conten &#34; \0 &#34; termin parol . stamp vide parol è poi possibil utilizz com string : printf ( &#34; % s &#34; , parol ) . mod defin tip string è utilizz costrutt &#34; typedef char string [ncar ] &#34; ncar numer caratter massim . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2772"><question_text>e&#39; possibil array dov ogni element è array ? esemp mostr com si può acced div element . </question_text><answer id="A2592"><answer_text>poss otten l ?oggett richiest ques utilizz variabil tip array 2 dimension , oppur attravers 1 costruttor tip ?typedef struct ? . cas variabil array 2 dimension 3 x 2 , poss utilizz 2 indic . esemp dichiaram matric int &#60;nome&#62; [3 ] [2 ] . poi poss acced singol element specific rig interess l ?altr colonn . esemp assegn variabil variabil = matric [1 ] [0 ] ; </answer_text><num_votes>1</num_votes></answer><answer id="A2654"><answer_text>quest form è dett array multidimensional . esemp array bidimensional si può pens com tabell bidimensional element tip . esemp vogl cre matric n x m poss dichiar : int matric [3 ] [6 ] ; quest dichiar ved array 6 element ciascun qual contien volt array 3 element (le 3 righ divis 6 colonn ) acced element &#34; matric &#34; poss scriv : &#34; matric [n ] [ m ] &#34; dov &#34; n &#34; corrispond rig &#34; m &#34; colonn . esemp : matric [2 ] [3 ] =element terz rig ,quart colonn . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ2641"><question_text>dat funzion non può restitu com risult array , com si può inizializz tram funzion procedur estern main ? </question_text><answer id="A2718"><answer_text>iniz dic domand è valid funzion , perc procedur non poss restitu null . inizializz array funzion è necessar pass com parametr puntator punt element dell&#39; array . sfrutt puntator poss usar effett l&#39; array semplic cicl for inizializz com sempr , all&#39; intern funzion . funzion dovr restitu puntator main . </answer_text><num_votes>2</num_votes></answer><answer id="A2725"><answer_text>inizializz array tram funzion è necessar realizz funzion gener valor casual , general chiam &#34; random &#34; chiam all&#39; intern cicl for analizz ogni singol cell dell&#39; array . cos fac l&#39; array si riemp valor casual . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2616"><question_text>costrutt if , è possibil inser blocc istruzion vuot ? (oss inser parentes graff apert quell chius nient all&#39; intern ) </question_text><answer id="A2719"><answer_text>si&#39; , e&#39; possibil inser blocc istruzion vuot costrutt if . non e&#39; error sintatt , pero&#39; sicur altern miglior svolg comp . poss dir codic e&#39; corrett non efficient . </answer_text><num_votes>2</num_votes></answer><answer id="A2586"><answer_text>cert è possibil ! esemp , codic sottost riport com esemp : int x ; x = 0 ; printf ( &#34; x = &#34; ) ; scanf( &#34; % d &#34; , &#38;x ) ; if (x &#62;= 10 ) { } else { printf ( &#34; x &#60; 10 ! \n &#34; ) ; } inser x&#60;10 verr esegu l&#39; istruzion &#34; printf &#34; conten nell&#39; else mentr , inser x&#62;=10 programm entrer nell&#39; if non esegu alcun istruzion perc vuot . cas compil non segnal alcun error , infatt , programm non è errat ; è semplic efficient potrebb esser implement . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2642"><question_text>spieg brevement cos&#39; è array ? tip array si poss linguagg c ? </question_text><answer id="A2552"><answer_text>array può esser defin com ?collezion organizz oggett ? . analizz definizion cap molt cos , innanzitutt concett ?collezion ? implic tal oggett sian tip ; array c è collezion variabil tip . ?organizz ? implic possibil identific univoc tutt ogget ?array mod sistemat ; c vien fatt tram l&#39; uso indic numer , array dimension n , vann 0 n-1 . esist tip array : -monodimensional (vettor ) ; -multidimensional . </answer_text><num_votes>1</num_votes></answer><answer id="A2715"><answer_text>array può esser defin com collezion organizz oggett , dov tutt element apparteng tip (es . numer real , numer real caratter ) . ogni element dell&#39; array dev&#39; esser identific mod sistemat , quant dev&#39; esser possibil richiam ogni singol element attravers notazion appropr , c vien fatt tram l ?us indic numer , array dimension n , vann 0 n-1 . essend essi sol struttur astratt identific puntator è possibil cre array qualsias tip dat . </answer_text><num_votes>1</num_votes></answer><answer id="A2747"><answer_text>array è insiem omogene element colloc memor central mod adiacent , l&#39; indirizz part l&#39; array è inser nell&#39; identif , val dir abbiam int a[10 ] , &#39;a &#39; corrispond prim cell dell&#39; array ovver a[0 ] . l&#39; array si comport com puntator , val dir vogl punt element dereferenz 2 cell poss scriv * (a +2 ) . c tant tip array quant i tip c,import è element present essi sian omogene . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2619"><question_text>qual è metod più efficient scorr array numer grand element ? </question_text><answer id="A2570"><answer_text>metod più efficent è l ?utilizz istruzion condizional , qual i costrutt &#34; for &#34; &#34; whil &#34; .conosc numero,seppur grande,d element array , cre inizializz variabil contator è possibil : 1 ) cre cicl whil fintantoc contator è minor numer element ?array spazz tutt i valor 2 ) cre cicl for fintantoc contator è minor numer element dell&#39; array increment spazz cos tutt element ?array quest metod necessar fas inizializz stamp dell&#39; array . </answer_text><num_votes>0</num_votes></answer><answer id="A2727"><answer_text>metod più efficient scorr array numer elev element è costrutt cicl , più precis cicl for whil , graz qual è possibil scorr tutt element dell&#39; array , increment l&#39; indic ogni pass . tram cicl for è present scorr , visualizz tutt element dell&#39; array , dand possibil blocc cicl volt vien raggiunt condizion . </answer_text><num_votes>2</num_votes></answer><answer id="A2572"><answer_text>numer inter è not , è opportun usar cicl for , consist inizializz variabil indic , condizion increment . altriment è consigl l&#39; applic cicl whil . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2648"><question_text>esist possibil dichiar array dinam vettor [a ] variabil tip int , mod poter increment valor cicl otten cos array dinam ? </question_text><answer id="A2701"><answer_text>si può defin manier dinam conten array . mett com condizion veng defin precedent &#34; n &#34; &#34; array[n ] &#34; , si può lanc cicl &#34; for(a=0,a&#60;n ,a++ ) &#34; defin conten dell&#39; array mod dinam . </answer_text><num_votes>1</num_votes></answer><answer id="A2700"><answer_text>si può defin manier dinam conten array . mett com condizion veng defin precedent &#34; n &#34; &#34; array[n ] &#34; , si può lanc cicl &#34; for(a=0,a&#60;n ,a++ ) &#34; defin conten dell&#39; array mod dinam . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2649"><question_text>dar definizion array . array dinam utilizz linguagg c ? vantagg dann ? </question_text><answer id="A2738"><answer_text>è ?collezion organizz oggett ?.il concett ?collezion ? implic tal oggett sian tipo.un array c è dunqu collezion variabil tip . ?organizz ? implic possibil identific univoc tutt ogget ?array mod sistematico;quest c vien fatt tram l ?us indic numer che,in array dimension n,vann 0 n-1 . int tesor [100 ] ; quest rig codic dichiar array inter , form 100 element .quest signif abbiam 100 variabil pront conten numer inter =&#62;pratic . </answer_text><num_votes>0</num_votes></answer><answer id="A2732"><answer_text>array e&#39; insiem cell omogene consecut , n element dell&#39; array indic indic e&#39; compres nell&#39; intervall 0 n-1 . array c poss esser tip : static dinam . array dinam preved definizion dimension durant l&#39; esecu . array dinam consent linguagg piu&#39; flessibil &#39; inoltr permett programm deleg gestion memor . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2662"><question_text>costrutt &#34; switc cas &#34; può confront valor variabil valor deriv un&#39; espression specific nell&#39; istruzion &#34; cas &#34; ? mot rispost . </question_text><answer id="A2609"><answer_text>definizion &#34; cas &#34; , variabil dev&#39; esser tip integral ; confront valor deriv un&#39; espression , inser l&#39; espression com argoment &#34; switc ( ) &#34; variabil inter com argoment &#34; cas &#34; . </answer_text><num_votes>1</num_votes></answer><answer id="A2745"><answer_text>si perc è confront </answer_text><num_votes>0</num_votes></answer><answer id="A2728"><answer_text>&#34; switc cas &#34; confront valor variabil un&#39; espression costant specific cas . framment codic : int x ; scanf( &#34; % d &#34; , &#38;x ) ; switc (x ) { cas (1+1 ) : printf ( &#34; \n &#34; ) ; break; } non dar problem fas compil perc l&#39; espression &#34; 1+1 &#34; è costant . framment : int x,y=1 ; scanf( &#34; % d &#34; , &#38;x ) ; switc (x ) { cas (1+y ) : printf ( &#34; \n &#34; ) ; break; } non sar compil perc l&#39; espression &#34; 1+y &#34; non è valut fas compil . potre risolv problem defin y com costant (fuor main ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2631"><answer_text>si costrutt può realizz confront valor deriv un&#39; espression . infatt sar compil interven fas compil sostitu l&#39; espression valor deriv essa quant si tratt inutil cpu . dunqu scriv , esemp , &#34; cas 2+ (8*2 ) &#34; oppur &#34; cas 18 &#34; non camb quant fas compil l&#39; espression c vien sostitu valor final quest linguagg macchin . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2761"><question_text>succed c , un&#39; istruzion condizional , condizion è a=5 (es . if (a=5 ) ... nb manc ugual ) ? qual insid error ? </question_text><answer id="A2712"><answer_text>manc ugual infatt , quand pon variabil , cas , ugual valor , 5 , signif vien assegn valor variabil , cas un&#39; istruzion condizional usiam ugual (a==5 ) verific variabil assum valor vogl , cas 5 . insid error costrutt non andrà verific variabil assum valor vol , calcol assegn variabil valor non verr segnal compil . </answer_text><num_votes>2</num_votes></answer><answer id="A2687"><answer_text>si manc ugual . infatt quand scriv variabil (a ) pon ugual valor (5 ) , signif assegn valor 5 . mentr cas costrutt if interess verific quand variabil (a ) è equivalent valor defin (5 ) . form corrett costrutt è if (a==5 ) { } . insid error esso non può esser identific calcol difficil rivel . </answer_text><num_votes>2</num_votes></answer><answer id="A2746"><answer_text>l&#39; utilizz = sta indic com assegn , mentr 2 = (== ) utilizz com uguagl . insid tal error poss esser , : esemp l&#39; intenzion era confront valor un&#39; istruzion if , l&#39; oper assegn ritorn valor è probabil veng valut com tru , sar valut clausol then , fac comport programm mod inattes . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2688"><question_text>ricord definizion funzion puntator comment l&#39; afferm : &#34; puntator è variabil memorizz indirizz memor &#34; . qual i vantagg puntator variabil com array struct ? ? </question_text><answer id="A2598"><answer_text>puntator e&#39; tip dat , variabil contien l&#39; indirizz memor un&#39; altra variabil . si poss puntator qualsias tip variabil . puntator contrar array struct è variabil , è facil utilizz all&#39; intern linguagg programm . general si può dir i puntator facilit scrittur . </answer_text><num_votes>2</num_votes></answer><answer id="A2702"><answer_text>i puntator caratterist import linguagg c , moment permett lavor bass livell , particol quant riguard l&#39; alloc memor gestion indirizz . particol , essi fondamental cas utilizz funzion , poic permett passagg parametr indirizz valor , consent cos modif variabil mediant invoc funzion . propr fatt , tuttav , essi poss gener effett collateral qual modif involontar variabil . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2630"><question_text>different c&#39; è cicl for , cicl whil cicl do-whil ? </question_text><answer id="A2551"><answer_text>quest cilc permett esegu più porzion codic , piuttost com com scanf ( ) . different principal cicl for whil , mentr cicl for codic vien esegu numer predefin dall&#39; utent (es . for(i=0;i&#60;n ;i++ ) ) cicl whil esegu corp cicl fintant condizion è verific (es . whil (i&#60;n ) ) . do whil , com cicl whil , esegu corp cicl numer non predefin , prim esegu corp cicl poi verif condizion . (es . do { } whil (i&#60;n ) ) . </answer_text><num_votes>2</num_votes></answer><answer id="A2579"><answer_text>i cicl equivalent . cicl &#34; for &#34; può sempr esser ricondott cicl &#34; do whil &#34; cicl &#34; whil &#34; . c&#39; è teorem dic , teorem böhm-jacopin . cicl do-whil è util quand numer iter è not prior . mentr costrutt whil sequenz istruzion ripet vien esegu condizion espress whil è verific , cicl do-whil istruzion veng esegu dopodic vien effettu controll condizion whil verific . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2732"><question_text>qual mot array dimension fiss ? </question_text><answer id="A2705"><answer_text>array si intend sequenz cell memor consecut omogene . ogni sequenz vien dat identif , mentr ogni singol cell vien identific mediant sequenz indic . moment creiam array dobb indic quant cell memor necessit ,cio diam all&#39; array dimension fiss , mod tal quand richiam variabil compil sapp qual cell memor rifer . </answer_text><num_votes>4</num_votes></answer><answer id="A3435"><answer_text>array insiem variabil tip . singol variabil array dett element . ogni element è identific inter , dett indic . array dimension vien specific all&#39; intern codic si chiam array static , dat dimension non camb durant l&#39; esecu programm . are memor variabil consecut veng riserv moment dichiar dell&#39; array , dimension non può esser più modific . </answer_text><num_votes>0</num_votes></answer><answer id="A2724"><answer_text>array dimension vien defin all&#39; intern programm com costant array static .gli arrays insiem variabil tipo.l singol variabil array dett element .gli array dimension fiss vien specific all&#39; intern codic si chiam array static .,dat dimension non camb durant l&#39; esecu programm different array dinam dimension vien determin all&#39; atto esecu programm . es . array static : intx [5 ] ; float y[ ]={8 .34 ,4.55.2.33.6.12 } ; </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2677"><question_text>serv quand si usa funzion &#34; enum &#34; ? </question_text><answer id="A2649"><answer_text>funzion enum serv defin tip variabil poss assum numer fin valor , veng denomin costant . funzion enum vien usat quand si vogl cre quest costant . quest costant veng enunc , programm , esemp , mod : &#34; enum days {sat , sun , mon , , wed , thu , fri } ; &#34; . </answer_text><num_votes>0</num_votes></answer><answer id="A2578"><answer_text>e&#39; costrutt serv defin tip dat ordin numer natural ; pratic bass livell verrann sempr vist com inter , alto livell vedrem nom più signif com &#34; luned , marted etc &#34; (se utilizz i giorn settiman ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2583"><answer_text>enumeration è tip user-defined c , permett defin list simbol . si inizializz : enum {list simbol separ virgol } variabil ; solit si usa defin tip valor predefin programm numer limit . bisogn attenzion riguard com i valor defin veng gest compil : veng infatt consider com costant inter . </answer_text><num_votes>1</num_votes></answer><answer id="A2632"><answer_text>&#34; enum &#34; è costruttor tip , variabil dichiar costruttor può assum i valor specific parentes graff . dichiar variabil quest caratterist si usa quest notazion : enum {valore1 , valore2 , ecc } nomevar ; i valor indic all&#39; intern parentes graff rappresent valor tip inter (non rappresent string ) . esemp inizializz enum {lun , mar , mer , gio , ven , sab , dom } giorn ; giorno=m ; stamp valor giorn compil stamp 1 . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2627"><question_text>perc quand si vuol dichiar string n caratter l&#39; array dimension n+1 ? </question_text><answer id="A2562"><answer_text>perc array caratter conten ultim posizion valor special null , indic dov fin string . </answer_text><num_votes>1</num_votes></answer><answer id="A2735"><answer_text>string è defin c com array caratter termin variabil &#39;\0 &#39; . durant l&#39; indicizz dobb consider array è conten termin andrà diminu spaz effett utilizz all&#39; intern string . e&#39; quest motiv quand necessit string n caratter dobb dichiar dimension n+1 . </answer_text><num_votes>1</num_votes></answer><answer id="A2595"><answer_text>perc bisogn riserv l&#39; post dell&#39; array caratt &#39;\0 &#39; è caratt &#34; string &#34; </answer_text><num_votes>1</num_votes></answer><answer id="A2734"><answer_text>string è defin c com array caratter termin variabil &#39;\0 &#39; . durant l&#39; indicizz dobb consider array è conten termin andrà diminu spaz effett utilizz all&#39; intern string . e&#39; quest motiv quand necessit string n caratter dobb dichiar dimension n+1 . </answer_text><num_votes>0</num_votes></answer><answer id="A2585"><answer_text>dimension n+1 poic ogni array com ultim posizion conten caratt special null . caratt vien utilizz cap dov fin string . dunqu array avrà dimension n+1 string lung n posizion n+1 trov caratt special null . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2685"><question_text>dichiar array diec element ( char a[10 ] ; ) quant cell disposizion ? perc è import caratt &#34; \0 &#34; nell&#39; ultim cell dell&#39; array ? </question_text><answer id="A2742"><answer_text>dichiar array 10 element disposizion corrispondent 10 cell , è riserv caratt null . caratt \0 è import poic corrispond caratt valor zer codif asci . </answer_text><num_votes>1</num_votes></answer><answer id="A2629"><answer_text>dichiar &#34; char a[10 ] &#34; si otterr array posizion &#34; [0 ] &#34; &#34; [9 ] &#34; . posizion &#34; [10 ] &#34; sar occup caratt &#34; \0 &#34; . ciò torn util quand dovrem esemp verific lunghezz , pon com condizion a[n ] == &#34; \0 &#34; com condizion uscit ipotet cicl whil . </answer_text><num_votes>0</num_votes></answer><answer id="A2593"><answer_text>denot n (in cas 10 ) dimension dell&#39; array , numer cell disposizion memorizz string n+1 , 11 . nell&#39; ultim cell è present caratt termin \0 permett tratt string conosc prior dimension indic quand string termin . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2613"><question_text>l&#39; inizializz fas dichiar è un&#39; oper applic inter array ? (cio non singol element dell&#39; array ) </question_text><answer id="A2657"><answer_text>l&#39; inizializz array può esser fatt durant dichiar , manier esplic , indic ogni valor ogni cell manual , esemp : &#34; int array_ [3 ] = {1 , 50 , 74 } ; char array_vocal [5 ] = { ? s ? , &#39; u ? , &#39; t ? , &#39; y ? , &#39; u ? } ; &#34; per mod più comod inizializz array grand dimension è attravers cicl iter com for , rimand cos l&#39; inizializz moment dichiar . esemp : &#34; int array_b[10 ] ; for( =0 ; i &#60; 10 ; i++ ) { array_b[ ] = i; } &#34; </answer_text><num_votes>0</num_votes></answer><answer id="A2720"><answer_text>e&#39; possibil inizializz i termin array fas dichiar segu mod : int array[5 ] = {3 ,2,1,0,3 } ; char [5 ] = { &#39; c &#39; , &#39;a &#39; , &#39;r &#39; , &#39;l&#39; , &#39;o &#39; } ; mod l&#39; array caratter &#34; &#34; veng interpret com string , ossi ser caratter defin &#39;un &#39; , è necessar introdurr termin string &#39;\0 &#39; com seguent cas : char [6 ] = { &#39; c &#39; , &#39;a &#39; , &#39;r &#39; , &#39;l&#39; , &#39;o &#39; , &#39; \0 &#39; } ; oppur altern : char [6 ] = &#34; carl &#34; ; termin string vien introdott automat . </answer_text><num_votes>0</num_votes></answer><answer id="A2733"><answer_text>programm c non è possibil oper (ad esemp printf scanf ) inter array . inizializz conten si serv cicl &#39;for&#39; permett scorr i var element compong l&#39; array . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2614"><question_text>qual&#39; è different array static array dinam ? qual vantagg si dichiar array dinam dichiar array static ? </question_text><answer id="A2642"><answer_text>different sostanzial array dinam static è seguent : array static dimension è not compil mentr array dinam è dimension l&#39; alloc esecu .questa,oltr esser sostanzial different , è vantagg principal array dinam quell static . </answer_text><num_votes>0</num_votes></answer><answer id="A2739"><answer_text>array static veng inizializz valor fiss ; quell dinam . vantagg array dinam static è è più flessibil . </answer_text><num_votes>0</num_votes></answer><answer id="A2716"><answer_text>quand si dichiar array static (es : int coef[20 ] ; ) e&#39; già not compil spaz necessar memorizz l&#39; array . definizion dinam (es : char c[len ] ; ) l&#39; array trov spaz memor esecu non compil . vantagg utilizz array dinam è aggiung notevol flessibil &#39; linguagg . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2652"><question_text>perc nell&#39; acquisizion tastier string è prefer utilizz com &#34; gets &#34; piuttost &#34; scanf &#34; ? </question_text><answer id="A2582"><answer_text>gets legg tutt i valor present rig finc non trov /n (a cap ) /0 (termin rig ) . sicur tutt i dat abbiam inser , veng trasport nell&#39; array . scanf innanzitutt analizz form dat inser , poi cattur ciò riguard form ; non c&#39; è certezz tutt i datiinser , veng immess nell&#39; array . </answer_text><num_votes>1</num_votes></answer><answer id="A2697"><answer_text>nell&#39; acquisizion tastier string è prefer utilizz com &#34; gets ( ) &#34; quant esso permett l&#39; acquisizion string includent spazi(blank spac ) l&#39; caratt indic string è &#34; invi &#34; ( enter key ) . &#34; scanf ( ) &#34; caratt indic string può esser &#34; invi &#34; oppur &#34; spaz &#34;, conseguent non si poss memorizz string contenent blank spac . </answer_text><num_votes>0</num_votes></answer><answer id="A2713"><answer_text>scanf è sconsigl l&#39; acquisizion string quant legg caratt &#34; spaz &#34; com termin string ossi com 0 . parol acquis esemp string caratt spaz (es cognom ) acquis . solit nell&#39; acquisizion string tastier si usa gets ancor fgets : f gets infatt esegu controll dimension string segnal eventual error cas string super dimension buffer . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2778"><question_text>qual i lim dat struttur array ? </question_text><answer id="A2617"><answer_text>l&#39; array rappresent più semplic tip dat struttur utilizz linguagg programm . import vann per evidenz i lim quest struttur dat present , onde evit error fas programm . e&#39; ben ten ment dat linguagg c non effettu alcun controll i lim array . error non : 1 ) oper aritmet confront array ; 2 ) chied funzion restitu array ; 3 ) assegn valor all&#39; inter array ; 4 ) inizializz array n element più n valor . </answer_text><num_votes>2</num_votes></answer><answer id="A2613"><answer_text>array è raccoglitor raggrupp determin numer variabil , indic divers . variabil conten nell&#39; array dev esser tutt tip , esemp dichiar array 20 element tip inter otteng 19 variabil (la ventesim è &#34; \0 &#34; ) tutt tip inter . </answer_text><num_votes>0</num_votes></answer><answer id="A2681"><answer_text>indic array non nessun controll correttezz dat immess , spess veng fatt calcol cell memor inesistent . </answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L35" title="Funzioni" date="2013-11-04"><question id="QQ3185"><question_text>seguent funzion utilizz metod different &#34; pass &#34; variabil : -int funzione1 (int , int b ) { ... } -int funzione2 (int* , int* b ) { ... } qual different quest metod ? com veng richiam funzion main ? </question_text><answer id="A3259"><answer_text>funzion 1 pass valor variabil b mentr funzion 2 pass rifer variabil . funzion star attent non modific valor variabil b , quel cas valor main camb . main cas pass variabil pass l&#39; indirizz </answer_text><num_votes>0</num_votes></answer><answer id="A3266"><answer_text>funzione1 utilizz metod valor : vien pass sol valor variabil , verr cop non sub modif . funzione2 utilizz metod rifer : vien pass l&#39; indirizz varabil , sub modif . i parametr funzione2 dev esser indirizz si usa &#38;nomevar </answer_text><num_votes>3</num_votes></answer><answer id="A3260"><answer_text>funzion 1 pass valor variabil b mentr funzion 2 pass rifer variabil . funzion star attent non modific valor variabil b , quel cas valor main camb . main cas pass variabil pass l&#39; indirizz </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3183"><question_text>qual è different variabil global variabil local ? </question_text><answer id="A3162"><answer_text>variabil global si dichiar fuor funzion compres funzion &#39;main&#39; , veng vist poss esser richiam tutt . variabil local , , dichiar all&#39; intern funzion : esse nasc quand si acced funzion si distrugg all&#39; uscit . general programm si tend usar poch variabil global quant si può incorr facil error . </answer_text><num_votes>3</num_votes></answer><answer id="A3149"><answer_text>variabil global poss esser usat tutt dur programm , veng alloc fas compil dichiar fuor main (sub dop librer ) . esse vist tutt part programm , cio main var funzion . quest poss caus sprec memor different variabil local veng vist part codic inser delimit oper { } . permett liber memor non farl satur . </answer_text><num_votes>2</num_votes></answer><answer id="A3148"><answer_text>variabil global poss esser usat tutt dur programm , veng alloc fas compil dichiar fuor main (sub dop librer ) . esse vist tutt part programm , cio main var funzion . quest poss caus sprec memor different variabil local veng vist part codic inser delimit oper { } . permett liber memor non farl satur . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3129"><question_text>qual caratterist funzion ricors ? </question_text><answer id="A3130"><answer_text>funzion è ricors quand intern c&#39; è invoc stess . funzion ricors veng impieg quand è necessar comp ser oper tutt ident . </answer_text><num_votes>1</num_votes></answer><answer id="A3239"><answer_text>caratterist funzion ricors principal seguent : presenz piu&#39; cas bas , qual risult puo&#39; esser determin dirett ; presenz piu&#39; cas compless , dett ricors , individu risult funzion valor piu&#39; piccol piu&#39; semplic risult dall&#39; esecu funzion stess . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3169"><question_text>different c&#39; è i parametr formal i parametr attual funzion ? </question_text><answer id="A3194"><answer_text>argoment funzion , elenc test all&#39; intern parentes , veng dett parametr formal funzion . quest rappresent que valor funzion richied esegu oper l&#39; utent inser all&#39; intern . quant riguard i parametr attual ( dett effett ) quell funzion attu oper logic intern . quand funzion vien invoc , i parametr formal veng inizializz i valor parametr effett . </answer_text><num_votes>1</num_votes></answer><answer id="A3157"><answer_text>i parametr formal quell dichiar tip , numer ordin definizion funzione.in pratic argoment funzion elenc nell&#39; header. parametr attual quell veng pass funzion ?att chiam .all ?att ?invoc funzion infatt , i parametr formal veng inizializz i valor parametr attual .import è coerenz tip numer parametr formal parametr attual , trasfer valor parametr attual parametr formal poss esser effettu conversion implic . </answer_text><num_votes>1</num_votes></answer><answer id="A3176"><answer_text>i parametr formal funzion argoment stess veng elenc nell&#39; header . quest verrann usat corp funzion svolg oper vol . i parametr attual (effett ) quell funzion vien attiv prend post (rispett l&#39; ordin veng elenc ) quell effett svolg funzion div cas . es int a(int n ) { return n*3 ; } n è parametr formal main { . a(x ) ; . } x è parametr effett prend post ogni n all&#39; intern funzion . </answer_text><num_votes>0</num_votes></answer><answer id="A3178"><answer_text>i parametr formal funzion quell usat intest , quand essa vien dichiar . esemp , funzion intest è &#34; int somm (int a,int b ) &#34; , i parametr formal &#34; &#34; &#34; b &#34; . i parametr attual funzion i parametr funzion vien attiv , dop è stat opportun dichiar . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3139"><question_text>si intend effett collateral (sid effects ) nell&#39; ambit funzion quand poss avven ? </question_text><answer id="A3133"><answer_text>&#34; sid effect &#34; è camb programm può compromett funzion programm può modific variabil present funzion . tip sid effect si verif quand veng utilizz variabil global all&#39; intern sottoprogramm funzion , esse sian defin all&#39; intern dell&#39; elenc variabil funzion . cas funzion , richiam , utilizz variabil global rend impreved comport funzion . </answer_text><num_votes>2</num_votes></answer><answer id="A3253"><answer_text>effett collateral vien fatt rifer quell si manifest inizializz variabil ambient global , ossi estern tutt funzion ; si inizializz &#34; int a; &#34; ambient global , essa può esser usat più funzion ...ma modific , può var signific assum all&#39; intern divers funzion . è l&#39; effett collateral . e&#39; perc sconsigl l&#39; utilizz variabil global . </answer_text><num_votes>1</num_votes></answer><answer id="A3134"><answer_text>&#34; sid effect &#34; è camb programm può compromett funzion programm può modific variabil present funzion . tip sid effect si verif quand veng utilizz variabil global all&#39; intern sottoprogramm funzion , esse sian defin all&#39; intern dell&#39; elenc variabil funzion . cas funzion , richiam , utilizz variabil global rend impreved comport funzion . </answer_text><num_votes>0</num_votes></answer><answer id="A3189"><answer_text>sid effect effett collateral è gener modif dell&#39; ambient global , ovver ciò è conten main funzion . nell&#39; ambit quest ultim si verif effett collateral quand si modific variabil non è stat dichiar all&#39; intern funzion , ovver nell&#39; ambient global , cos fac l&#39; effett esecu funzion non è più confin all&#39; intern stess , potrebb andar modific variabil utilizz funzion , compromett funzion . è sconsigl l&#39; uso variabil global . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3131"><question_text>perc funzion non può restitu un&#39; array , singol valor puntator ? </question_text><answer id="A3232"><answer_text>funzion non può restitu array appunt definizion funzion , puo esser restitu valor com puo esser inter puntator non vettor valor com array . funzion esegu ser oper parametr attual tram parametr formal risult final esser valor . </answer_text><num_votes>0</num_votes></answer><answer id="A3246"><answer_text>funzion è grad restitu valor puntator principal problem relat alloc static memor necessar c . c++ , dat possibil alloc dinam memor , si possibil estrarra array mediant funzion . </answer_text><num_votes>1</num_votes></answer><answer id="A3270"><answer_text>funzion non può restitu un&#39; array perc memor vien dealloc automat durant esecu ritorn singol valor puntator esso . </answer_text><num_votes>2</num_votes></answer><answer id="A3245"><answer_text>funzion tratt ogni singol element manier separ analizz singolar ! siccom array ser variabil memorizz spaz non conosc , funzion può restitu sol puntator singol cell dell&#39; array ! </answer_text><num_votes>1</num_votes></answer><answer id="A3244"><answer_text>funzion tratt ogni singol element manier separ analizz singolar ! siccom array ser variabil memorizz spaz non conosc , funzion può restitu sol puntator singol cell dell&#39; array ! </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3199"><question_text>com avvien passagg dat puntator funzion ? </question_text><answer id="A3229"><answer_text>attravers passagg rifer si forn funzion puntator (e l&#39; indirizz posizion memor ) variabil interess oper . mod funzion è grad lavor variabil stess , anzic cre cop com passagg valor . funzion success prim vann oper variazion stess variabil , vien modific . passagg rifer miglior l&#39; efficient programm , altern sarebber necessar &#39;n&#39; cop stess variabil &#39;n&#39; funzion . </answer_text><num_votes>2</num_votes></answer><answer id="A3193"><answer_text>passagg dat indirizz funzion avvien utilizz l&#39; oper dereferenz (* ) variabil vien pass com puntator ; simbol &#38; chiam funzion main affinc pass l&#39; indirizz * corp funzion modific valor variabil punt . </answer_text><num_votes>0</num_votes></answer><answer id="A3182"><answer_text>passagg indirizz avvien cop zon memor anness funzion puntator variabil interess . process è util quant si maggior leggerezz programm , riduc i dat cop istanz all&#39; altra . svantagg è per modif dirett variabil gioc , bisogn prest estrem attenzion quand usarl non modific valor dovrebber rest fiss . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3266"><question_text>è possibil implement funzion forz dichiar l&#39; header ? si qual problem potr incorr ? esemp dichiar prevent header funzion non è possibil dichiar stess . </question_text><answer id="A3235"><answer_text>l header contien inform import fin uso corrett funzion , dunqu è buon norm dichiar sempr . cas non si dichiar potr incapp error , com esemp restitu risult funzion non corrett parametr formal non corrett . es : cas non si dichiar tip variabil ritorn potr risult non conform richiest funzion . </answer_text><num_votes>0</num_votes></answer><answer id="A3220"><answer_text>funzion esser necessar dichiar attravers : -un test (o header ) : tip risult ritorn , identif sottoprogramm list dichiar argoment funzion . -un blocc , dett corp (o body ) funzion . poss cos not l&#39; header , manc l&#39; identif richiam sottoprogramm sarebb imposs . esemp : programm vien richiam funzion stampa(int x ) , dichiar non è defin nessun header , programm non sa è rifer stampa(int x ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3131"><answer_text>è possibil farl bisogn per star attent dov si implementa,un funzion esser chiam esser stat precedent dichiarata/definita.invoc funzion non dichiarata/defin precedent port error .se esemp defin funzion (senz header prevent ) l main,nel moment andiam richiam si gener error .stess avvien cas svilupp funzion un&#39; fil .se non dichiar l&#39; header funzion fil si trov prim usarl , quest non potr mai esser richiam . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ3135"><question_text>dovess camb conten array precedent dichiar qual parametr essenzial pass funzion ? tal funzion ritorn qualc tip dat ? com può esser defin tip funzion ? </question_text><answer id="A3187"><answer_text>camb conten array utilizz i parametr indirizz tram oper differenz , oper indirizz costruttor puntator . ciò consent ritorn più risult chiamant . avrem funzion procedur . </answer_text><num_votes>0</num_votes></answer><answer id="A3188"><answer_text>c funzion non può ritorn dirett array , modific array precedent dichiar , pass funzion indirizz non valor . pass valor funzion riusc modific local funzion chiamant (solit main ) non otterre alcun modif . non è necessar funzion ritorn dat perc modif già variabil dichiar funzion chiamant . tip funzion vien chiam procedur . far restitu array funzion dovre inser all&#39; intern struttur . </answer_text><num_votes>5</num_votes></answer></question><question id="QQ3177"><question_text>quand è più convenient usar passagg parametr valor passagg parametr indirizz ? </question_text><answer id="A3191"><answer_text>e&#39; più convenient usar passagg parametr valor indirizz , quand si effettu camb parametr procedur , perc quest camb non influenz i valor variabil programm principal , cio modif copp local non influenz parametr original , inoltr i valor variabil programm principal veng cop parametr procedur . infin passagg parametr valor è util isol ciò fa funzion rest programm . </answer_text><num_votes>1</num_votes></answer><answer id="A3174"><answer_text>normal passagg indirizz è più convenient , non seguent cas : -pass array dat : semplic puntator non è grad farl . -gest dat abbast piccol : non convien prend l&#39; indirizz . -modific i dat pass : far ciò è più semplic pass parametr . -struttur disordin : general è più complic oper puntator dat sint men logic . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3237"><question_text>è compost definizion funzion ? elenc spieg 2 component . </question_text><answer id="A3226"><answer_text>definizion funzion si avval nozion : quell test (o header ) quell corp (o body ) . l&#39; header funzion contien : tip risult &#34; codomin &#34; (es . int , float , ecc ... ) , l&#39; identif sottoprogramm (nom &#34; chiam &#34; funzion ) dichiar argoment &#34; domin &#34; (es . int x , int y ... ) . corp funzion è compost : part dichiar local (contien variabil necessar all&#39; esecu ) part programmat (contien istruzion l&#39; esecu funzion , es . cicl for , whil tutt oper ) . </answer_text><num_votes>3</num_votes></answer><answer id="A3138"><answer_text>definizion funzion è compost test corp . test , chiam header , contien inform principal corrett funzion funzion . essa si defin domin , codomin (utilizz parametr formal ) funzion . corp (body ) è costitu blocc istruzion (cicl , istruzion condizional , struct qualsias tip com ) implement effett comp funzion svolg . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3171"><question_text>si intend record attiv funzion ? contien serv ? </question_text><answer id="A3172"><answer_text>l&#39; insiem dat salv stack (com parametr , variabil local , ... ) è dett record attiv funzion , rappresent funzion esecuzione.il record attiv nasc muor essa esist specif ogni funzion . </answer_text><num_votes>3</num_votes></answer><answer id="A3250"><answer_text>record attiv è struttur dat salv memor moment chiam funzion . esso conten tutt parametr variabil local funzion gener . conten ino miltr inform riguard l&#39; indirizz ritorn (punt all&#39; istruzion success quell chiam funzion ) colleg record attiv funzion chiamant . serv manten memor inform necessar &#34; macchin astratt &#34; esegu funzion . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ3163"><question_text>contien test (o &#34; header &#34; ) funzion ? </question_text><answer id="A3140"><answer_text>test &#34; header &#34; , e&#39; part definizion funzion , contien inform piu&#39; rilev l&#39; uso corrett funzion . test e&#39; costitu : 1-tip risult (che costitu codomin funzion ) ; 2-dall&#39; identif sottoprogramm ; 3-dall list parametr funzion vien applic relat tip (la list parametr costitu domin funzion ) . esemp test &#39; : int cas ( int bas , int x ) dov int= tip parametr ritorn ; casa=identif funzion ( int bas , int x ) =parametr formal . </answer_text><num_votes>4</num_votes></answer><answer id="A3132"><answer_text>test funzion contien contien tip dat funzion ritorn (void , int , float... ) , funzion , parentes i parametr formal ovver i valor utilizz funzion . l&#39; header andrà poi scritt prim main fil .h </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3244"><question_text>com facc imped funzion modific parametr pass rifer ? </question_text><answer id="A3210"><answer_text>imped funzion modific paramentr pass rifer è sufficient utilizz parol chiav &#34; const &#34; davant tip dat nell&#39; intest funzion . esemp : void funzion (const int variabile1 , int variabile2 ) { variabile1 = 0 // error , c&#39; è const davant &#34; int variabile1 &#34; variabile2 = 0 // è possibil ! ! } </answer_text><num_votes>2</num_votes></answer><answer id="A3268"><answer_text>passagg rifer conten memor quell variabil non vien semplic cop utilizz funzion , vien propr fatt rifer posizion memor conten memor vien modific , non accad passagg valor dov conten memor quell variabil non vien modific . non avrebb sens pass rifer parametr non si vuol veng modific memor . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3140"><question_text>permett i sottoprogramm qual vantagg port programm ? </question_text><answer id="A3136"><answer_text>i sottoprogramm permett svolg part programm zon separ . codic risult cos più leggibil si poss effettu più oper simil semplic richiam programm riscriv . </answer_text><num_votes>0</num_votes></answer><answer id="A3141"><answer_text>i sottoprogramm (o funzion ) part programm veng defin fuor main mod allegger codic . sol sottoalgoritm limit (ad . es . codic riemp array valor gener casual ) veng richiam main specific valor (variabil puntator ) input restitu valor output (fann eccezion procedur funzion void non restitu null ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3185"><answer_text>i sottoprogramm programm &#34; asserv &#34; programm principal si suddivid funzion , cio restitu valor chiamant , procedur , cio non restitu specif valor (restitu void ) . i vantagg sottoprogramm : astrazion , cio si può far rifer mod sintet oper compless , riusabil , infatt consent scriv sol volt codic usarl più . i sottoprogramm infatt consist righ codic più men compless , volt scritt poss esser riutilizz semplic invoc main . </answer_text><num_votes>4</num_votes></answer><answer id="A3160"><answer_text>i sottoprogramm blocc istruzion permett semplific scrittur fas debugging relat programm . particol , tram l&#39; utilizz sottoprogramm è possibil far rifer determin sequenz istruzion utilizz semplic l&#39; identif assegnatogl , pass eventual variabil . inoltr , sottoprogramm può eventual esser utilizz div programm , evit cos programm necess dov scriv nuov . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3133"><question_text>si parl , quand si usa funzion inlin ? ? ? ? </question_text><answer id="A3255"><answer_text>premett definizion funzion specif &#34; inlin &#34; , si espand ogni chiam funzion codic implement funzion stess . l&#39; uso inlin permett elimin sovraccar dov gestion comun programm funzion . </answer_text><num_votes>2</num_votes></answer><answer id="A3175"><answer_text>risult funzion inlin e&#39; simil funzion macr , controll tip . entramb i cas l&#39; esecu e&#39; piu&#39; veloc funzion non inlin , quant non c&#39; chiam funzion run-tim . funzion inlin piu&#39; sicur funzion macr . codic funzion inlin , sar riprodott punt chiam ogni volt vien chiam funzion . funzion inlin contien poch righ codic non present loop . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3270"><question_text>qual mot variabil intern funzion divers conten programm poss ? </question_text><answer id="A3192"><answer_text>programm è present ambient global , qual tutt element poss esser &#34; vist &#34; var funzion facent part programm . ogni funzion , , si trov ambient local divers ; , element funzion poss esser usat referenz ambient , esser vist funzion . e&#39; è permess dichiar variabil purc ambient div . </answer_text><num_votes>2</num_votes></answer><answer id="A3165"><answer_text>poss perc funzion riconosc com variabil esistent sol quell intern stess quell global (dichiar prim main ) . infatt variabil non global è local funzion è defin , (esistent stess ) non collid quell dichiar main , per attenzion , tutt ciò è valid non si utilizz variabil global , tal cas variabil è present tutt programm , non permett cre variabil . </answer_text><num_votes>3</num_votes></answer><answer id="A3254"><answer_text>perc quand vien defin funzion si cre memor spec contenitor appartent funzion specif mot ogni variabil local defin all&#39; intern funzion può .si cre 2 funzion esemp 2 blocc poss conten variabil dell&#39; altra funzion computer variabil div ,con div comp , propr perc apparteng blocc div .sol variabil global defin all&#39; iniz programm può intercett tutt i blocc funzion . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3277"><question_text>parametr funzion sta main esser forz ugual parametr definizion funzion stess ? </question_text><answer id="A3197"><answer_text>, i parametr poss nom different , purc sian tip dichiar . i parametr present definizion funzion parametr formal , moment chiam funzion veng sostitu i parametr effett , quell specific main . esemp funzion è defin com void funzion (int , int b ) ; chiam , all&#39; intern main , può form divers , com esemp int dato ,datob ; funzion (dato ,datob ) ; funzion , fas esecu , sostitu i parametr effett dato datob quell formal b </answer_text><num_votes>4</num_votes></answer><answer id="A3262"><answer_text>parametr funzion sta main può differ parametr funzion stess . funzion sta all&#39; intern main è indipendent main i parametr (argoment ) valor local funzion richiam . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3186"><question_text>quand sens funzion ritorn tip dat &#34; void &#34; ? </question_text><answer id="A3156"><answer_text>quand funzion non restitu nessun valor </answer_text><num_votes>0</num_votes></answer><answer id="A3147"><answer_text>quand funzion non restitu nessun dat programm principal (main ) , scherm vien stamp funzion non vien memorizz main . </answer_text><num_votes>1</num_votes></answer><answer id="A3195"><answer_text>quand si dichiar funzion procedur (ess non ritorn nessun valor ) , tip void (cio vuot ) , poss utilizz esemp quand vogl modific valor alcun variabil implement funzion stamp : void stampa(int x ) { printf ( &#34; x=% d &#34; , x ) ; } ogni cas quand non interess funzion ritorn &#34; qualcos &#34; . </answer_text><num_votes>2</num_votes></answer><answer id="A3161"><answer_text>funzion &#34; void &#34; , gia &#39; dispon linguagg c , non ritorn alcun tip dat , vien inizializz mod : void nomefunzion ( ) ; esemp utilizz e&#39; funzion &#34; stamp &#34; , implement bas necessita&#39; programm , non svolg oper variabil dat precedent defin , azion ritorn risult . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3178"><question_text>different main funzion ? </question_text><answer id="A3242"><answer_text>funzion blocc istruzion poss esser invoc div punt programm dover esser riscritt ogni volt . poss esser consider sottoprogramm funzion principal e&#39; rappresent main . veng richiam funzion . e&#39; import ten present sebben main funzion , non e&#39; possibil richiam part programm . </answer_text><num_votes>4</num_votes></answer><answer id="A3218"><answer_text>funzion main ( ) sempr esser present programm c e&#39; prim funzion vien pass controll . linguagg c non si poss defin funzion all&#39; intern funzion , all&#39; intern main si potr invoc . programm termin termin funzion main ( ) , oppur quand vien invoc funzion exit ( ) librer standard . </answer_text><num_votes>1</num_votes></answer><answer id="A3206"><answer_text>main è funzion principal programm , all&#39; intern qual avvien chiam funzion ; affinc programm esegu conten necessar funzion main , eventual funzion entrerann gioc quand richiam main . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3227"><question_text>è possibil programm funzion main ? ? </question_text><answer id="A3153"><answer_text>, non è possibil . </answer_text><num_votes>0</num_votes></answer><answer id="A3183"><answer_text>no; compil , durant l&#39; esecu programm , trov più funzion main contemporane , dà error poic può esegu soltant . esist metod più funzion main programm bisogn ricorr strateg farn esegu l&#39; altra com esemp : -&#62; //////////////////////////// #defin main1 #includ &#60;iostream&#62; using namespac std ; #ifdef main1 int main ( ) //main 1 { [ ... ] return 0 ; } #els int main ( ) //main 2 { [ ... ] return 0 ; } #endif ///////////////////// </answer_text><num_votes>3</num_votes></answer><answer id="A3257"><answer_text>funzion main è f ?unzion vien esegu all&#39; iniz programm . essa può argoment restitu valor . nessun&#39; altra funzion programm main . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3262"><question_text>perc pass funzion matric si dev indic dimension quest&#39; ultima,com seguent cas : void init(int m[r ] [ c ] , int dim ) ; mentr vol pass vettor ciò non è necessar (void init(int v[ ],int dim ) ) ? </question_text><answer id="A3146"><answer_text>pass semplic vettor (quind compost list element raggrupp un&#39; unic rig ) , calcol bast scorr element quest rig bast sap posizion inizial element ; pass matric (quind element raggrupp più righ ) calcol oper somm offset dopp puntator sap dimension massim righ colonn è compost matric . </answer_text><num_votes>0</num_votes></answer><answer id="A3181"><answer_text>passagg matric funzion è sempr necessar specific dimension rig [c ] , [r ] non è davver necessar . pass array mod indic riesc calcol l&#39; indirizz qualsias element array (bast infatt somm all&#39; indirizz multipl dimension tip ) . si può pens array bidimensional com array i element righ ; mot è necessar conosc lunghezz righ [nc ] . </answer_text><num_votes>0</num_votes></answer><answer id="A3144"><answer_text>pass semplic vettor (quind compost list element raggrupp un&#39; unic rig ) , calcol bast scorr element quest rig bast sap posizion inizial element ; pass matric (quind element raggrupp più righ ) calcol oper somm offset dopp puntator sap dimension massim righ colonn è compost matric </answer_text><num_votes>1</num_votes></answer><answer id="A3142"><answer_text>pass semplic vettor (quind compost list element raggrupp un&#39; unic rig ) , calcol bast scorr element quest rig bast sap posizion inizial element ; pass matric (quind element raggrupp più righ ) calcol oper somm offset dopp puntator sap dimension massim righ colonn è compost matric </answer_text><num_votes>0</num_votes></answer><answer id="A3145"><answer_text>pass semplic vettor (quind compost list element raggrupp un&#39; unic rig ) , calcol bast scorr element quest rig bast sap posizion inizial element ; pass matric (quind element raggrupp più righ ) calcol oper somm offset dopp puntator sap dimension massim righ colonn è compost matric . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3233"><question_text>funzion implic parol chiav &#34; const &#34; ? cas è opportun utilizz ? </question_text><answer id="A3223"><answer_text>const serv indic compil cert variabil non può esser modific durant l&#39; esecu programma,vien utilizz funzion : -void stamp ( .. ) const { .. } -void funz(const../const* . . ) { .. } cas si rifer contenuto,nel variabil pass cop indirizzo.l variabil e/o indirizz sol lettur fas compil messagg error comunic eventual modif e&#39; opportun utilizz evit risult corrott dov modif dat inizial , error difficil rintracc . </answer_text><num_votes>1</num_votes></answer><answer id="A3201"><answer_text>parol chiav &#34; const &#34; vien utilizz evit camb conten variabil mentr quest vien , esemp , stamp . utilizz const pass dat sol lettur , vien modific , verr segnal error . </answer_text><num_votes>1</num_votes></answer><answer id="A3199"><answer_text>parol chiav const può qualific funzion membr imped qualsias modif class origin . esemp dichiar class &#34; aut &#34; &#34; funzion ( ) const &#34; essa non potr modific alcun valor variabil intern . funzion const util quant evit l&#39; accidental modif parametr potrebber introdurr error programm (ad esemp programm vien usat più non sann qual parametr poss esser modific ) </answer_text><num_votes>1</num_votes></answer><answer id="A3269"><answer_text>prim specific tip variabil si premett ?const ? conten variabil non può più esser modific . variabil ?const ? sempr esser inizializz . l&#39; uso const è consigl all&#39; altern scriv più stess costant , infatt programm decid camb valor durant compil programm usat const , è sufficient modif sol istruzion definizion . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3159"><question_text>accad memor quand main rich 2 funzion (un dietr l&#39; altra ) ? succed (sempr memor ) quand programm termin ? </question_text><answer id="A3167"><answer_text>vien cre macchin dedic prim funzion alloc relat memor . memor è organizz pil l&#39; ultim macchin cre è prim esser distrutt . quand prim funzion termin macchin dedic vien distrutt memor dealloc . stess accad second funzion . quand termin main macchin virtual vien distrutt memor dealloc perc anch&#39; esso è funzion . regol pil è rispett , infatt macchin main vien cre prim distrutt ultim . </answer_text><num_votes>3</num_votes></answer><answer id="A3180"><answer_text>zon memor vien cre singol funzion vien dett &#34; record attiv &#34; . quand rich funzion , si cre memor record attiv contenent i relat parametr formal funzion relat variabil local programm . quand programm termin , i record attiv cre precedent veng cancell perc variabil dichiar non serv più si può liber memor . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3192"><question_text>mod vien pass matric funzion ? perc ? </question_text><answer id="A3135"><answer_text>innanzitutt occorr chiar funzione/procedur può restitu valor ; mot non può restitur nemmen array n-dimensional (quind matric ) ; 2 mod pass array funzion : 1 ) pass l&#39; indirizz bas dell&#39; array : procedur agisc dirett sull&#39; array originar (guadagn veloc risparm memor cop l&#39; inter struttur contenent l&#39; array spaz memor riserv funzion com cas success ) 2 ) inglob l&#39; array struttur pass l&#39; inter struttur </answer_text><num_votes>1</num_votes></answer><answer id="A3219"><answer_text>pass matric com parametr funzion , dovr pass funzion parametr inter , specific numer rig colonn matric . esemp , prend matric &#34; int m[3 ] [4 ] &#34; funzion &#34; void funzion (int m ) &#34; , si decid pass funzion parametr è matric oper seguent mod : &#34; void funzion ( m [2 ] [3 ] ) &#34; . cas vien pass funzion valor inter , situ second rig terz colonn matric . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3206"><question_text>c si poss defin tip sottoprogramm : funzion procedur . qual different i ? </question_text><answer id="A3186"><answer_text>comp funzion è restitu valor chiamant , com cas funzion matemat . procedur svolg comp chiamant non restitu valor specif , restitu void . </answer_text><num_votes>1</num_votes></answer><answer id="A3256"><answer_text>funzion c ritorn valor dop averl otten ser oper mentr procedur non ritorn null m esegu oper esemp stamp vide ser parametr </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3153"><question_text>different c&#39; è passagg parametr valor passagg parametr indirizz ? </question_text><answer id="A3236"><answer_text>funzion vien pass parametr valor valor parametr effett (cio qual funzion vien attiv ) vien cop variabil funzion chiam rappresent parametr formal (cio l&#39; argoment funzion elenc test ) . passagg indirizz funzion invoc ricev puntator parametr effett . </answer_text><num_votes>0</num_votes></answer><answer id="A3202"><answer_text>quand si utilizz passagg valor , esemp funzion , vien pass cop dell&#39; argoment , mentr quand si pass valor indirizz vien pass appunt l&#39; indirizz locazion memor dell&#39; argoment . different i metod sta fatt passagg valor fa cop (e utilizz più memor ) variabil ; contrar passagg indirizz occup men memor perc appunt si pass l&#39; indirizz cell punt . </answer_text><num_votes>0</num_votes></answer><answer id="A3205"><answer_text>quand passagg parametr avvien valor , funzion vien effett pass cop ?argoment . graz meccan valor variabil programm chiamant non vien modific . passagg parametr rifer , funzion vien pass l ?indirizz non valor ?argoment . </answer_text><num_votes>0</num_votes></answer><answer id="A3200"><answer_text>passagg parametr valor cop e&#39; inefficent parametr e&#39; ingombr , parametr effett formal occup zon distint memor mentr passagg parametr indirizz c&#39;e &#39; modif parametr effett cop indirizz variabil . </answer_text><num_votes>0</num_votes></answer><answer id="A3190"><answer_text>passagg parametr valor cop l&#39; inter valor variabil question , passagg indirizz cop sol l&#39; indirizz quest variabil (ovver l&#39; indirizz cell memor ) , risparm memor calcol . bisogn ricord per si perd l&#39; indirizz variabil non cop non saràpiù possibil recuper , mentr pass valor bast ricord l&#39; identif assegn . </answer_text><num_votes>0</num_votes></answer><answer id="A3231"><answer_text>passagg valor si esegu si forn funzion , com variabil local , cop dat qual oper . si occup spaz memor termin esecu . cas passagg rifer (per indirizz ) si forn l&#39; indirizz memor qual dat è alloc ovver puntator quel dat . sistem present evident vantagg (fra i più import esser l&#39; unic possibil array , qual non è possibil l&#39; assegn ) , men dell&#39; utilizz &#34; const &#34; , rend possibil modif indesider valor . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ3216"><question_text>perc passagg struttur funzion convien farl rifer anzic cop ? </question_text><answer id="A3234"><answer_text>passagg rifer vien pass funzion puntator struttur (o più general variabil ) . funzion modif struttur quest modif permanent non accad pass struttur cop . infatt cas funzion vien pass cop struttur modif veng fatt tal cop non si ripresent struttur original vann pers termin funzion , men struttur non veng ritorn funzion . </answer_text><num_votes>2</num_votes></answer><answer id="A3215"><answer_text>passagg variabil qualsias (struttur men ) funzion implic sempr cop quest variabil . , cas variabil struttur , convien pass variabil rifer indirizz poic mod vien cop l&#39; indirizz variabil non tutt valor , conseguent risparm memor . </answer_text><num_votes>1</num_votes></answer><answer id="A3216"><answer_text>passagg variabil qualsias (struttur men ) funzion implic sempr cop quest variabil . , cas variabil struttur , convien pass variabil rifer indirizz poic mod vien cop l&#39; indirizz variabil non tutt valor , conseguent risparm memor . </answer_text><num_votes>2</num_votes></answer><answer id="A3155"><answer_text>convien punt vist dell&#39; alloc memor . rifer bast puntator cio occup memor 1 byte , mentr cop sprec numer byte par numer byte occup struttur . incid veloc nell&#39; esecu programm . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3146"><question_text>variabil global com poss esser utilizz ? qual side-effects si poss gener ? </question_text><answer id="A3249"><answer_text>variabil global chiam cos perc definizion avvien fuor qualsias funzion (compres main ) l&#39; utilizz tip variabil è comod abbiam bisogn far lavor funzion dat vogl quest non veng cancell funzion (risult simil si pass i dat funz ) i possibil side-effects : consum memor elev (le variabil veng cancell programm ) limit riusabil codic (le funzion funzion presenz variabil global ) </answer_text><num_votes>0</num_votes></answer><answer id="A3247"><answer_text>variabil global quell variabil veng dichiar all&#39; iniz programm , fuor qualsias funzion . esse visibil tutt funzion present programm , cio poss esser utilizz modific tutt funzion . potrebb sembr vantagg uso non sempr è raccomand , poic è facil sian modific accidental (side-effect ) rend più difficil ricerc error . </answer_text><num_votes>3</num_votes></answer><answer id="A3222"><answer_text>variabil global quell variabil dichiar fuor sottoprogramm , valid visibil tutt progett . l&#39; utilizz variabil global non comport fort risc bisogn star attent non dichiar variabil local ugual quell global , perc potrebb port conflitt . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3158"><question_text>succed cre più funzion , i parametr formal div ? (es . int nomefunz( ) { } int nomefunz(int x ) { } int nomefunz(int x1 , int x2 ) { } ) </question_text><answer id="A3163"><answer_text>tal oper c++ è tutt lec (non c ) . famigl funzion ugual com quest prend : &#34; overloading &#34; . esist per requis fondamental corrett funzion tal oper : 1 ) numer parametr formal divers funzion esser divers ; 2 ) definizion funzion parametr ugual (in numer ) divers tip vann evit . l&#39; es . ved corrett creazion funzion divers (1 ) . n.b. programm esegu funzion appropr second tip argoment pass . </answer_text><num_votes>2</num_votes></answer><answer id="A3208"><answer_text>c++ , different c , è lec (o più ) funzion , ammess per list parametr formal different , quest sian forn ordin divers (cos fondamental poic permett compil distingu ) . quand ciò succed , com mostr nell&#39; esemp , si verif cosiddett &#34; sovraccaric &#34; (overloading ) funzion . funzion sovraccaric veng utilizz esatt com funzion normal è comp compil decid qual version &#34; nomefunz&#34; utilizz , bas parametr forn . </answer_text><num_votes>1</num_votes></answer><answer id="A3241"><answer_text>risult error quant si cre confusion rich cell . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3174"><question_text>qual i vantagg si poss struttur progett div fil : &#34; .h &#34; &#34; main &#34; &#34; .cpp &#34; ? </question_text><answer id="A3439"><answer_text>separ codic librer permett spezz i programm part separ , ovvi rius stess aument leggibilità/comprension programm . librer static consent colleg codic conten (funzioni/tipi/classi/costanti/etc ) static esegu , colleg avvien fas compil . </answer_text><num_votes>0</num_votes></answer><answer id="A3203"><answer_text>i fil &#34; .cpp&#34; conteng l&#39; implement codic poss esser compil part non bisogn compil men non si modif , velocizz fas compil . vantagg è mantenibil codic , permett suddivid facil cas si dec programm team . </answer_text><num_votes>2</num_votes></answer><answer id="A3125"><answer_text>vantagg : - riutilizz fil div progett ; - facil port avant progett team compost più ; - material condivis ; ... </answer_text><num_votes>0</num_votes></answer><answer id="A3224"><answer_text>innanzitutt fatt fil div port ordin maggior progett (fondamental quand si cominc programm compless ) , com vantagg si possibil utilizz l&#39; insiem funzion fil defin com librer all&#39; intern qualsias progett . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3128"><question_text>è possibil funzion restitu array ? cas non foss possibil esist soluzion pot ? </question_text><answer id="A3214"><answer_text>non è possibil funzion restitu array perc vien tratt programm com puntator . soluzion problem è utilizz doubl (ricord doubl mul(doubl a[ ] , int n ) { ? . } ) , inoltr si può utilizz struct comport alcun risc : array veng pass indirizz valor metod è dispend punt vist dell&#39; ingombr memor . </answer_text><num_votes>1</num_votes></answer><answer id="A3184"><answer_text>c/c++ non è possibil cre funzion restitu array quant , volt uscit funzion , verrebb manc rifer puntator abbiam ritorn . soluzion possibil è quell cre tip struttur (struct ) conteng intern array , implement funzion mod ritorn un&#39; istanz quel tip struttur . esemp : typedef struct miastruttura{ int mioarray[n ] ; } ; miastruttur funzion ( ) { miastruttur daritorn ; [ ... ] return daritorn ; } trov array all&#39; intern struttur ritorn . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3256"><question_text>l&#39; utilizz funzion port consistent diminu dell&#39; alloc memor ? </question_text><answer id="A3263"><answer_text>utilizz funzion programm rend più semplic lettur eventual modif codic programm mucc istruzion sol funzion &#39;main&#39; . essend c++ linguagg alto livell , non è comp programm alloc memor funzion . bast pens funzion main quell librer (conten esemp &#60;iostream&#62; ) non necessit esser alloc dichiar , librer estern includ . quantit memor alloc dipend esclus dall&#39; oggett si vuol alloc . </answer_text><num_votes>3</num_votes></answer><answer id="A3212"><answer_text>funzion occup memor soltant moment vien invoc fin esist comp termin non si può dir è consistent diminu dell&#39; alloc memor . </answer_text><num_votes>0</num_votes></answer><answer id="A3158"><answer_text>! funzion serv ten codic pul applic programm top-down . si pass più 2 3 parametr anzic &#39; scriv registr si scriv ram . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3284"><question_text>dar definizion funzion (nel camp informat ) , sofferm particol sint test corp . </question_text><answer id="A3243"><answer_text>definizion funzion bas specif inizial sint linguagg , si present seguent form : tiporitorn nomefunzion (lista_parametr ) dichiarazione_parametr { definizioni/dichiar lista_statement } tiporitorn non vien specific , default vien assunt tip int. funzion non ritorn alcun risult . tiporitorn esser specific tip void . int fattorial (n ) int n; { if (n &#62; 1 ) return n*fattorial (n-1 ) ; } </answer_text><num_votes>0</num_votes></answer><answer id="A3213"><answer_text>definizion funzion è compost : 1 ) test (o header ) , contien inform rilev fin uso corrett funzion cio : 1 ) tip risult (il codomin funzion ) ; 2 ) identif sottoprogramma;3 ) list dichiar argoment funzion (il domin funzion ) ; 2 ) blocc , dett corp (o body ) funzion ; corp funzion è compost : -un part dichiar , dett part dichiar local , contien variabil necessar esecu ; -un part programmat , istruzion corp . </answer_text><num_votes>5</num_votes></answer></question><question id="QQ3230"><question_text>serv tip dat void ? </question_text><answer id="A3139"><answer_text>tip dat &#34; void &#34; (vuot ) è usat funzion non necessit ritorn alcun valor , quest funzion non sar necessar utilizz com &#34; return &#34; . esemp tipic funzion è classific com void è funzion stamp , non ritorn nessun dat non stamp vide valor . </answer_text><num_votes>3</num_votes></answer><answer id="A3265"><answer_text>tip dat void (o tip indefin ) vien utilizz quand valor ritorn funzion non esser pres consider ; vien dichiar tip void funzion non necess com return non ritorn alcun valor . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3274"><question_text>si intend &#34; macchin dedic &#34; , com quand vien realizz ? </question_text><answer id="A3196"><answer_text>macchin dedic vien realizz all&#39; invoc funzion . quest cre propr memor contenent variabil funzion , utilizz all&#39; intern quest (local ) , i parametr (gest com variabil local , inizializz all&#39; atto chiam ) risult funzion . memor vien distrutt termin funzion . esemp invoc funzion void f1 ( ) {printf ( &#34; % d &#34; , x ) ; } main ( ) {f1 ( ) ; } ; sar macchin dedic funzion void esegu istruzion pass macchin principal i parametr &#34; cop &#34; . </answer_text><num_votes>2</num_votes></answer><answer id="A3237"><answer_text>termin &#34; macchin dedic &#34; si intend ambient dedic comp determin oper . quest macchin dedic veng realizz quand , esemp , si vuol invoc funzion ; tal funzion vien invoc tram void . </answer_text><num_votes>0</num_votes></answer><answer id="A3248"><answer_text>macchin dedic è ambient dot propr memor , unic scop l&#39; esecu determin funzion . pratic , i computer un&#39; unic memor un&#39; unic cpu . realizz macchin dedic si ricorr sistem lif : stess macchin esegu programm mett paus l&#39; esecu , alloc determin spaz memor esegu sottoprogramm . termin memor vien recuper , l&#39; ambient rimoss pil ripr l&#39; esecu programm principal . </answer_text><num_votes>0</num_votes></answer><answer id="A3129"><answer_text>macchin dedic è oggett fisic virtual si occup svolg sol funzion . può esser realizz tram struttur lif (o fif ) vien realizz quand è necessar funzion nasc muoi all&#39; intern main prim si conclud programm . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3253"><question_text>qual&#39; è different variabil &#34; static &#34; , variabil &#34; dinam &#34; , variabil &#34; automat &#34; ? </question_text><answer id="A3171"><answer_text>variabil static sono&#38;#8239 ;alloc sol volt distrutt termin ?esecu programm , (lo quell global ) e&#38;#8239 ;fung canal comun funzion . variabil dinam veng cre distrutt dinam implicit sistem (automat ) esplicit programm , appos costrutt . variabil automat cre quand fluss esecu entra ambit visibil distrutt ?usc tal ambit ; veng dichiar funzion (inclus parametr ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3177"><answer_text>variabil &#34; static &#34; (o &#34; automat &#34; ) veng inizializz all&#39; iniz programm blocc programm quand blocc si chiud , esse veng distrutt automat . variabil &#34; dinam &#34; veng inizializz distrutt tram appos istruzion (new , del ) indipendent struttur programm , contrar variabil &#34; static &#34; , dimension può var durant l&#39; esecu programm . zon memor dedic variabil dinam è chiam &#34; heap &#34; l&#39; access è effettu tram puntator . </answer_text><num_votes>1</num_votes></answer><answer id="A3127"><answer_text>variabil è dett automat (o dinam ) , cess esist non appen fluss programm esce funzion variabil è defin . variabil è dett static &#34; vit &#34; coincid l&#39; inter dur programm : quand fluss programm torn funzion è defin variabil static , ritrov variabil com l&#39; lasc (cio valor ) . esist , variabil automat , specif aut , è inutil quant default (pu esser usat miglior leggibil programm ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3128"><answer_text>variabil è dett automat (o dinam ) , cess esist non appen fluss programm esce funzion variabil è defin . variabil è dett static &#34; vit &#34; coincid l&#39; inter dur programm : quand fluss programm torn funzion è defin variabil static , ritrov variabil com l&#39; lasc (cio valor ) . esist , variabil automat , specif aut , è inutil quant default (pu esser usat miglior leggibil programm ) . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3243"><question_text>qual&#39; è different test (head ) funzion corp (body ) ? programm suddivis più fil (es : main.cpp , funzion .h , funzion .cpp ) , dov colloc test dov corp ? </question_text><answer id="A3170"><answer_text>test funzion è part dov present dichiar , è tip dat funzion (int,void,c ) , funzion i parametr ingress , body contien variabil local part codic . test funzion conten vann sempr dichiar fil header (funzion .h ) , definizion compr head body inser fil .cpp (funzion .cpp ) . </answer_text><num_votes>1</num_votes></answer><answer id="A3173"><answer_text>test colloc funzion .h è tip tipodatoritorn nomefunzion (input ) ; body colloc funzion .cpp è tip tipodatoritorn nomefunzion (input ) { azionedellafunzion } </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3160"><question_text>è possibil funzion richiam stess ? si qual assum qual caratterist ? </question_text><answer id="A3261"><answer_text>sì , assum funzion ricors svolg propr richiam sè stess . ogni rich &#34; profond &#34; dell&#39; elabor aument , finc cert punt , scop vien raggiunt funzion ritorn . tipic esemp funzion ricors è visualizz dat struttur gerarc , esemp visualizz fil conten directory . vien cre funzion &#39;gener &#39; legg directory visualizz ogni fil . fil è directory , funzion richiam sè stess usand directory trov com parametr . </answer_text><num_votes>1</num_votes></answer><answer id="A3159"><answer_text>si , linguagg programm c è ammess chiam ricors sottoprogramm . programm ricors vien assoc un&#39; are dat non sottoprogramm ogni esecu , chiam record attiv . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3136"><question_text>cos&#39; è variabil automat com può esser implement (scriv esemp codic ) ? </question_text><answer id="A3225"><answer_text>variabil automat c c++ è sinonim variabil local . essa viv punt vien defin blocc &#34; } &#34; . memor vien riserv tram instruzion definizion com &#60;tipo&#62; &#60;nomevariabile&#62; ; dov &#60;tipo&#62; è tip variabil (int char float... ) variabil è sequenz caratter attravers sar possibil acced all&#39; are memor riserv . esemp codic : ...{ int a=0 ; //definizion variabil local automat a++ ; //oper ... } //fin blocc : memor riserv vien dealloc ... </answer_text><num_votes>3</num_votes></answer><answer id="A3126"><answer_text>variabil automat è variabil dichiar all&#39; intern funzion (o perlomen dichiar &#34; blocc &#34; racchius parentes graff ) ; pratic vien alloc part memor manier dinam esemp : void main(void ) { int x = 1; printf ( &#34; % d , %d &#34; ,x ) ; } dov x è variabil automat </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3281"><question_text>qual i 3 cas compless dell&#39; input spiegan funzion . </question_text><answer id="A3240"><answer_text>compless cas peggior , cas med cas miglior . 1 ) cas miglior è cas i dat input i miglior dat possibil l&#39; algoritm , cio quell richied men elabor esser tratt . 2 ) cas med permett stud l&#39; algoritm bas frequenz si verific input compless ciascun essi .e&#39; più util analizz quant forn real indic compless dell&#39; algoritm . 3 ) cas peggior è cas i dat input richied massim numer pass l&#39; algoritm . </answer_text><num_votes>3</num_votes></answer><answer id="A3211"><answer_text>algoritm ricerc esist cas compless , : -il cas peggior è cas numer ricerc corrispond numer element impieg è par n (numer element ) . -il cas miglior è cas l&#39; element cerc è list impieg unitar ricerc . -il cas med è più difficil calcol , perc dip dall&#39; algoritm utilizz ricerc esemp ricerc lin corrispond n/2 , mentr ricerc binar è par log2 ( n ) </answer_text><num_votes>2</num_votes></answer></question><question id="QQ3167"><question_text>è compost definizion funzion ? è costitu corp ? </question_text><answer id="A3152"><answer_text>&#39;definizion funzion &#39; si intend l&#39; &#34; header &#34; ( test ) ; esso contien inform relat : -al tip risult ritorn funzion (es . int) ; -all&#39; identif funzion (nom ) ; -ai parametr formal funzion identrific tip (quell parentes ) ; es . int diff(int a,int b ) ; corp funzion è costitu : -un part dichiar local contien variabil local intern funzion . -un part codic contenent oper sarann esegu moment dell&#39; invoc . </answer_text><num_votes>1</num_votes></answer><answer id="A3164"><answer_text>c/c++ funzion è compost test (header ) corp (body ) . prim , defin com &#34; prototip &#34; post solit header-files , è costitu : -tip risult (che esser unic ) specif &#34; void &#34; (se non ritorn nessun parametr ) -nom funzion -argoment parametr formal (sostitu quell effett moment dell&#39; invoc funzion ) blocc corp è form : -part dichiar (di variabil local necessar all&#39; esecu ) -part programmat content istruzion ver propr implement . </answer_text><num_votes>1</num_votes></answer><answer id="A3169"><answer_text>definizion funzion si divid header : dichiar progett .h seguent struttur : tipodelrisult nomedellafunzion (tipodellargoment argoment ) ; body : implement progett .c/.cpp seguent struttur : header{ part dichiar local , ossi variabil necessar funzion sottoprogramm non specific nell&#39; header ; part programmat , ossi istruzion funzion comp ; return variabiledaritornaredopoavereffettuatoleistru ; } cas procedur , ossi funzion non ritorn null , prim dell&#39; header </answer_text><num_votes>1</num_votes></answer><answer id="A3168"><answer_text>definizion funzion si divid header : dichiar progett .h seguent struttur : tipodelrisult nomedellafunzion (tipodellargoment argoment ) ; body : implement progett .c/.cpp seguent struttur : header{ part dichiar local , ossi variabil necessar funzion sottoprogramm non specific nell&#39; header ; part programmat , ossi istruzion funzion comp ; return variabiledaritornaredopoavereffettuatoleistru ; } sol 500 caratter è difficil spieg . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3187"><question_text>spieg brevement i tip passagg variabil funzion : passagg dei parametr valor (o cop ) indirizz </question_text><answer id="A3264"><answer_text>passagg parametr valor è mod comun pass inform funzion è mod normal utilizz c++ . passagg parametr rifer (o referenc ) , funzion vien pass l ?indirizz non valor ?argoment . approcc richied men memor chiam valor , consent modific valor variabil livell visibil estern funzion metod . passagg indirizz bisogn pass funzion argoment tip puntator </answer_text><num_votes>2</num_votes></answer><answer id="A3204"><answer_text>passagg parametr valor avvien copp (dall&#39; ambient main all&#39; ambient searc ) svantagg i parametr effett quell formal occup zon divers memor sistem passagg copp divent inefficient valor ingombr . passagg indirizz , , utilizz parametr formal tip puntator qual non contien i dat variabil contien l&#39; indirizz cell memor dov essi conten acced vien usat l&#39; oper de-referenz (* ) permett acced conten cell memor </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3145"><question_text>quand si dichiar funzion vien alloc macchin memor , comp svolg oper richiest funzion . esist per part memor estern tutt quest macchin chiam ambient global : contien ? succed vien modific ? </question_text><answer id="A3154"><answer_text>l&#39; ambient global contien tutt part compong programm : variabil global , local , sottoprogramm . e&#39; riconduc scatol veng inser tant oggett distint stacc uni , tutt indispens otten risult final . apport modif singol blocc quest si ripercuot sottoprogramm interess mentr , modific variabil global , si modif ogni part programm principal quest present . variabil global vann usat necessar vann gest accurat . </answer_text><num_votes>2</num_votes></answer><answer id="A3258"><answer_text>c , ogni funzion ambient local compr i parametr variabil defin local funzion . esist per ambient global : dov tutt funzion defin . si poss defin variabil , dett variabil global denomin &#34; global &#34; der fatt l&#39; environment definizion quest variabil non coincid nessun funzion (neppur main ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3252"><answer_text>l&#39; ambient global question è descritt com part memor tutt funzion variabil veng defin . tal variabil dett appunt variabil global . denomin &#34; global &#34; der fatt l&#39; environment definizion quest variabil non coincid nessun funzion (neppur main ) è un&#39; alloc sè . quest part non può esser modific dall&#39; utent quant è prerog sistem . </answer_text><num_votes>0</num_votes></answer><answer id="A3238"><answer_text>l&#39; ambient global contien variabil global visibil tutt programm poss esser usat main funzion . realt variabil global cre più problem quant risolv , ragion uso è general fortement sconsigl . anzitutt rend programm più difficil legg corregg cas error : infatt variabil può esser usat modific tutt , valor può esser camb qualsias punt programm (e addirittur all&#39; intern different fil ) . </answer_text><num_votes>0</num_votes></answer><answer id="A3209"><answer_text>memor estern ambient global (in c particol ) scop conten variabil dichiar fuor main qualsias altra funzion , qual valg durant tutt l&#39; esecu programm , veng per disalloc quand programm termin . quest variabil vien modific main funzion quell funzion variabil vien modific , creiam funzion variabil avrà sempr valor quell dichiar ambient global (a men non modific quell funzion nuov ) . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3282"><question_text>e&#39; possibil pass vettor matric funzion ? sì , com ? </question_text><answer id="A3150"><answer_text>si , è possibil . si pass puntator (indirizz ) prim zon memor alloc vettor matric . dopodic variabil puntator si preoccup effettu tutt oper funzion svolg vettor matric . header funzion , i parametr ingress , vien usat sint : tipod vett[ ] . stess matric si fa : tipod mat[ ] [ ] . </answer_text><num_votes>1</num_votes></answer><answer id="A3143"><answer_text>si , è possibil . si pass puntator (indirizz ) prim zon memor alloc vettor matric . dopodic variabil puntator si preoccup effettu tutt oper funzion svolg vettor matric . header funzion , i parametr ingress , vien usat sint : tipod vett[ ] . stess matric si fa : tipod mat[ ] [ ] . </answer_text><num_votes>0</num_votes></answer><answer id="A3179"><answer_text>passagg vettor com parametr avvien tram passagg puntator solit bisogn pass numer element poic funzion altriment non capac conosc dimension vettor . esemp : void inseriscivettor (vettor v , int dim ) { ? ....... } . proced metod risult valid quand si consider matric . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ3238"><question_text>perc è consigl defin mod separ header body funzion ? </question_text><answer id="A3198"><answer_text>non si defin separat header i body , si cre rifer funzion . int numeroprim (int n ) ; quest tecnic è util cas : quand realizz programm fil , defin tutt i rifer funzion prim cre esse creazion progett più fil , è buon norm scriv rifer fil &#34; .h &#34; ( header-files ) , mentr funzion si implement fil &#34; .cpp &#34; ( implementation-fil ) . entramb i cas si possibil implement funzion nell&#39; ordin prefer si ordin maggior codic . </answer_text><num_votes>1</num_votes></answer><answer id="A3221"><answer_text>quand si scriv programm gross dimension è consigl suddivid i programm modul separ più ordin rend più leggibil codic . funzion main ( ) sar conten fil (es : ?mioprogr.c? ) . ?buon norm dichiar struttur header funzion fil separ (header fil ) includ tal modul (es : #includ ?mioprogr.h ? ) . fin è cre fil dov verr implement body funzion . </answer_text><num_votes>1</num_votes></answer><answer id="A3217"><answer_text>inanz tutt bisogn dir non è obbligator , infatt poss defin funzion , cosiddett prototip . vantagg farl consist fatt codic divent più leggibil facil interpret dall&#39; uom , permett compil c controll sint chiam funzion . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ3202"><question_text>com si calcol compless funzion ricors quell non ricors ? </question_text><answer id="A3166"><answer_text>nell&#39; informat , funzion ricors class funzion numer natural numer natural &#34; calcol &#34; qualc sens intuit . infatt teor calcol si mostr funzion ricors corrispond precis quell funzion poss esser calcol tram macchin turing . non tutt funzion calcol , cio ricors , quest si dic funzion non ricors veng calcol attravers alcun teorem , com ferm . </answer_text><num_votes>0</num_votes></answer><answer id="A3230"><answer_text>ogni volt funzion invoc stess (funzion ricors ) , sta richied soluzion problem più semplic partenz . si arriv dunqu problem dimension sufficient piccol poter esser affront ,dett cas bas . punt vien restitu rispost , casc all&#39; , permett calcol rispost intermed più compless rimast sospes . calcol compless è necessar introdurr equazion ricorrent , l&#39; appunt ,descriv funzion termin valor input sempr più piccol . </answer_text><num_votes>3</num_votes></answer><answer id="A3227"><answer_text>compless funzion può esser descritt attravers l&#39; analis var fattor qual esecu , memor occup svolg difficolt l&#39; elabor incontr acquis input restitu output . quest fattor fortement influenz dall&#39; efficient dell&#39; algoritm scelt funzion . funzion ricors compless può esser inoltr calcol bas quant vien semplific ogni ricorsion problem inizial . </answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L27" title="Architettura del Calcolatore, Algebra di Boole" date="2013-09-23"><question id="QQ2211"><question_text>quand si parl sistem oper bas micro-kernel si intend ? sistem oper micro-kernel applic utent poss esser esegu modal kernel mod ? </question_text><answer id="A2159"><answer_text>s.o. bas micro-kernel , kernel , elev cost computazional , è ridott all&#39; essenzial , ossi forn soltant minim gestion dell&#39; hardw bass livell (driver ) memor deleg rest part estern dett server modul comun kernel . dunqu un&#39; applic utent non richied dirett gestion &#34; polit &#34; meccan process , può esser esegu s.o. micro-kernel (anc kernel mod ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2188"><answer_text>premett non abbiam svolt quest argoment lezion . microkernel different kernel implement men funzion , è più facil implement . rend dispon i serviz necessar softw veng cre &#34; modul server &#34; &#34; livell &#34; più alto . signif quest modul server crash , non provoc blocc dell&#39; os , può esser riavv part . second domand kernelmod si intend ? line com ?non avrebb sens </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2216"><question_text>relazion esist frequenz clock veloc computer ? </question_text><answer id="A2261"><answer_text>clock è orolog intern calcol graz impuls gener scand cpu (central processing unit ) . conseguent maggior è frequenz impuls clock maggior oper calcol può esegu nell&#39; unit . </answer_text><num_votes>1</num_votes></answer><answer id="A2157"><answer_text>veloc frequenz clock è numer commut i livell logic &#34; 0 &#34; &#34; 1 &#34; l&#39; unit elabor (cpu ) è grad esegu nell&#39; unit , è espress cicl , hertz . frequenz clock veloc computer dirett proporzional : infatt , maggior è frequenz , più oper poss esser esegu lass maggior è veloc computer . </answer_text><num_votes>3</num_votes></answer><answer id="A2267"><answer_text>velocitã ?â elabor computer ã ?â¨ dirett proporzional velocitã ?â clock cpu . infatt velocitã ?â clock elev garant maggior numer istruzion esegu nell&#39; unitã ?â , nonost non l&#39; unic fattor concorr ala velocitã ?â macchin . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2241"><question_text>esist tip rappresent binar numer real , virgol fiss virgol mobil . qual è rappresent più vantagg qual mot ? </question_text><answer id="A2138"><answer_text>rappresent piu&#39; vantagg e&#39; quell virgol mobil (floating point ) utilizz notazion esponenzial : i vantagg riguard possibil &#39; rappresent poch cifr numer grand oppur rappresent precision numer piccol ; sostanz , rappresent virgol mobil estend l&#39; intervall numer rappresent , par &#39; cifr , notazion virgol fiss . </answer_text><num_votes>0</num_votes></answer><answer id="A2260"><answer_text>sicur rappresent virgol mobil , quant permett scriv numer com &#34; notazion scientif &#34; , riduc quantit memor necessar memorizz . </answer_text><num_votes>0</num_votes></answer><answer id="A2202"><answer_text>rappresent più vantagg è quell virgol mobil (floating point ) utilizz notazion esponenzial ; i vantagg riguard possibil rappresent poch cifr numer grand oppur rappresent precision numer piccol . sostanz rappresent virgol mobil estend l’intervall numer rappresent , parit cifr , notazion virgol fiss . </answer_text><num_votes>0</num_votes></answer><answer id="A2112"><answer_text>rappresent binar più vantagg i numer real è quell virgol mobil quant essa permett rappresent manier compatt numer grand , piccol . rappresent virgol mobil standard 32 bit è seguent : bit codif segn , i success 8 codific l&#39; esponent &#34; &#34; indic l&#39; ordin grandezz numer infin i restant 23 codific mantiss &#34; m &#34; qual rappresent cifr signif numer . </answer_text><num_votes>1</num_votes></answer><answer id="A2200"><answer_text>rappresent più vantagg è quell virgol mobil (floating point ) utilizz notazion esponenzial ; i vantagg riguard possibil rappresent poch cifr numer grand oppur rappresent precision numer piccol . sostanz rappresent virgol mobil estend l’intervall numer rappresent , parit cifr , notazion virgol fiss . </answer_text><num_votes>0</num_votes></answer><answer id="A2135"><answer_text>e&#39; sicur più vantagg rappresent virgol mobil qual permett esprim numer grand poch cifr precision numer piccol . rappresent virgol mobil si utilizz notazion esponenzial 32 bit dov 1 bit indic segn , 8 bit l&#39; esponent , dett caratterist , indic posizion virgol infin 23 bit mantiss rappresent cifr più rappresent numer . </answer_text><num_votes>2</num_votes></answer><answer id="A2205"><answer_text>rappresent più vantagg è quell virgol mobil (floating point ) utilizz notazion esponenzial ; i vantagg riguard possibil rappresent poch cifr numer grand oppur rappresent precision numer piccol . sostanz rappresent virgol mobil estend l’intervall numer rappresent , parit cifr , notazion virgol fiss . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2323"><question_text>com avvien gestion perifer sistem ? è caric bus sistem oper ? polling l&#39; interrupt ? </question_text><answer id="A2254"><answer_text>gestion perifer e&#39; caric sistem oper , puo&#39; gest metod : polling interrupt . cas , processor continu verific dat e&#39; arriv perifer mentr , processor vien notific dell&#39; arriv dat ; notif interromp processor stav fac . gestion polling e&#39; semplic , svantagg ten processor sospes cicl attes dat . </answer_text><num_votes>3</num_votes></answer><answer id="A2255"><answer_text>gestion perifer ã¨ caric sistem oper , puã² gest metod : polling interrupt . </answer_text><num_votes>0</num_votes></answer><answer id="A2099"><answer_text>gestion perifer sistem ã ?â¨ comp design so ; tal gestion vien effetu tram cosidett interrupt ; interrupt : richiest d&#39; attenzion part perifer cpu ; si &#34; interrompe/freeze/sospes momentan &#34; cosã ?â¬ process esecu , vien &#34; interrog &#34; perifer oper conclus si ritorn all&#39; esecu precedent . </answer_text><num_votes>0</num_votes></answer><answer id="A2147"><answer_text>gestion perifer è affid sistem oper qual , attravers programm denomin driver , gest oper input/output perifer . polling l&#39; interrupt different modal controll gestion perifer i/o . polling è controll ciclic perifer , mentr l&#39; interrupt è segnal tip asincr invi cpu , vien gener verific event estern intern . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2329"><question_text>qual different principal concett &#34; compil &#34; &#34; interpret &#34; linguagg ? </question_text><answer id="A2095"><answer_text>quand programm cre softw ,ovver codic sorgente,in determin linguagg programm esser &#34; cap &#34; computer qualsias automa,dev esser tradott linguagg macchin ,ovver oper bassissim livell . oper softw : compil prend l&#39; inter codic sorgent traduc linguagg macchin cre cos l&#39; esegu , bast error non vien cre . l&#39; interpr traduc rig rig esegu . </answer_text><num_votes>1</num_votes></answer><answer id="A2266"><answer_text>termin &#34; compil &#34; si intend traduzion tutt programm linguagg . metod traduzion è più veloc puo&#39; richied . &#34; interpret &#34; , , si intend traduzion line volt . metod l&#39; esecu è più lent programm è maggior interatt . </answer_text><num_votes>1</num_votes></answer><answer id="A2144"><answer_text>i linguagg compil , different quell interpret , veng scritt editor si occup controll correttezz codic poi compil , ovver , ogni istruzion vien trasform corrispondent codic linguagg macchin può esser esegu processor . mentr linguagg interpret veng elabor vol veng esegu istruzion cos com descritt codic sorgent controll error . </answer_text><num_votes>1</num_votes></answer><answer id="A2311"><answer_text>termin &#34; compil &#34; si intend traduzion tutt programm linguagg . metod traduzion ã¨ piã¹ veloc puo&#39; richied . &#34; interpret &#34; , , si intend traduzion line programm volt . metod l&#39; esecu ã¨ piã¹ lent programm ã¨ piã¹ interatt . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2275"><question_text>qual categor principal istruzion esegu processor ? </question_text><answer id="A2265"><answer_text>istruzion esegu processor poss esser classific categor principal : â ? -&#62; istruzion aritmet : â ? ¢ somm , sottrazion , moltipl , division , shift ecc . â ? -&#62; istruzion controll â ? ¢ incondizion , condizional , salt , chiam sottoprogramm -&#62;istruzion trasfer dat : â ? ¢ registr allâ ? ? â ? ¢ registr memor vicevers </answer_text><num_votes>0</num_votes></answer><answer id="A2264"><answer_text>istruzion esegu processor poss esser classific categor principal : -&#62; istruzion aritmet : * somm , sottrazion , moltipl , division , shift ecc . -&#62; istruzion controll * incondizion , condizional , salt , chiam sottoprogramm -&#62;istruzion trasfer dat : * registr all&#39; * registr memor vicevers </answer_text><num_votes>0</num_votes></answer><answer id="A2128"><answer_text>categor principal istruzion esegu processor : 1 ) istruzion aritmet (per esemp somme,sottr ,moltipl division ) 2 ) istruzion controll (per esemp condizional chiam sottoprogramm ) 3 ) istruzion trasfer dat (da registr all&#39; registr vers memor vicevers ) esemp istruzion aritmet potrebb esser : esegu l&#39; oper a=b+c </answer_text><num_votes>2</num_votes></answer><answer id="A2293"><answer_text>processor è l&#39; unit principal personal computer funzion principal è l&#39; elabor dat dell&#39; inter macchin . </answer_text><num_votes>0</num_votes></answer><answer id="A2193"><answer_text>principal tipolog istruzion : istruzion aritmet , istruzion controll istruzion trasfer dat . prim esegu nell&#39; unit aritmetico-log registr cpu dedic . istruzion controll veng elabor principal nell&#39; unit controll si occup prel , decodif dell&#39; esecu dat . infin istruzion trasfer pass i dat registr all&#39; memor cpu </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2368"><question_text>qual oper boolean propriet ? com veng rappresent linguagg programm c ? </question_text><answer id="A2272"><answer_text>oper logic boolean not ,and ,or . not (unar ) com risult l&#39; oppost dell&#39; oper . and com risult vero(1 ) entramb operand ver , or almen operand ã¨ ver . proprietã : commut : and b=b and distribut : and (b or c ) = (a and b ) or (a and c ) (valid invert and or ) linguagg programm c not ,and ,or rappresent rispett ! , &#38;&#38; , || utilizz espression logic . </answer_text><num_votes>3</num_votes></answer><answer id="A2258"><answer_text>oper boolean : -not &#39;! &#39; (not rend l&#39; oppost valor ) ; -and &#39;&#38;&#38; &#39; (a and b è ver entramb oper ver ) ; -or &#39;|| &#39; (a or b è ver operand è ver ) ; propriet propriet commut distribut : -commut : or b=b or , and b=b and a; -distribut : or (b and c ) = (a or b ) and (a or c ) , and (b or c ) = (a and b ) or (a and c ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2271"><question_text>serv codif ca2 &#34; complement 2 i numer inter &#34; ? </question_text><answer id="A2125"><answer_text>codif ca2 serv rappresent i numer negat sistem binar , tal sistem si bit inizial (più sinistr ) numer , segnal negat (1 ) posit (0 ) , consent inoltr sol rappresent 0 richied circu somm sottrazion </answer_text><num_votes>2</num_votes></answer><answer id="A2118"><answer_text>codif ca2 complement i numer inter serv trov valor decimal numer inter segn part numer binar vicevers . infatt bit più signif (msb ) , ovver più sinistr è 0 numer decimal sar sicur posit , contrar l&#39; msb è 1 numer sar negat . codif ca2 n bit è possibil rappresent i valor -2^ (n-1 ) 2^ (n-1 ) -1 . </answer_text><num_votes>3</num_votes></answer><answer id="A2122"><answer_text>codif ca2 permett rappresent numer inter negat risult util ambient informat perc calcol non controll segn numer rappresent sap usar l&#39; addizion sottrazion semplic svolg sol oper , ovver l&#39; addizion velocizz tutt . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2284"><question_text>qual principal different dram (dynamic ram ) sram (static ram ) ? </question_text><answer id="A2148"><answer_text>dram richied i dat veng period aggiorn esser manten memor , mentr sram conserv finc vien aliment corrent . consegu sram è più veloc consum men potenz dram . struttural sram necess più transistors conten cert quantit dat dram . dram è più econom è maggior utilizz . </answer_text><num_votes>2</num_votes></answer><answer id="A2301"><answer_text>principal different dram sram ã¨ conten dram , tip ram immagazzin ogni bit divers condes , necess esser &#34; rinfresc &#34; period , consent maggior densitã sram . sram inoltr bass temp lettur bass consum , cost piã¹ elev dov complessitã cell memor compong . sram puã² inoltr manten inform teoric infin , contrar dram perd inform quand cess l&#39; aliment sistem . </answer_text><num_votes>0</num_votes></answer><answer id="A2249"><answer_text>principal different dram sram ã ? ? ã ?â¨ dram , tip ram immagazzin bit ogni divers condes , conten &#34; rinfresc &#34; period . inoltr , quand cess l&#39; aliment condes perd caric , l&#39; inform vien pers . sram , contrar non necess refresh puã ? ? ã ?â² manten inform teoric infin . inoltr bass temp lettur bass consum . </answer_text><num_votes>0</num_votes></answer><answer id="A2151"><answer_text>sram è ram volatil non necess refresh , i banc memor consent manten inform teoric infin , bass temp lettur bass consum . necess usar component cell rend per più costos dram . dram , è tip ram refresh i banc memor necessit . </answer_text><num_votes>0</num_votes></answer><answer id="A2152"><answer_text>sram è ram volatil non necess refresh , i banc memor consent manten inform teoric infin , bass temp lettur bass consum . necess usar component cell rend per più costos dram . dram , è tip ram refresh i banc memor necessit . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2351"><question_text>i dat istruzion esegu dall&#39; unit elabor codific form binar ; perc calcol i dati/l istruzion veng spess memorizzati/ form ottal esadecimal ? </question_text><answer id="A2113"><answer_text>perc entramb util memorizz valor registr quand ogni cifr traduc rispett 3(ottal ) 4( esadecimal ) bit sistem binar . particol sistem esadecimal permett memorizz valor grand utilizz , termin byte , minor quantit memor . esemp byte può esser espress tram sol cifr esadecimal permett cos risparm memor . </answer_text><num_votes>1</num_votes></answer><answer id="A2119"><answer_text>approssim men possibil , dat form binar present i numer 0 1 . </answer_text><num_votes>0</num_votes></answer><answer id="A2114"><answer_text>perc entramb util memorizz valor registr quand ogni cifr traduc rispett 3(ottal ) 4( esadecimal ) bit sistem binar . particol sistem esadecimal permett memorizz valor grand utilizz , termin byte , minor quantit memor . esemp byte può esser espress tram sol cifr esadecimal permett cos risparm memor . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2239"><question_text>mod mapp karnaug poss minimizz funzion boolean ? </question_text><answer id="A2316"><answer_text>mapp k . sn metod grafic x semplific funz boolean , altern all&#39; uso teorem algebr b ogni mapp grigl 2^n casell dov n e&#39; num variabil .ogn casell avra valor funz calcol particol combinaz variabil es n=not a,b,c variab f=n ( ) &#38; &#38; n ( b ) &#38; &#38; n (c ) | | n ( ) &#38; &#38;b&#38;&#38; n (c ) | | n ( ) &#38; &#38;b&#38;&#38;c|| a&#38;&#38;b&#38;&#38;c|| a&#38;&#38; n ( b ) &#38; &#38;c mapp |00|01|11|10&#60; - (a ,b ) 0| 0 | 1 | 0 | 0 1| 1 | 1 | 1 | 1 ^ | c colonna01 : funzion ver a=0 b=1 indip c equival : not( ) &#38; &#38;b riga2 funz sempr ver equival : c f=1-&#62;o b=1 n( ) &#38; b=1 si ric : f=not( ) &#38; &#38;b|| c </answer_text><num_votes>0</num_votes></answer><answer id="A2070"><answer_text>mapp karnaug particol form tabell verit , consent individu immediat , qualsias funzion boolean , part poss esser semplific utilizz seguent propriet dell&#39; algebr bool . _ _ axb + axb = ax(b+b ) = _ (a+b ) ( a+b ) = b tal metod grafic comport riduzion compless funzion . applic per risult semplic numer variabil par 4 . </answer_text><num_votes>2</num_votes></answer><answer id="A2154"><answer_text>mapp karnaug poss minimizz funzion boolean perc capac compil valor risul espression funzion singol operand semplific svolg inter oper logic . </answer_text><num_votes>0</num_votes></answer><answer id="A2262"><answer_text>dat un&#39; espression , mapp karnaug permett evidenz implic (particolar grupp valor ingress dann uscit valor ) , codific ser and . l&#39; espression inizial equival implic . l&#39; utilizz mapp si confã â sistem non super i 6 valor ingress , altriment l&#39; analis divent pesant . risult mapp non e&#39; univoc , funzion sarã minimizz com graz semplif algebr . </answer_text><num_votes>2</num_votes></answer><answer id="A2150"><answer_text>mapp karnaug poss minimizz funzion boolean perc permett valut risolv i valor binar dell&#39; espression funzion singol operand (ver fals , 0 1 ) semplific svolg dell&#39; espression logic . </answer_text><num_votes>0</num_votes></answer><answer id="A2168"><answer_text>mapp karnaug permett soluzion funzion boolean tram costruzion grafic (un tabell ) riduc tutt banal oper somm prodott . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2266"><question_text>different c&#39; è #defin n 50 const int n=50 ? </question_text><answer id="A2093"><answer_text>&#34; const int n=50 &#34; è dichiar costant , assoc permanent valor identif , cas assoc variabil inter n valor 50 . &#34; # defin n 50 &#34; è dichiar variabil non riserv spaz memor sostitu valor costant post dell&#39; identif vien esegu processor compil . </answer_text><num_votes>0</num_votes></answer><answer id="A2312"><answer_text>#defin , essend istruzion preprocessor , compil esegu semplic sostitu testual tutt occorrent all&#39; intern compil prim compil , pratic può , minim part , rend po&#39; più veloc l&#39; esecu . const , costant vien elabor sol volt vien alloc spaz conten stack , compil esegu controll valid â costant (short , word , etc ... ) . const vien richiam sorgent indirizz . </answer_text><num_votes>0</num_votes></answer><answer id="A2166"><answer_text>definizion costant &#34; # defin &#34; non produc nessun occup memor , mentr l&#39; istruzion c &#34; const &#34; riserv memor costant vien defin , cas inter . &#34; # defin &#34; val tutt sorgent (programm ) quel punt poi , mentr &#34; const &#34; è limit function corrent . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2295"><question_text>parl espression boolean , qual è signific contraddizion ? signific tautolog ? </question_text><answer id="A2195"><answer_text>l` algebr bool è bas oper logic fondamental not (es not ) op. unar , and (es and b ) op. binar , or (es or b ) op. binar si applic operand poss assum i valor binar ver fals . contraddizion si intend un&#39; espression è sempr fals esemp and (not ) . tautolog si intend un&#39; espression è sempr ver esemp or (not ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2199"><answer_text>l` algebr bool è bas oper logic fondamental ! ? not (es not ) op. unar , &#38; ? and (es and b ) op. binar , || or (es or b ) op. binar si applic operand poss assum i valor binar ver fals . contraddizion si intend un&#39; espression è sempr fals esemp and (not ) . tautolog si intend un&#39; espression è sempr ver esemp or (not ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2139"><answer_text>un&#39; espression boolean contraddizion si ottien quand abbiam un&#39; espression sempr fals , es . and (not ) ; mentr abbiam un&#39; espression boolean tautolog quand abbiam un&#39; espression sempr ver , es or (not ) . </answer_text><num_votes>2</num_votes></answer><answer id="A2198"><answer_text>l` algebr bool è bas oper logic fondamental ! ? not (es not ) op. unar , &#38; ? and (es and b ) op. binar , || or (es or b ) op. binar si applic operand poss assum i valor binar ver fals . contraddizion si intend un&#39; espression è sempr fals esemp and (not ) . tautolog si intend un&#39; espression è sempr ver esemp or (not ) . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2234"><question_text>qual legg de morgan consist ? </question_text><answer id="A2253"><answer_text>legg de morgan prov l&#39; equivalent specif espression boolean . prim legg afferm and b equival not ( ( not ) or (not b ) ) ; mentr second verif not ( ( not ) and (not b ) ) ã¨ ugual or b . </answer_text><num_votes>0</num_votes></answer><answer id="A2216"><answer_text>legg de morgan dimostr utilizz dopp negazion l&#39; oper oppost risult formul non camb . esemp and b = not ( ( not ) or (not b ) ) oppur or b = not ( ( not ) and ( not b ) ) </answer_text><num_votes>0</num_votes></answer><answer id="A2246"><answer_text>legg de morgan prov l&#39; equivalent specif espression boolean . prim legg afferm and b equival not ( ( not ) or (not b ) ) ; mentr second verif not ( ( not ) and (not b ) ) ã¨ ugual or b . </answer_text><num_votes>0</num_votes></answer><answer id="A2079"><answer_text>legg de morgan formul equivalent permett riscriv un&#39; oper &#34; and &#34; com un&#39; oper &#34; or &#34; &#34; not &#34; , vicevers . quest formul utilizz , esemp , si vuol riscriv un&#39; espression boolean utilizz &#34; and &#34; &#34; or &#34; . legg de morgan : and b = not( (not ) or (not b ) ) or b = not( (not ) and (not b ) ) </answer_text><num_votes>2</num_votes></answer><answer id="A2252"><answer_text>e&#39; util trov espression boolean si equivalg , avvien tavol ver &#39; corrispondent espression ugual . particol , de morgan trov seguent espression si equivalg : and b = not ( (not ) or ( not b ) ) ; or b = not ( ( not ) and ( not b ) ) ; quest legg de morgan aiut semplific espression boolean trov men compless form piu&#39; facil legg piu&#39; intuit . </answer_text><num_votes>2</num_votes></answer><answer id="A2263"><answer_text>espression boolean equivalent medesim tavol veritã ?â . legg de morgan seguent : prim ) ã ?â and b = not ( ( not ) or (not b ) ) second ) ã ?â or b = not ( ( not ) and (notb ) ) quest legg particolar util velocizz semplific i calcol . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2245"><question_text>com poss rappresent , all&#39; intern dell&#39; ambient programm c , numer decimal un&#39; ingent quantit cifr dop virgol ? var modal rappresent , qual è più convenient termin risors ? </question_text><answer id="A2228"><answer_text>c i numer decimal si rappresent mediant tip float . rappresent un’ingent quantit cifr dop virgol è ben utilizz rappresent virgol mobil post quell virgol fiss (dov è sprec risors quant si riserv prior numer bit part inter part frazionar sap realment numer sfrutt quest spaz ) . mod si utilizz più efficient bit un’ottimizz risors . </answer_text><num_votes>4</num_votes></answer><answer id="A2176"><answer_text>rappresent i numer virgol possibil usar 3 tip div : float , doubl oppur long doubl . numer molt cifr decimal si usa long doubl , per occup memor . tip float è più convenient termin memor , può conten men </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2307"><question_text>perc esist registr interru (intr ) ? particol , serv funzion processor ? </question_text><answer id="A2143"><answer_text>registr interru è sistem utilizz var hardw segnal azion event cpu . poic processor ricev inform sol attravers singl ingress , qualsias hardw debb richid l&#39; utlizz cpu funzion , invi seganl cpu stess interromp ciò stav elabor analizz richiest dell&#39; hardw . </answer_text><num_votes>0</num_votes></answer><answer id="A2142"><answer_text>registr interru è sistem utilizz var hardw segnal azion event cpu . poic processor ricev inform sol attravers singl ingress , qualsias hardw debb richid l&#39; utlizz cpu funzion , invi seganl cpu stess interromp ciò stav elabor analizz richiest dell&#39; hardw . </answer_text><num_votes>1</num_votes></answer><answer id="A2214"><answer_text>registr interru intr serv indic all&#39; unit elabor verific event estern . </answer_text><num_votes>1</num_votes></answer><answer id="A2141"><answer_text>registr interru è sistem utilizz var hardw segnal attiv processor . poic processor può ricev inform sol attravers ingress , quand hardw (intern estern pc ) richied oper cpu interromp attiv sta svolgent quest&#39; ultim far si elabor rischiest dell&#39; hardw question . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2344"><question_text>different c&#39; è memor ram memor cach ? tratt tip dat different elabor oper different ? </question_text><answer id="A2245"><answer_text>ram è memor central calcol dov risied dat programm qual esso oper mentr cach è memor assoc principal dov veng momentan sistem dat serv più frequent mod tal non dov volt volt recuper ram . un&#39; altra different consist fatt ram access cell contenent parol maggior memor cach contien più dat essa </answer_text><num_votes>3</num_votes></answer><answer id="A2281"><answer_text>different memor riguard quantit istruzion dat riesc immagazzin veloc riesc forn processor . memor cach è grad rend dispon inform poch nanosecond quant è situ vicin chip processor non può conten tutt inform ram . quand processor , nell&#39; acced dat , non trov cach , prelev memor ram . </answer_text><num_votes>0</num_votes></answer><answer id="A2292"><answer_text>memor ram è memor più veloc all&#39; intern computer l&#39; access dat è indipendent posizion occup . suppon memor cach sram quest è tip ugual ram , i dat rimang salv quand cess l&#39; aliment pc . tip dat memorizz memor è . sol memor cach veng memorizz temporan dat qual oper cpu , qual recuper più veloc memor mass . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2201"><question_text>mod l&#39; unit controll rend possibil l&#39; esecu un&#39; istruzion qual registr veng chiam caus durant quest fas esecu ? </question_text><answer id="A2222"><answer_text>uc attravers segnal controll spost conten pc registr indirizzi( ) ; tram segnal vien lett dato.il dat vien spost registr dat (dr ) segu all&#39; arriv segnal mfc (memory function completed ) cu spost dat registr istruzion corrent (cir ) .infin uc decodif l&#39; istruzion segu gener sequenz segnal necessar all&#39; esecu dell&#39; istruzion , utilizz registr com quell operand </answer_text><num_votes>0</num_votes></answer><answer id="A2187"><answer_text>l&#39; unit &#39; controll esegu fas : prel , decodif mand esecu . fas esecu uc gener sequenz segnal controll necessar esegu l’istruzion mediant registr operand . i registr veng chiam caus durant quest fas : b principal . </answer_text><num_votes>0</num_votes></answer><answer id="A2167"><answer_text>l&#39; unit controll (uc ) gest sequenzializz ooper . ruol è prelev decodific istruzion . più precis fas fetc è uc spost istruzion registr indirizz (ar ) success spost i dat ricev memor registr istruzion istruzion corrent (cir ) ruol dell&#39; uc è decodific l&#39; istruzion , ossi tradurl termin alu (unit aritmet logic ) poss comprend esegu </answer_text><num_votes>0</num_votes></answer><answer id="A2303"><answer_text>l&#39; unit &#39; ã ?â controll (uc ) mand segnal controll affinc &#39; conten pc spost registr indirizz , memor legg dat post all&#39; indirizz . dat lett vien res dispon registr dat ,dop l&#39; arriv segnal mfc ,la uc mand segnal controll affinc &#39; conten dr spost registr istruzion corrent ,cir . infin decodif l&#39; istruzion cir gener sequenz segnal controll necessar esegu l&#39; istruzion . registr : contator ,interruzioni,d ,dat ,indirizz . </answer_text><num_votes>2</num_votes></answer><answer id="A2227"><answer_text>uc attravers segnal controll spost conten pc registr indirizzi( ) ; tram segnal vien lett dato.il dat vien spost registr dat (dr ) segu all&#39; arriv segnal mfc (memory function completed ) cu spost dat registr istruzion corrent (cir ) .infin uc decodif l&#39; istruzion segu gener sequenz segnal necessar all&#39; esecu dell&#39; istruzion , utilizz registr com quell operand </answer_text><num_votes>1</num_votes></answer><answer id="A2224"><answer_text>uc attravers segnal controll spost conten pc registr indirizzi( ) ; tram segnal vien lett dato.il dat vien spost registr dat (dr ) segu all&#39; arriv segnal mfc (memory function completed ) cu spost dat registr istruzion corrent (cir ) .infin uc decodif l&#39; istruzion segu gener sequenz segnal necessar all&#39; esecu dell&#39; istruzion , utilizz registr com quell operand </answer_text><num_votes>1</num_votes></answer><answer id="A2225"><answer_text>uc attravers segnal controll spost conten pc registr indirizzi( ) ; tram segnal vien lett dato.il dat vien spost registr dat (dr ) segu all&#39; arriv segnal mfc (memory function completed ) cu spost dat registr istruzion corrent (cir ) .infin uc decodif l&#39; istruzion segu gener sequenz segnal necessar all&#39; esecu dell&#39; istruzion , utilizz registr com quell operand </answer_text><num_votes>0</num_votes></answer><answer id="A2226"><answer_text>uc attravers segnal controll spost conten pc registr indirizzi( ) ; tram segnal vien lett dato.il dat vien spost registr dat (dr ) segu all&#39; arriv segnal mfc (memory function completed ) cu spost dat registr istruzion corrent (cir ) .infin uc decodif l&#39; istruzion segu gener sequenz segnal necessar all&#39; esecu dell&#39; istruzion , utilizz registr com quell operand </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2228"><question_text>e&#39; possibil dedic part memor ram calcol com memor cach ? cosi&#39; fac miglior prestazion pc ? </question_text><answer id="A2247"><answer_text>memor central , ram random access memory , e&#39; utilizz memorizz i dat programm util funzion compil . ram puo&#39; esser tip : static (sram ) dinam (dram ) . sram si adatt esser utilizz com memor cach , quant consent memorizz dat richiest frequent ; dram consent conten maggior quant &#39; dat e&#39; men veloc sram . prestazion pc miglior aument capac &#39; ram . </answer_text><num_votes>2</num_votes></answer><answer id="A2310"><answer_text>e&#39; possibil tipic , miglior prestazion pc , vien install memor piccol veloc tip sram dirett cpu (o vicin ) dov veng salv indirizz part ram vien utilizz piu&#39; frequent cos acceler oper .la cach e&#39; tip memor poter esser utilizz frequent , buon accessibil conten poch dat . </answer_text><num_votes>1</num_votes></answer><answer id="A2087"><answer_text>ram cach fisic divers . cach è realizz sram (ser circu flip-flop ) , divers dram usat ram (un cell è compost condens transistor ) . non è possibil &#34; trasform &#34; ram pc cach . teoric si può realizz macchin oper cach : effett via maggior veloc access miglior prestazion pc . cost sarebb per proibit . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2332"><question_text>com funzion gestion process ? veng esegu sequenzial non parallel com è possibil cpu singl cor poss permett multitasking all&#39; utent ? </question_text><answer id="A2162"><answer_text>più process veng svolt parallel singol cpu , esemp process process b , cpu svolg brevissim lass process (non sta svolg process ) poi svolg process b brevissim lass (ovv cpu non sta svolg process ) , poi torn cos via . mod riesc esegu process parallel singol cpu . </answer_text><num_votes>0</num_votes></answer><answer id="A2068"><answer_text>gestion process è comp più import processor . quand cpu è chiam esegu più process , sicur soluzion miglior sarebb quell esegu contemporan . cas cpu singl cor non è possibil . cpu ricev i process mod sequenzial esegu . siccom processor esegu un&#39; istruzion dell&#39; ordin grandezz milionesim l&#39; utent avrà l&#39; impression mult tasking . </answer_text><num_votes>2</num_votes></answer><answer id="A2160"><answer_text>più process veng svolt parallel singol cpu , esemp process process b , cpu svolg brevissim lass process (non sta svolg process ) poi svolg process b brevissim lass (ovv cpu non sta svolg process ) , poi torn cos via . mod riesc esegu process parallel singol cpu . </answer_text><num_votes>0</num_votes></answer><answer id="A2161"><answer_text>più process veng svolt parallel singol cpu , esemp process process b , cpu svolg brevissim lass process (non sta svolg process ) poi svolg process b brevissim lass (ovv cpu non sta svolg process ) , poi torn cos via . mod riesc esegu process parallel singol cpu . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2200"><question_text>qual i principal oper logic qual è l&#39; ordin priorit essi ? </question_text><answer id="A2127"><answer_text>i principal oper logic not , and , or . quest si ric segu variant neg and , or (nand or ) . combin piu&#39; element si ric oper exor exnor . oper cit ordin prior &#39; , ovver not , poi and infin or . esemp : !ab+c e&#39; mod sintet scriv [ (! ) * b ] +c . </answer_text><num_votes>0</num_votes></answer><answer id="A2069"><answer_text>oper logic bas and , or not . regol precedent dett tal oper , all&#39; intern espression , vann esegu seguent ordin : prim vien esegu not , poi l&#39; and infin l&#39; or . tal precedent poss esser modific piec mediant l&#39; uso parentes . </answer_text><num_votes>2</num_votes></answer><answer id="A2302"><answer_text>i principal oper logic and , or not . l&#39; ordin prioritã ã¨ seguent : 1 . not 2 . and 3 . or </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2347"><question_text>descr element funzional principal costitu macchin von neumann . </question_text><answer id="A2132"><answer_text>element principal macchin von neumann : processore=eseg i programm ; memor centrale=memorizz dat istruzion ; memor massa=memorizz grand quantit dat ; perifer i/o=consent interfacc l&#39; estern ; bus sistema=colleg tutt element . </answer_text><num_votes>0</num_votes></answer><answer id="A2284"><answer_text>macchin von neumann esegu un&#39; istruzion volta,ed è compost : -memor central : accogl dat programm i qual oper calcol , è compost cell ognun qual contien parol access specific l&#39; indirizz ; -cpu : è l&#39; unit calcol si occup elabor i programm ; -memor mass : è più lent mem . central memorizz manier persistent i dat ; -perifer ; -bus : è via comun scamb dat . </answer_text><num_votes>1</num_votes></answer><answer id="A2271"><answer_text>macchin von neumann : 1 ) unit elabor (cpu ) : scand clock interpret esegu istruzion programm (unit controll ,alu ) .present registr (cir,pc ,intr,sr ) . 2 ) memor central : volatil ,contien istruzion dat util all&#39; esecu programma.s suddivid cell ,contenent parol , indirizz (ram ) . 3 ) perifer : permett scamb inform elabor mond estern (memor mass ,tast ,mous ) . 4 ) memor mass : memorizz dat mod persistent . 5 ) bus sistem : colleg element funzional consent scamb dat . </answer_text><num_votes>2</num_votes></answer><answer id="A2131"><answer_text>element principal macchin von neumann : processore=eseg i programm ; memor centrale=memorizz dat istruzion ; memor massa=memorizz grand quantit dat ; perifer i/o=consent interfacc l&#39; estern ; bus sistema=colleg tutt element . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2229"><question_text>perc memor central (ram ) è dett memor access casual ? signif è memor volatil ? </question_text><answer id="A2178"><answer_text>ram è dett memor access casual quant permett l&#39; access dirett qualsias indirizz memor brevissim , infatt è utilizz com memor central . è memor tip volatil poic necess aliment elettr manten propr intern inform , esemp spegn computer tutt inform memorizz all&#39; intern essa veng cancell ; mot vien dett memor temporane . </answer_text><num_votes>0</num_votes></answer><answer id="A2179"><answer_text>ram è dett memor access casual quant permett l&#39; access dirett qualsias indirizz memor brevissim , infatt è utilizz com memor central . è memor tip volatil poic necess aliment elettr manten propr intern inform , esemp spegn computer tutt inform memorizz all&#39; intern essa veng cancell ; mot vien dett memor temporane . </answer_text><num_votes>0</num_votes></answer><answer id="A2180"><answer_text>ram è dett memor access casual quant permett l&#39; access dirett qualsias indirizz memor brevissim , infatt è utilizz com memor central . è memor tip volatil poic necess aliment elettr manten propr intern inform , esemp spegn computer tutt inform memorizz all&#39; intern essa veng cancell ; mot vien dett memor temporane . </answer_text><num_votes>0</num_votes></answer><answer id="A2268"><answer_text>memor ram (random access memory ) e&#39; dett memor access casual perc &#39; nell&#39; istant processor estrarr dat essa , si bas indirizz cell memor acced inform memorizz , non acced dunqu manier sequenzial . e&#39; mot access e&#39; ridott . e&#39; inoltr dett memor volatil perc &#39; l&#39; interru corrent elettr (spegn pc guast ) tutt i dat conten essa veng pers . </answer_text><num_votes>2</num_votes></answer><answer id="A2206"><answer_text>ram è dett memor access casual perc impieg acced indirizz div cio non serv scorr tutt parol present memor perc bast sap l&#39; indirizzo. memor volatil perc quand sistem oper vien riavv i dat essa veng cancell ogni volt . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2223"><question_text>mod numer bit (caratterist processor ) costitu indirizz memor influenz quantit memor è possibil alloc ? e&#39; possibil qualc mod alloc più memor ? </question_text><answer id="A2203"><answer_text>numer bit costitu indirizz memor influenz quantit memor è possibil alloc poic indirizz memor occup bit memor stess conseguent influ , diminu , quantit memor effett cell . tuttav è possibil alloc più memor espand memor . </answer_text><num_votes>0</num_votes></answer><answer id="A2146"><answer_text>memor può esser consider com sequenz fin cell , ognun contenent sequenz bit . spaz fisic memor può esser immagin com ser posizion qual veng assoc bit . valor tipic numer bit poss esser memorizz 8 , 16 , 32 64 . quest variazion numer bit coinvolt non signif aument memor , camb nell&#39; architettur processor </answer_text><num_votes>1</num_votes></answer><answer id="A2156"><answer_text>processor , influenz memor dov e&#39; possibil alloc &#34; word &#34; mod numer bit potenz 2 cell memor var 0 2^bit - 1 . esemp : 2^10 = 1024 cell 0 1023 mod aument memor calcol e&#39; camb fisic cioe&#39; estrarl sostitu second esigent utent . </answer_text><num_votes>0</num_votes></answer><answer id="A2201"><answer_text>numer bit costitu indirizz memor influenz quantit memor è possibil alloc poic indirizz memor occup bit memor stess . conseguent influ , diminu , quantit memor effett cell . tuttav è possibil alloc più memor espand ulterior memor . </answer_text><num_votes>0</num_votes></answer><answer id="A2177"><answer_text>memor e&#39; costitu numerosissim cell , disposit bistabil , capac assum (0 1 ) attravers i qual e&#39; possibil memorizz quant &#39; ã ?â minim inform (1 bit ) . numer bit identif spaz indirizz , avend disposizion k bit e&#39; possibil indirizz 2^ ( k ) bit all&#39; intern processor ; esemp si disposizion 10 byte (10*8 bit ) si potrann indirizz 2^ (10 ) byte memor , 1 kil byte . non e&#39; possibil alloc piu&#39; memor quell dispon . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2210"><question_text>qual component form l&#39; architettur calcol ? mod comunic ? </question_text><answer id="A2257"><answer_text>i principal processor (cpu ) esegu oper , memor central (ram ) qual veng salv temporan i dat esser elabor , memor mass principal (hard disk ) qual salv permanent dat programm . quest comunic perifer (monitor , tastier , mous , stampant , sched ret , memor mass com pendriv ecc . ) attravers bus sistem qual trasfer dat comand </answer_text><num_votes>1</num_votes></answer><answer id="A2081"><answer_text>i component form l&#39; architettur calcol : - cpu (o processor ) -&#62; &#34; esegu &#34; i programm - memor central -&#62; memorizz dat istruzion - memor mass -&#62; memorizz grand quantit dat - perifer (monitor , tast , sched ret ... ) comunic tutt mediant bus sistem . modell hardw è dett &#34; macchin von neumann &#34; </answer_text><num_votes>0</num_votes></answer><answer id="A2078"><answer_text>i component form l&#39; architettur calcol : -la cpu (o processor ) -&#62; &#34; esegu &#34; i programm -la memor central -&#62; memorizz dat istruzion -la memor mass -&#62; memorizz grand quantit dat programm -le perifer (monitor , tast , sched ret . . ) comunic tram bus sistem . modell hardw è dett &#34; macchin von neumann . &#34; </answer_text><num_votes>1</num_votes></answer><answer id="A2089"><answer_text>calcol è compost seguent part : - processor (svolg l&#39; elabor ) - memor central (memorizz dat istruzion ) - perifer (mous , tastier ) - memor mass (memorizz grand quantit dat manier non volatil ) quest comunic attravers bus sistem , consent scamb dat . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2270"><question_text>esist fattor influenz veloc calcol processor ? </question_text><answer id="A2317"><answer_text>si . fattor influenz veloc clock , ovver quantit impuls gener dall&#39; orolog intern , più elev è frequenz impuls clock più istruzion esegu nell&#39; unit (clock , vien misur hz ) . fattor è quantit memor ram dispon all&#39; intern computer . </answer_text><num_votes>0</num_votes></answer><answer id="A2223"><answer_text>un&#39; elev frequenz clock cpu (ad esemp 2 3 ghz ) fa mod tutt oper calcol sian più veloc quand usi programm fann elabor grafic . </answer_text><num_votes>0</num_votes></answer><answer id="A2295"><answer_text>i fattor influenz velocitã processor . consist grandezz word (grupp bit 8-16-32-64 ) processor comun perifer , second consist frequenz , infatt quest rappresent velocitã veng emess word , ovvi capacitã gestion microprocessor aument cresc frequenz gradezz word , conclusion clock (ond quadr ) sincronizz oper cpu </answer_text><num_votes>0</num_votes></answer><answer id="A2296"><answer_text>i fattor influenz velocitã processor . consist grandezz word (grupp bit 8-16-32-64 ) processor comun perifer , second consist frequenz , infatt quest rappresent velocitã veng emess word , ovvi capacitã gestion microprocessor aument cresc frequenz gradezz word , conclusion clock (ond quadr ) sincronizz oper cpu </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2276"><question_text>perc memor ram possied veloc scrittur lettur superior harddisk ? </question_text><answer id="A2108"><answer_text>perc memor ram è memor d&#39; access casual ,ovver non dip posizion (indirizz ) parol codic .quest avvien graz registr indirizzi,il qual denot ogni parol codic indirizz k bit : moment dell&#39; access bast conosc indirizz individu veloc ;e graz registr dat contien già word memorizz .negl hd process esser fatt scrivendo/legg singol bit 0/1 disc fisic . </answer_text><num_votes>3</num_votes></answer><answer id="A2275"><answer_text>l&#39; harddisk risult estrem piã ?â¹ lent memor ram caus oper fisic , attivitã ?â ã ?â lettur , indirizz necessar dell&#39; enorm quantitã ?â ã ?â inform quest support poss contenere. dat present sull&#39; hd , infatt , non veng pers volt avven l&#39; arrest . quest ã ?â¨ different sostanziale,c pes termin velocitã ?â ã ?â ,con ram ã ?â¨ memor volatil chiusur computer perd tutt i dat conten . </answer_text><num_votes>3</num_votes></answer><answer id="A2270"><answer_text>l&#39; harddisk e&#39; compost piu&#39; disc sormont testin scriv legg conten disc stesso,il tutt e&#39; conten involucr metall colleg sched madr mezz cav ogni byte vien scritt posizion registr tabell chiam fil system . tutt cio &#39; rend l&#39; harddisk piu&#39; lent ram , qual e&#39; compost element hardw colleg dirett sched madr dialog piu&#39; veloc stess </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2237"><question_text>perc legg memor volatil superior 4096 mb serv architettur 64 bit ? </question_text><answer id="A2126"><answer_text>legg memor volatil superior 4096 mb serv un&#39; architettur 64 bit , perc più memor sistem 32 bit non support , vist lim memor realment utilizz var second dell&#39; hardw intorn 3,50 gb . signif un&#39; architettur 32 bit massim quantit dat potr indirizz sar circ 4096 mb (4 gb ) , part vien utilizz indirizz necessar funzion dell&#39; hardw perifer . </answer_text><num_votes>1</num_votes></answer><answer id="A2285"><answer_text>architettur gen poss esser 16,32 64 bit . memor volatil ram i dat veng salv &#34; pacchett &#34; 1 byte . abbiam esemp sistem 32 bit , massim quant &#39; dat esso puo&#39; indirizz e&#39; par 2^32 byte . fac rapid calcol otten 2^32 byte corrispond propr 4096 mb . perc &#39; legg memor volatil superior 4096 mb serv un&#39; architettur 64 bit poic &#39; quell 32 bit risult esser insufficient . </answer_text><num_votes>3</num_votes></answer><answer id="A2165"><answer_text>serv un&#39; architettur 64 bit memor volatil superior 4096 mb perc 32 bit si arriv 4096 mb , non si riesc andar . </answer_text><num_votes>1</num_votes></answer><answer id="A2209"><answer_text>un&#39; architettur 32 bit permett numer indirizz memor par 2 32 , ovver 4gb . so può usar massim circ 3gb memor ram perc restant vien utilizz memor qual registr ram gpu . un&#39; architettur 64 bit permett numer indirizz memor par 2 64 , numer assa maggior precedent permett l&#39; utilizz memor volatil superior 4gb . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2203"><question_text>different present l&#39; oper logic &#34; xor &#34; all&#39; oper logic &#34; or &#34; ? </question_text><answer id="A2189"><answer_text>l’oper or c vien scritt com | (pip ) è dett somm logic . quand vien effettu l’or bit , risult varr ver almen bit val ver . l’oper xor (or esclus ) c vien scritt com ^ (elev potenz ) è dett somm modul 2 . quand vien effettu l’xor bit , risult varr ver soltant bit val ver . </answer_text><num_votes>0</num_votes></answer><answer id="A2192"><answer_text>l’oper or c vien scritt com | (pip ) è dett somm logic . quand vien effettu l’or bit , risult varr ver almen bit val ver . l’oper xor (or esclus ) c vien scritt com ^ (elev potenz ) è dett somm modul 2 . quand vien effettu l’xor bit , risult varr ver soltant bit val ver . </answer_text><num_votes>0</num_votes></answer><answer id="A2297"><answer_text>l&#39; oper logic &#34; xor &#34; restitu com output &#34; vero/1 &#34; operand present valor &#34; vero/1 &#34; , ciã ? ? ã ?â² implic cas operand sian entramb &#34; veri/1 &#34; &#34; falsi/0 &#34; dar com output valor &#34; falso/0 &#34; ; &#34; or &#34; restitu output valor &#34; vero/1 &#34; almen operand ã ? ? ã ?â¨ &#34; vero/1 &#34; restitu valor &#34; falso/0 &#34; entramb operand valor &#34; falso/0 &#34; </answer_text><num_votes>1</num_votes></answer><answer id="A2101"><answer_text>l&#39; oper logic or restitu 1 almen element è 1 , mentr restitu 0 cas . l&#39; oper xor , restitu 1 numer operand ugual 1 è dispar , mentr restitu 0 tutt cas . </answer_text><num_votes>0</num_votes></answer><answer id="A2191"><answer_text>l’oper or c vien scritt com | (pip ) è dett somm logic . quand vien effettu l’or bit , risult varr ver almen bit val ver . l’oper xor (or esclus ) c vien scritt com ^ (elev potenz ) è dett somm modul 2 . quand vien effettu l’xor bit , risult varr ver soltant bit val ver . </answer_text><num_votes>0</num_votes></answer><answer id="A2190"><answer_text>l’oper or c vien scritt com | (pip ) è dett somm logic . quand vien effettu l’or bit , risult varr ver almen bit val ver . l’oper xor (or esclus ) c vien scritt com ^ (elev potenz ) è dett somm modul 2 . quand vien effettu l’xor bit , risult varr ver soltant bit val ver . </answer_text><num_votes>1</num_votes></answer><answer id="A2171"><answer_text>l&#39; oper logic &#34; or &#34; restitu 1 almen operand è 1 , mentr restitu 0 tutt operand 0 . l&#39; oper logic &#34; xor &#34; restitu 1 operand ugual 1 dispar , mentr restitu 0 tutt cas . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2283"><question_text>qual cas l&#39; oper logic or restitu 1 un&#39; oper algebr boolean ?e quand restitu 0 ? </question_text><answer id="A2308"><answer_text>quand entramb ingress fals (bit 1 ) l&#39; uscit ã¨ fals ; almen ingress ã¨ ver (bit 0 ) , l&#39; uscit ã¨ ver (bit 0 ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2106"><answer_text>l&#39; oper logic or (il simbol , leggibil compil e&#39; || ) restitu 1 , cioe&#39; ver , almen operand coinvolt nell&#39; espression boolean val 1 , cioe&#39; risult ver ; contrar dar &#39; 0 , cioe&#39; fals , tutt operand valg 0 . </answer_text><num_votes>1</num_votes></answer><answer id="A2294"><answer_text>ipotizz variabil b l&#39; algebr boolean poss assum com valor &#34; 0 &#34; (fals ) &#34; 1 &#34; (tru ) . l&#39; espression or b rstitu &#34; 1 &#34; moment almen oper foss &#34; 1 &#34; , restitu &#34; 0 &#34; entramb assum &#34; 0 &#34; com valor . </answer_text><num_votes>3</num_votes></answer><answer id="A2145"><answer_text>general , l&#39; oper logic or restitu 1 quand almen valor dell&#39; oper è 1 . vicevers restitu 0 quand tutt i valor dell&#39; oper valor 0 . </answer_text><num_votes>1</num_votes></answer><answer id="A2123"><answer_text>l&#39; oper restitu 1 (ver ) quand ingress (o entramb ) consist bit 1 (ver ) ; l&#39; uscit e&#39; 0 (fals ) quand entramb ingress consist bit 0 (fals ) . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2286"><question_text>com mai è necessar dichiar variabil programm ? </question_text><answer id="A2318"><answer_text>memor ram è risors limit vien condivis process dell&#39; inter sistem . quest&#39; ottic , dichiar variabil permett corrett gestion : sarann defin indirizz dispon riserv numer dimension necessar conten variabil tip dichiar . quest are memor alloc sarann riemp esecu programm . più , dichiar tipizz permett compil verific eventual error semant codic . </answer_text><num_votes>1</num_votes></answer><answer id="A2136"><answer_text>compil riserv memor spaz necessar all&#39; inizializz ciascun variabil . bisogn ten present variabil non vien inizializz , spaz memor assegnatol potrebb conten già valor . </answer_text><num_votes>0</num_votes></answer><answer id="A2305"><answer_text>perchã¨ dichiar variabil vien valut defin quantitã memor destin conten i dat variabil si rifer . quantitã memor vien alloc dip tip variabil si dichiar . dichiar si specif tip variabil , mod compil poss verific eventual error semant present all&#39; intern programm sintatt risult corrett (es . moltiplic variabil string variabil inter ) . non vien dichiar variabil compil si accorg dell&#39; anomal error . </answer_text><num_votes>4</num_votes></answer></question><question id="QQ2209"><question_text>dat seguent espression boolean : not y and y and (x or not y ) -ricav risult -riport osserv opportun </question_text><answer id="A2269"><answer_text>x | y | not y | x or not y | not y and y and (x or not y ) 0 0 1 1 0 0 1 0 0 0 1 0 1 1 0 1 1 0 1 0 com si puã² not tabell , l&#39; espression boolean dat non mai uscit valor ver , sempr valor fals . </answer_text><num_votes>1</num_votes></answer><answer id="A2185"><answer_text>moment confront y oppost (not y ) utilizz l&#39; oper logic &#34; and &#34; si cre contraddizion risult sempr fals . avend and second part dell&#39; espression poic risult parzial è sempr 0 , consegu risult final 0 , cio l&#39; espression sar fals ogni circost . </answer_text><num_votes>1</num_votes></answer><answer id="A2289"><answer_text>l&#39; espression restitu 0 qualsias copp (x ,y ) consider . si not termin not y and y restitu anch&#39; esso sempr zer ; dat success oper and , risult final sarã ?â zer ogni copp qualsias l&#39; espression parentes . </answer_text><num_votes>1</num_votes></answer><answer id="A2182"><answer_text>moment confront y oppost (not y ) utilizz l&#39; oper logic &#34; and &#34; si cre contraddizion risult sempr fals . avend and second part dell&#39; espression poic risult parzial è sempr 0 , consegu risult final 0 , cio l&#39; espression sar fals ogni circost . </answer_text><num_votes>0</num_votes></answer><answer id="A2215"><answer_text>risult è 0 . si può osserv not y and y fa sempr 0 i risult dell&#39; espression non sar mai 1 perc l&#39; oper and com risult 1 entramb operand 1 . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2348"><question_text>legg de morgan poss dimostr l&#39; uguagl : and b = not ( ( not ) or (not b ) ) livell computazional espression pes usar piuttost l&#39; altra è bas gust è più facil comput ? </question_text><answer id="A2133"><answer_text>osserv &#34; comput &#34; signif &#34; calcol &#34; , calcol non fa distinzion form poic entramb calcol . different and b not ( ( not ) or (not b ) ) risied veloc esecu calcol part compil . l&#39; espression and b , infatt , è necessar sol oper , mentr not ( ( not ) or (not b ) ) necessar oper . quest different si può afferm and b è più rapid comput . </answer_text><num_votes>3</num_votes></answer><answer id="A2304"><answer_text>prim espression ã¨ piã¹ facil comput perchã© corrispond tavol veritã piã¹ semplic legger different second combin calcol molt piã¹ . </answer_text><num_votes>0</num_votes></answer><answer id="A2075"><answer_text>l&#39; espression and b è più rapid comput quant esegu cicl macchin : veloc comput dip infatt numer oper calcol esegu , 1 sol and b , not ( ( not ) or (not b ) ) </answer_text><num_votes>1</num_votes></answer><answer id="A2129"><answer_text>osserv &#34; comput &#34; signif &#34; calcol &#34; , calcol non fa distinzion form poic entramb calcol . different and b not ( ( not ) or (not b ) ) risied veloc esecu calcol part compil . l&#39; espression and b , infatt , è necessar sol oper , mentr not ( ( not ) or (not b ) ) necessar oper . quest different si può afferm and b è più rapid comput . </answer_text><num_votes>0</num_votes></answer><answer id="A2259"><answer_text>legg de morgan puã ?â² esser facil verific via teoric tram tavol veritã ?â . macchin risolv espression consist problem matemat , vien svolt alcun different . punt vist pratic spess si vorrã ?â predilig espression mot semplicitã ?â (a and b ã ?â¨ piã ?â¹ intuit ) oppur , elettron , bas material si disposizion . </answer_text><num_votes>0</num_votes></answer><answer id="A2250"><answer_text>pes computazional and b è inferior not ( ( not ) or (not b ) ) . realizz prim richied sol port logic , mentr second 4 . port maggior calcol par 3 ritard port (consider ritard port port and or not ) 1 ritard port and b , maggior consum energ caus maggior numer component utilizz . </answer_text><num_votes>0</num_votes></answer><answer id="A2074"><answer_text>l&#39; espression and b e&#39; piu&#39; rapid comput quant esegu cicl macchin : veloc &#39; comput dip infatt numer oper calcol esegu , 1 sol and b , not ( ( not ) or (not b ) ) . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2365"><question_text>com mai vien utilizz maggior standard asci piuttost standard unicod codif caratter ? qual i vantagg svantagg entramb standard ? </question_text><answer id="A2196"><answer_text>asci : vantagg : minor utilizz memor singol caratt (7 8 bit ) svantagg : minor numer caratter codific , esistent var codif asci estes incompat . unicod : vantagg : un&#39; unic codif tutt i caratter lingu utilizz . svantagg : maggior occup memor (16 32 bit ) . mot è codic unicod non è implement softw nell&#39; hardw &#34; vecc dat &#34; (antecedent 1990 ) , non è compat . </answer_text><num_votes>2</num_votes></answer><answer id="A2212"><answer_text>asci unicod div sistem codif caratter . può codific 256 simbol caratter controll fondamental , utilizz 8 bit ; non includ per caratter alfabet (es . cirill ) . , , unisc sè tutt codif regional singol are , riusc cos rappresent caratter appartenent tutt lingu ; tuttav tal necessar 16 21 bit , comport cio maggior utilizz memor . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2299"><question_text>signif espression boolean equivalent ? </question_text><answer id="A2083"><answer_text>equazion boolean 1 2 si dic equivalent quand , qualsias valor assegn variabil tal espression , risult espression 1 coincid . esemp si not i teorem de morgan dov , l&#39; espression </answer_text><num_votes>0</num_votes></answer><answer id="A2120"><answer_text>espression logic si dic equivalent medesim tavol verit , ossi , avend espression contenent variabil b risult oper funzion valor operand è . esemp espression boolean equivalent dat legg de morgan : and b = not ( ( not ) or (not b ) ) or b = not ( ( not ) and (not b ) ) </answer_text><num_votes>2</num_votes></answer><answer id="A2121"><answer_text>espression logic si dic equivalent medesim tavol verit , ossi , avend espression contenent variabil b risult oper funzion valor operand è . esemp espression boolean equivalent dat legg de morgan : and b = not ( ( not ) or (not b ) ) or b = not ( ( not ) and (not b ) ) </answer_text><num_votes>1</num_votes></answer><answer id="A2300"><answer_text>espression boolean si dic equivalent present medesim tavol verit conduc rislt . e&#39; possibil riscontr esemp equivalent legg de morgan : and b equival not ( ( not ) or (notb ) ) or b equival not ( ( not ) and (notb ) ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2110"><answer_text>espression boolean espression logic , risult equivalent assum sempr valor . </answer_text><num_votes>0</num_votes></answer><answer id="A2082"><answer_text>equazion boolean si dic equivalent quand , qualsias valor assegn variabil tal espression , risult espression coincid . esemp si not i teorem de morgan dov , l&#39; espression ! (a + b ) è equivalent all&#39; espression !a &#38; !b . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2250"><question_text>serv com funzion registr interru ? qualc correl gestion interrupt linguagg c ? </question_text><answer id="A2274"><answer_text>registr interru tien memor richiest attenzion part unitã estern richied attenzion real . non foss registr quest richiest ferm l&#39; unitã logic perd quant fatt quel moment . livell softw sistem permett richiam programm chiam chiamant . c&#39; ã¨ fort correl quant livell softw si applic stess procedur dell&#39; hardw real-tim . </answer_text><num_votes>0</num_votes></answer><answer id="A2091"><answer_text>l&#39; intr è registr contenent inform relat all’operat perifer funzion è strett leg interrupts c . i codic conteng inform gest interrupts salv memor , posizion fiss relat indirizz bas tram offset memoria.quest offset è conten propr registr interrupt quand perifer invi interrupt , l’intr si aggiorn bas posizion offset corrispondent . </answer_text><num_votes>1</num_votes></answer><answer id="A2086"><answer_text>contien inform relat funzion perifer . perifer process dev contatt cpu verr invi segnal registro.in segu processor memorizz esecu all&#39; arriv dell&#39; interrupt iniz l&#39; esecu subroutin esegu richiest dell&#39; interrupt , infin processor ripr l&#39; esecu oper stav elaborando.il c è grad sfrutt interrupt second funzion richiest . </answer_text><num_votes>4</num_votes></answer><answer id="A2184"><answer_text>registr interru , insiem segnal , fa&#39; sì l&#39; interfacc grad gener l&#39; interru vien inser realizz dell&#39; interfacc stess . funzion è quell blocc un&#39; oper quand più import esser comp . c&#39; è correl registr gestion interru poic , volt registr permett l&#39; interfacc gener l&#39; interru , processor interromp oper esegu gestion interru . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2215"><question_text>qual i registr cpu qual è funzione/utilizz ? </question_text><answer id="A2288"><answer_text>i registr insiem bit funzion memorizz dat . essi : registr indirizz memor : l&#39; indirizz memor si vuol selezion registr dat memor : dic i dat giã ?â present memor selezion quell introdott contator programm : contien indirizz istruzion sucess registr istruzion corrent : contien istruzion tradurr esegu registr interru : inform funzion perifer . </answer_text><num_votes>2</num_votes></answer><answer id="A2286"><answer_text>esist var registr cpu , qual : pc , ir , sr , ar , mar , mdr , gpr . funzion è quell ospit inform corrett . </answer_text><num_votes>0</num_votes></answer><answer id="A2104"><answer_text>registr dat : usat memorizz dat . registr indirizz : acced memor . registr gener : contien dat indirizz . registr floating-point : memorizz numer virgol mobil . registr costant : conteng dat sol lettur . registr special : conteng dat intern cpu , tip program counter , clock , ecc ... registr istruzion : contien l&#39; istruzion corrent . registr indic : camb l&#39; indirizz operand . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2372"><question_text>si intend termin &#34; macchin virtual &#34; ? </question_text><answer id="A2276"><answer_text>termin macchin virtual indic softw , attravers process virtualizz , cre ambient virtual emul tipic comport macchin fisic graz riserv risors hardw (porzion hd , ram risors process ) alcun applic poss esser esegu com interag tal macchin . cas dovess andar fuor uso sistem oper macchin virtual sistem oper bas non risent . </answer_text><num_votes>2</num_votes></answer><answer id="A2287"><answer_text>macchin virtual intend indic softw cre ambient virtual simul comport macchin fisic . e&#39; res possibil graz fatt veng riserv risors hardw quest macchin virtual (part disc rigid , ram ecc ... ) . vantagg quest &#34; macchin &#34; e&#39; offrir contemporan piu&#39; utent possibil &#39; div ambient oper separ attiv ciascun propr richiest . </answer_text><num_votes>1</num_votes></answer><answer id="A3441"><answer_text>termin macchin virtual indic softw , attravers process virtualizz , cre ambient virtual emul tipic comport macchin fisic graz all&#39; assegn risors hardw (porzion disc rigid , ram risors process ) alcun applic poss esser esegu com interag tal macchin . fatt si offre contemporan efficient più utent , div ambient oper separ , ciascun attiv effett richiest , sporc sistem fisic real partizion . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2328"><question_text>qual different analog , present , calcol 32bit 64bit ? qual vantagg svantagg port un&#39; architettur all&#39; altra ? </question_text><answer id="A2221"><answer_text>i termin 32 64 bit si intend grandezz bit variabil semplic architettur hardw . esemp cpu , i registr architettur 64 bit dimension maggior 32 bit perc dev &#34; ospit &#34; quantit maggior dat cos sistem può gest più dat contemporan . quest è l&#39; unic different i calcol quant essi oper sempr com metod : fas fetc , interpret esecu . </answer_text><num_votes>0</num_votes></answer><answer id="A2183"><answer_text>aggett 32 64 bit intend dimension form standard variabil all&#39; intern un&#39; architettur hardw (un different gestion inform part cpu ) . second dell&#39; architettur var dimension registr intern microprocessor . un&#39; architettur 64bit può gest dat sar più efficient è &#34; convenient &#34; support bus dat indirizz , nonc memor ram , &#34; adegu &#34; all&#39; architettur . </answer_text><num_votes>0</num_votes></answer><answer id="A2309"><answer_text>dat calcol 64 bit memorizz i dat unit &#39; medesim dimension , esso avra &#39; access quantit indirizz potenzial memor ram piu&#39; ampi version 32 bit , picc teoric 2^64 indirizz i 2^32 second -corrispondent limit circ 4gb ram sistem . livell softw , ogni architettur necessiter &#39; propr set drivers rend programm architettur different non sempr retrocompat . </answer_text><num_votes>0</num_votes></answer><answer id="A2100"><answer_text>i 64 bit 32 bit , indic rispett architettur lunghezz registr , spaz indirizz memor ecc . vantagg è capac elabor oper raddopp 2^32 2^64 . svantagg è i dat più ampi poss signific più spaz occup molt sprec . esemp memorizz numer 300 richied bit . memorizz 32 bit , 23 si sprec , 64 bit sprec 55 . </answer_text><num_votes>0</num_votes></answer><answer id="A2290"><answer_text>numer bit è rifer lunghezz variabil processor può gest ; processor istruzion 64bit è grad gest istruzion lunghezz dopp 32b,con 32bit sistem oper può gest 2^32bit memoria,mentr sistem 64 bit memor sal 2^64.il processor gest variabil più lung men oper ricostruzione/decostru inform dà alcun vantagg nell&#39; utilizz memor grand dimension 64 bit sistem è men soggett overflow . </answer_text><num_votes>0</num_votes></answer><answer id="A2158"><answer_text>aggett 32 64 bit intend dimension form standard variabil all&#39; intern un&#39; architettur hardw (un different gestion inform part cpu ) . second dell&#39; architettur var dimension registr intern microprocessor . un&#39; architettur 64bit può gest dat sar più efficient è &#34; convenient &#34; support bus dat indirizz , nonc memor ram , &#34; adegu &#34; all&#39; architettur . </answer_text><num_votes>0</num_votes></answer><answer id="A2103"><answer_text>i termin 32 64 bit si intend grandezz bit variabil semplic architettur hardw . esemp cpu , i registr architettur 64 bit dimension maggior 32 bit perc dev &#34; ospit &#34; quantit maggior dat cos sistem può gest più dat contemporan . quest è l&#39; unic different i calcol quant essi oper sempr com metod : fas fetc , interpret esecu . </answer_text><num_votes>0</num_votes></answer><answer id="A2105"><answer_text>prov scrittur ... </answer_text><num_votes>0</num_votes></answer><answer id="A2175"><answer_text>different sta fondamental dimension bus dat : i processor 32 bit bus word (32 bit ) , mentr quell 64 doubleword (64 bit ) . un&#39; altra different è version 64 bit support astratt 128gb memor ram mentr version 32 bit massim 4gb . sistem 64 bit gen offre prestazion miglior ; svantagg 64 bit è moltissim programm non scritt gir sistem 64 bit . </answer_text><num_votes>1</num_votes></answer><answer id="A2098"><answer_text>entramb i calcol present stess component sistem comun i modul intern cpu . ciò distingu è lunghezz dat memorizz elabor , registr cell memor . i calcol 32bit present dat lung 32 bit mentr quell 64 elabor numer form 64 bit . dat binar form più bit si poss rappresent più combin si poss comp elabor più compless più veloc . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2233"><question_text>qual&#39; è relazion numer bit costitu indirizz memor spaz indirizz disposizion ? </question_text><answer id="A2115"><answer_text>spaz indirizz è defin numer parol indirizz dip esclus numer bit dell’indirizz non numer parol memor effett dispon : n è numer bit costitu l’indirizz memor spaz indirizz è 2^n . dat tutt i byte dev esser indirizz dimension effett memor è sempr minor ugual spaz indirizz . </answer_text><num_votes>0</num_votes></answer><answer id="A2076"><answer_text>numer bit costitu indirizz memor determin numer indirizz , cio spaz indirizz . particol , indirizz memor è n bit , spaz indirizz disposizion è 2^n cell . </answer_text><num_votes>2</num_votes></answer><answer id="A2077"><answer_text>numer bit costitu indirizz dip spaz indirizz disposizion rapport 2^n dov n è numer bit dell&#39; indirizz . </answer_text><num_votes>0</num_votes></answer><answer id="A2117"><answer_text>spaz indirizz è defin numer parol indirizz dip esclus numer bit dell’indirizz non numer parol memor effett dispon : n è numer bit costitu l’indirizz memor spaz indirizz è 2^n . dat tutt i byte dev esser indirizz dimension effett memor è sempr minor ugual spaz indirizz . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2235"><question_text>qual mot all&#39; intern calcol è present memor rom , qual è caratterist principal vien utilizz all&#39; intern computer ? </question_text><answer id="A2307"><answer_text>rom vien utilizz memorizz dat programm serv moment dell&#39; accension dell&#39; elabor , prim caric sistem oper , esemp poss conten bios (basic input-output system ) . rom (read-only-memory ) ã¨ memor sol lettur non programm access rapid , i dat conten essa veng inser fas costruzion non poss esser modific success . </answer_text><num_votes>2</num_votes></answer><answer id="A2283"><answer_text>memor rom utilizz memorizz dat programm serv moment dell&#39; accension computer , prim caric sistem oper . rom effettu un&#39; oper importantissim all&#39; avvi sistem , boot l&#39; aut diagnost , consist verific i fil sistem perifer computer non abbi problem . conten tal memor si puo&#39; legg non modific e&#39; persistent , cioe&#39; non vien pers spegn calcol . </answer_text><num_votes>1</num_votes></answer><answer id="A2102"><answer_text>rom (read-only memory ) è memor caratterist simil quell ram (random access memory ) , differ mot : è memor tip permanent d&#39; access notevol superior quest&#39; ultim . si utilizz memorizz i dat serv moment dell&#39; accession calcol prim caric sistem oper , esemp bios . i dat rom veng gen inser fas costruzion non poss esser modific . </answer_text><num_votes>0</num_votes></answer><answer id="A2088"><answer_text>rom (read only memory ) com esprim è memor si distingu gemell ram fatt è memor permanent , sens different ram , quand vien tolt l&#39; aliment i dat permang essa ; rom risied esemp bios programmi/d serv all&#39; avvi dell&#39; os ; perc è indispens computer . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2254"><question_text>si intent raid (redundant array of inexpens disks ) tip raid esist ? </question_text><answer id="A2094"><answer_text>raid è modal consente,tram controller,d più disc fiss permett aument prestazion lettura/scrittura.il raid consist 7 schem div (raid 0-6 coinvolg numer minim disc impieg : minim 2(raid 0 ) minim 4(raid 6 ) ) assoc divers architettur distribu dati.il raid vist so com unic disc .spess utilizz i server camp finanziar bancar (garant serviz continu ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2210"><answer_text>raid è sistem informat usa grupp disc rigid condivid replic inform , combin disc bass cost rend sistem compless miglior disc singol ultim gener . esist var livell raid bas combin disc , i più utilizz vann livell 0 , numer minim 2 disc , livell 5 , minim 4 . </answer_text><num_votes>0</num_votes></answer><answer id="A2218"><answer_text>raid è sistem informat usa grupp disc rigid condivid replic inform , combin disc bass cost rend sistem compless miglior disc singol ultim gener . esist var livell raid bas combin disc , i più utilizz vann livell 0 , numer minim 2 disc , livell 5 , minim 4 . </answer_text><num_votes>0</num_votes></answer><answer id="A2211"><answer_text>raid è sistem informat usa grupp disc rigid condivid replic inform , combin disc bass cost rend sistem compless miglior disc singol ultim gener . esist var livell raid bas combin disc , i più utilizz vann livell 0 , numer minim 2 disc , livell 5 , minim 4 . </answer_text><num_votes>0</num_votes></answer><answer id="A2194"><answer_text>raid si intend sistem combin un&#39; insiem disc rigid stess unitã . sistem oper riconosc l&#39; insiem disc com unic volum . ciã² consent aument l&#39; integritã dat , toller guast prestazion , all&#39; uso disc singol . 7 tip raid , denomin i numer 0 6 (anc raid 0 non sarebb ver propr raid quant non permett nessun guast disc ....non ã¨ conseguent rindond ) . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2238"><question_text>perc sram consent access più rapid ram inform ? perc capac è minor memor ram ? </question_text><answer id="A2291"><answer_text>sram , acronim static random access memory consent access più rapid inform via com stat costru celle,in mod più compless costos ram normal . sram riesc esser 20-30 più veloc ram normali.l capac è minor sempr via metod costruzion cell memoria,infatt maggior densit fluss dat è utilizz dram,men veloc più capient . </answer_text><num_votes>1</num_votes></answer><answer id="A2153"><answer_text>memor sram , acronim static random access memory , consent access più rapid ram quant dispong capienz non tropp elev (dell&#39; ordin poch mb ) . sram general usat com memor cach dov necessar elev veloc . </answer_text><num_votes>0</num_votes></answer><answer id="A2107"><answer_text>memor sram è memor tip static (i dat conten essa permang temp lung ) contien poch dat . alta veloc access inform der mod è realizz fatt conteng poch dat intern . capac è limit perc ogni cell memor richied numer elev component . infatt elev quantit dat vien utilizz dram vien realizz usand cell memor men compless . </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2355"><question_text>qual propriet oper boolean ? </question_text><answer id="A2314"><answer_text>propriet &#39; oper boolean : 1 ) propriet &#39; commut 2 ) propriet &#39; distribut vers l&#39; . esemp propriet &#39; commut : or b = b or . esemp propriet &#39; distribut vers l&#39; : or (b and c ) = (a or b ) and (a or c ) </answer_text><num_votes>2</num_votes></answer><answer id="A2299"><answer_text>propriet oper boolean commut ( and b = b and ) , distribut . esemp quest&#39; ultim è : and (b or c ) = (a and b ) or (a and c ) </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2335"><question_text>serv fas interpret funzion processor ? </question_text><answer id="A2163"><answer_text>funzion processor fas interpret decodif dell&#39; istruzion e&#39; svolt dall&#39; unit &#39; â controll (control unit ) consist trasform linguagg programm linguagg macchin . </answer_text><num_votes>1</num_votes></answer><answer id="A2251"><answer_text>l&#39; unit controll analizz conten registr istruzion corrent decodif istruzion present &#39;&#39; linguagg astratt &#39; &#39; &#39;&#39; linguagg macchin &#39; &#39; rend possibil l&#39; esecu istruzion . esemp vien individu tip oper i operand : registr general oppur cell memor . cas , sar necessar almen access memor reper l&#39; oper . </answer_text><num_votes>1</num_votes></answer><answer id="A2092"><answer_text>processor fas interpret decodif , graz all&#39; unitã â controll (uc ) , registr dell&#39; istruzion corrent (cir , ) qual sarã salv l&#39; istruziuon compil dovr esegu segu , dop aver ricev i operand salv registr b . </answer_text><num_votes>2</num_votes></answer></question><question id="QQ2227"><question_text>com vien implement l&#39; algebr bool livell hardw ? </question_text><answer id="A2073"><answer_text>l&#39; algebr bool è un&#39; algebr astratt oper i sol valor logic 0 (fals ) 1 (ver ) . livell hardw calcol qualsias elabor elettron è struttural bas element bistabil , può oper sol sequenz simbol binar (bit ) . cas l&#39; algebr bool può esser implement rappresent circu logic dov 0 1 corrispond condizion bit può assum . </answer_text><num_votes>0</num_votes></answer><answer id="A2071"><answer_text>l&#39; algebr bool è un&#39; algebr astratt oper i sol valor logic 0 (fals ) 1 (ver ) . livell hardw calcol qualsias elabor elettron è struttural bas element bistabil , può oper sol sequenz simbol binar (bit ) . cas l&#39; algebr bool può esser implement rappresent circu logic dov 0 1 corrispond condizion bit può assum . </answer_text><num_votes>0</num_votes></answer><answer id="A2072"><answer_text>l&#39; algebr bool è un&#39; algebr astratt oper i sol valor logic 0 (fals ) 1 (ver ) . livell hardw calcol qualsias elabor elettron è struttural bas element bistabil , può oper sol sequenz simbol binar (bit ) . cas l&#39; algebr bool può esser implement rappresent circu logic dov 0 1 corrispond condizion bit può assum . </answer_text><num_votes>0</num_votes></answer><answer id="A2085"><answer_text>inform rappresent elabor disposit elettron , dett ret logic qual possied port logic costitu element bas tutt i disposit digitali.l port logic si bas funzion transistor com interruttor binar veloc quest implement oper dell&#39; algebr bool , algebr valor (0 ,1 ) .un funzion boolean può esser descritt mediant tavol verit . </answer_text><num_votes>2</num_votes></answer><answer id="A2097"><answer_text>l&#39; algebr bool esegu oper matemat bas numer binar . , implement quest&#39; algebr livell hardw , vien fatt uso piccol component elettron , i transistor , combin dann luog port logic . propr quest port esegu oper matemat , principal : - and : moltipl - or : somm - not : negazion </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2253"><question_text>spieg funzion scrittura/lettur dat (parol memor ,word ) memor central specific funzion registr indirizzi( ) registr dat (dr ) ( modal store/load ) . inoltr dir qual può esser l&#39; indirizz minim massim word quand registr indirizz è 16 bit . </question_text><answer id="A2197"><answer_text>i regisr dr ar comand uc esegu istruzion . ar veng scritt indirizz cell memor oper . volt raggiunt quest cell , si caric dat dr si esegu oper necessar . dr c&#39; è dat lett scriv cell indirizz ar . word 16 bit può conen dat 0 65535 , convert binar . </answer_text><num_votes>1</num_votes></answer><answer id="A2172"><answer_text>azion scrittur lettur dat memor central veng gest cpu sfrutt bus indirizz bus controll cpu caric l&#39; indirizz registr indirizz mett bus indirizz mod perifer corrett si attiv tram segnal controll trasmess bus dedic fa comp quest l&#39; azion desider (store/load memor ) indirizz 16 bit quest poss esser tutt possibilitã ?â 16 uni 16 zer (2 16 ) </answer_text><num_votes>0</num_votes></answer><answer id="A2306"><answer_text>l&#39; acquisizion un&#39; inform e&#39; res possibil funzion registr indirizz (ar ) registr dat (dr ) .il permett all&#39; elabor selezion particol cell memor avval &#34; indirizz &#34; (posizion ) , rend possibil oper lettur scrittur . durant &#34; lettur &#34; conten cell memor e&#39; cop dr (load ) , durant scrittur e&#39; conten dr esser cop cell (stor ) . registr indirizz e&#39; 16bit , , veng indirizz 2^16 cell i indirizz vann 0 2^16-1 . </answer_text><num_votes>2</num_votes></answer><answer id="A2186"><answer_text>l&#39; oper lettur effettu cop dat conten cell memor all&#39; intern registr dat . tal cell e&#39; indirizz attravers registr indirizz . l&#39; oper scrittur provoc cop conten registr dat all&#39; intern cell memor , qual e&#39; indirizz registr indirizz . cas registr indirizz 16 bit , e&#39; possibil indirizz 65536 word . l&#39; indirizz minim word risulter &#39; 0 mentr massim 65535 . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2320"><question_text>ll cpu intern contien &#34; clock &#34; scand tram impuls . calcol veloc clock elev è sempr più perform veloc clock più bass ? motiv rispost . </question_text><answer id="A2084"><answer_text>clock è circu gener impuls forn processor scansion temporal l&#39; esecu singol oper logic . rispost domand è . infatt , bisogn consider cpu è , insiem frequenz clock , numer istruzion clock . inoltr , esemp , l&#39; architettur mult cor adott orma tutt cpu calcol modern consent aument potenz calcol aument frequenz clock . </answer_text><num_votes>1</num_votes></answer><answer id="A2278"><answer_text>velocitã clock , frequenz , ã¨ numer commutiz riesc comp tr i livell logic &#34; 0 &#34; &#34; 1 &#34; . piã¹ frequenz ã¨ elev piã¹ commut riesc comp , tuttav frequenz dev&#39; esser calcol mod tal ogni circu riesc complet propr oper . frequenz ã¨ tropp elev i circu non riesc complet i calcol cpu non ã¨ piã¹ perform . </answer_text><num_votes>0</num_votes></answer><answer id="A2213"><answer_text>si , è poic clock frequenz maggior riesc esegu stess istruzion period minor (rispett clock frequenz minor ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2279"><answer_text>velocitã clock , frequenz , ã¨ numer commutiz riesc comp tr i livell logic &#34; 0 &#34; &#34; 1 &#34; . piã¹ frequenz ã¨ elev piã¹ commut riesc comp , tuttav frequenz dev&#39; esser calcol mod tal ogni circu riesc complet propr oper . frequenz ã¨ tropp elev i circu non riesc complet i calcol cpu non ã¨ piã¹ perform . </answer_text><num_votes>0</num_votes></answer><answer id="A2280"><answer_text>velocitã clock , frequenz , ã¨ numer commutiz riesc comp tr i livell logic &#34; 0 &#34; &#34; 1 &#34; . piã¹ frequenz ã¨ elev piã¹ commut riesc comp , tuttav frequenz dev&#39; esser calcol mod tal ogni circu riesc complet propr oper . frequenz ã¨ tropp elev i circu non riesc complet i calcol cpu non ã¨ piã¹ perform . </answer_text><num_votes>0</num_votes></answer><answer id="A2277"><answer_text>veloc clock , frequenz , è numer commutiz riesc comp i livell logic &#34; 0 &#34; &#34; 1 &#34; . più frequenz è elev più commut riesc comp , tuttav frequenz dev&#39; esser calcol mod tal ogni circu riesc complet propr oper . frequenz è tropp elev i circu non riesc complet i calcol cpu non è più perform . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2358"><question_text>si intend modal master/slav nell&#39; ambit funzion bus sistem ? </question_text><answer id="A2164"><answer_text>bus sistem è canal permett colleg tutt i component all&#39; intern sched madr calcol perifer estern essa , è gest gerarc master/slav , master è component detien controll bus quand vien esegu richiest , slav è rappresent tutt component implic cors richiest esegu l&#39; istruzion , non deteng controll bus . </answer_text><num_votes>2</num_votes></answer><answer id="A2111"><answer_text>modal master/slav nell&#39; ambit funzion bus sistem , si intend facolt cpu controll mod unidirezional inform viagg bus sistem . </answer_text><num_votes>0</num_votes></answer><answer id="A2256"><answer_text>modalitã master/slav consist grupp disposit process qual (master ) possied assum comp controll gest disposit (slaves ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2169"><answer_text>modal master/slav nell&#39; ambit funzion bus sistem si intend facolt cpu controll mod unidirezional inform viagg bus sistem (dat , indirizz segnal controll ) . </answer_text><num_votes>0</num_votes></answer><answer id="A2219"><answer_text>modal master/slav si indic particol sistem connession disposit interfacc comun bus sistem . fattispec disposit verr indic com master avrà priorit esecut disposit indic com slav funzion quest&#39; dipend disposit master . </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2259"><question_text>descriv fas processor (cpu ) svolg esegu un&#39; istruzion . </question_text><answer id="A2207"><answer_text>fas esecu cpu principal : fas fetc , fas interpret quell esecu . prim fas l&#39; unit controll trasfer l&#39; istruzion registr istruzion (cir ) . second uc decodif l&#39; istruzion cir nell&#39; ultim fas uc gener i segnal controll esegu l&#39; istruzion . </answer_text><num_votes>0</num_votes></answer><answer id="A2208"><answer_text>fas esecu cpu principal : fas fetc , fas interpret quell esecu . prim fas l’unit controll trasfer l’istruzion registr istruzion (cir ) . second uc decodif l’istruzion cir nell’ultim fas uc gener i segnal controll esegu l’istruzion . </answer_text><num_votes>0</num_votes></answer><answer id="A2096"><answer_text>processor esegu un&#39; istruzion quest fas - caric prim istruzion contator program counter - fetc : l&#39; unitã controll uc spost l&#39; istruzion registr indirizz ar , prelev dat registr dat dr . poi l&#39; uc spost dat registr d&#39; istruzion corrent cir . - interpret : l&#39; uc decodif l&#39; istruzion registr cir - esecu : l&#39; uc esegu l&#39; istruzion mediant i registr l&#39; alu . - increment pc prossim istruzion </answer_text><num_votes>3</num_votes></answer></question><question id="QQ2224"><question_text>accad all&#39; intern un&#39; espression matemat compil si trov lavor variabil tip divers ? </question_text><answer id="A2220"><answer_text>esegu un&#39; espression matemat variabil divers compil restitu &#34; warning &#34; ( un&#39; avvert compil , per non pregiud compil ver propr ) oppur error ver propr . effettu oper variabil tip divers dovr ricorr &#34; conversion cast &#34; , semplic specific parentes tip oper vogl effettu (esemp : int a=1 float b=2.7 c=(float ) a+b=3.7 ) . </answer_text><num_votes>1</num_votes></answer><answer id="A2149"><answer_text>risult quell&#39; oper non &#39; desider . esemp lavor inter volessim risult tip float,dobb usar l&#39; oper dett &#34; casting &#34; ossi mett prim dell&#39; espression tip dat desider parentes . ( (float ) a/b . . dov b inter ) . casting risult variabil float &#39; compost sol part inter part decimal . </answer_text><num_votes>1</num_votes></answer><answer id="A2130"><answer_text>casting automat assegn all&#39; espression valor tip risult esser domin (gerarc tip dat ) . casting non è automat , è impost programm , valor dell&#39; espression verr valut bas esso (ad esemp nell&#39; espression x=(float ) 2/3 ; valor dell&#39; espression verr calcol nell&#39; ambit numer razional i operand inter ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ2306"><question_text>qual&#39; è different inter long , short int? </question_text><answer id="A2170"><answer_text>long short qualif tip inter condizion spaz alloc compil variabil ; quand vien esegu programm val seguent regol : spaz alloc (short int) &#60; =spazio(int ) &#60; =spazio(long int ) . tipic i long utilizz 32 bit , i short 16 int 16-32 bit . </answer_text><num_votes>0</num_votes></answer><answer id="A2313"><answer_text>dichiar variabil tip int defin lâ ? ? insiem valor quest puã² assumere. calcol preved i tip dat abbi dimension memor fortement dipendent dall&#39; hardw ,esist poi qualif permett aument diminu .short utilizz valor compres -32767 32767 ( 2^15 ) mentr long -2147483647 2147483647 ( 2^31 ) .int assum valor max min bas calcol (16bit-&#62;2^15 32bit-&#62;2^31 ) . short&#60;=int&#60;=long </answer_text><num_votes>0</num_votes></answer><answer id="A2204"><answer_text>dichiar variabil tip int defin l’insiem valor quest può assumere. calcol preved i tip dat abbi dimension memor fortement dipendent dall&#39; hardw ,esist poi qualif permett aument diminu .short utilizz valor compres -32767 32767 ( 2^15 ) mentr long -2147483647 2147483647 ( 2^31 ) .int assum valor max min bas calcol (16bit-&#62;2^15 32bit-&#62;2^31 ) . short&#60;=int&#60;=long </answer_text><num_votes>0</num_votes></answer><answer id="A2298"><answer_text>long short qualif tip inter condizion spaz alloc compil variabil ; quand vien esegu programm val seguent regol : spaz alloc (short int) &#60; =spazio(int ) &#60; =spazio(long int ) . tipic i long utilizz 32 bit , i short 16 int 16-32 bit . </answer_text><num_votes>0</num_votes></answer><answer id="A2124"><answer_text>long short qualific tip variabil int. condizion spaz alloc compil variabil determin valor massim minim . elabor 32 bit compil alloc 16 bit variabil short int , ( -32.768 ; 32.767 ) 32 bit variabil int long int (-2.147.483.648 ; +2.147.483.647 ) . qualor support macchin , long int alloc 64bit estension maggior int. dev&#39; esser &#39;short int&#39; &#60;= &#39;int&#39; &#60;= &#39; long int&#39; </answer_text><num_votes>1</num_votes></answer><answer id="A2134"><answer_text>dichiar variabil tip int defin l&#39; insiem valor quest può assum . i calcol preved i tip dat abbi dimension memor fortement dipendent dall&#39; hardw ,esist poi qualif permett aument diminu .short utilizz valor compres -32767 32767 ( 2^15 ) mentr long -2147483647 2147483647 ( 2^31 ) .int assum valor max min bas calcol (16bit-&#62;2^15 32bit-&#62;2^31 ) .short&#60;=int&#60;=long </answer_text><num_votes>0</num_votes></answer></question><question id="QQ2278"><question_text>com avvien lettur dat ram tram cpu com scrittur sempr tram cpu ? </question_text><answer id="A2116"><answer_text>-cpu scriv indirizz locazion conten interess registr indirizz -att segnal controll read giung ram -ram ricerc locazion (indirizz indic registr indirizz ) cop conten registr dat access cpu -cpu scriv indirizz locazion interess registr indirizz -inser dat scriv registr dat -att segnal controll writ giung ram -ram prend dat conten registr dat memorizz locazion (indirizz indic registr indirizz ) </answer_text><num_votes>0</num_votes></answer><answer id="A2315"><answer_text>cpu legg i dat present ram , attravers bus sistem , manier casual (random access memory ) , veloc regol defin . scriv , inoltr , i dat ram , attravers bus sistem , alloc indirizz defin . </answer_text><num_votes>0</num_votes></answer><answer id="A2174"><answer_text>l&#39; unit controll (cu ) caric registr indirizz (ar ) l&#39; indirizz si trov dat legg (o scriv ) ram . attravers bus sistem cu mand un&#39; istruzion lettur (o scrittur ) ram ; un&#39; istruzion trasfer dat dat conten quell&#39; indirizz vien trasfer registr dat (dr ) vicevers dat dr vien scritt posizion ram corrispondent quell&#39; indirizz . </answer_text><num_votes>2</num_votes></answer></question></lecture><lecture id="IKEA_EN_001" title="IKEA FAQ" date="2014-03-20"><question id="QQ4192"><question_text>shop ikea ? </question_text><answer id="AA4283"><answer_text>trip ikea pleasant . , tip shop easi ikea store ! ikea store free park ( subject minimum spend southampton coventri ) provid easi access disabl . shop avail entranc : pencil , paper , tape measur , store guid , catalogu , shop stroller shop bag . shop local ikea store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4193"><question_text>check stock avail ? </question_text><answer id="AA4284"><answer_text>effort maintain avail item shown catalogu , due popular suppli issu , product avail , check avail stock local store . item stock option leav mobil email address notifi stock arriv . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4194"><question_text>onlin tool assist plan ? </question_text><answer id="AA4285"><answer_text>yes , onlin plan tool avail help furnish home , . onlin plan tool </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4195"><question_text>buy item onlin ? </question_text><answer id="AA4286"><answer_text>rang avail buy onlin deliveri distribut centr home address , inform . unfortun current n&#39;t offer onlin home-shop northern ireland republ ireland store belfast &#38; dublin look forward welcom . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4196"><question_text>addit servic offer help shop ? </question_text><answer id="AA4287"><answer_text>offer servic home deliveri financ . inform . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4197"><question_text>offer guarante product ? </question_text><answer id="AA4288"><answer_text>offer rang guarante product rang . inform ikea everyday qualiti guarante . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4198"><question_text>purchas item phone , deliveri collect store ? </question_text><answer id="AA4289"><answer_text>unfortun payment phone , reserv item collect . purchas onlin direct distribut centr home . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4199"><question_text>reserv item collect ? </question_text><answer id="AA4290"><answer_text>reserv item store ; abl check stock avail visit store use onlin stock checker . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4200"><question_text>store time direct ? </question_text><answer id="AA4291"><answer_text>store own websit includ time , direct store inform . click choos favourit store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4201"><question_text>park ? </question_text><answer id="AA4292"><answer_text>ikea store free park ( subject minimum spend southampton coventri ) . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4202"><question_text>facil peopl disabl ? </question_text><answer id="AA4293"><answer_text>visitor disabl , pleas offer follow servic ikea store : • wheelchair , free store . • assist shop , pleas custom inform desk store request . • facil hear impair visitor </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4203"><question_text>store famili friend ? </question_text><answer id="AA4294"><answer_text>store suppli chair , organ babi food , babi food warm station , healthi meal children restaur , play nurs . store crèche facil usabl 45 minut time ( book store ) . bring famili . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4204"><question_text>item sometim stock ? </question_text><answer id="AA4295"><answer_text>effort maintain avail item shown catalogu , due popular suppli issu , product avail . , ikea estim product stock . onlin stock checker item avail visit . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4205"><question_text>store offer home deliveri van hire ? </question_text><answer id="AA4296"><answer_text>ikea furnitur flat-pack , home car enjoy . &#39;d prefer , ikea arrang home deliveri reason rate , visit home deliveri desk custom servic checkout . offer van hire servic europcar . ikea rang servic offer . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4206"><question_text>help assembl ? </question_text><answer id="AA4297"><answer_text>yes , assembl guid product descript onlin , store call help furnitur assembl inform servic page . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4207"><question_text>help plan design ? </question_text><answer id="AA4298"><answer_text>ikea store offer home decor servic wish furnish entir home . friend co-work happi assist store . ikea onlin plan tool rang product includ storag , kitchen , wardrob offic furnitur . kitchen depart arrang visit home help design ideal kitchen , ,a href= &#34;http ://www.ikea.com/ms/en_gb/customer_service/ikea_services/kitchen_plann .html &#34; &#62;see inform regard kitchen servic . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4208"><question_text>ve lost store - ? </question_text><answer id="AA4299"><answer_text>lost item , pleas return store visit co-work happi help custom servic desk . pleas note credit card destroy 24 hour secur purpos . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4209"><question_text>mistak receipt store . ? </question_text><answer id="AA4300"><answer_text>pleas return store receipt investig . unabl return store pleas contact . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4210"><question_text>worldwid store locat </question_text><answer id="AA4301"><answer_text>detail ikea store outsid uk found . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4211"><question_text>buy onlin ? </question_text><answer id="AA4302"><answer_text>shop onlin pleas click . pleas note shop onlin avail mainland england , scotland wale . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4212"><question_text>product websit buy onlin ? </question_text><answer id="AA4303"><answer_text>major ikea furnitur rang avail shop onlin increas select home accessori rang . plan increas rang avail futur . tri item onlin wish visit store item , enabl product detail hand visit . item avail purchas onlin option “add basket ” . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4213"><question_text>price onlin store ? </question_text><answer id="AA4304"><answer_text>shop onlin product price normal store price . , occasion promot mean price . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4214"><question_text>chang mind onlin onlin ? </question_text><answer id="AA4305"><answer_text>it’ fine chang mind ; abl cancel , contact . ’ve deliveri ’ve chang mind , simpli store request collect . detail found shop onlin return polici . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4215"><question_text>person detail third parti ? </question_text><answer id="AA4306"><answer_text>sometim hire compani help provid servic . limit inform , ensur fulfil . strict monitor ikea custom privaci protect . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4216"><question_text>cancel place onlin ? </question_text><answer id="AA4307"><answer_text>ikea compli distanc sell regul , cancel time deliveri contact detail , receiv understand time consid purchas , cancel 14 day receiv item , item nearest store receipt email contact collect . appli item specif . inform . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4217"><question_text>add chang exist ? </question_text><answer id="AA4308"><answer_text>chang exist , pleas call soon . confirm chang delay deliveri date . add place store , return store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4218"><question_text>onlin pick store ? </question_text><answer id="AA4309"><answer_text>onlin product deliv direct distribut centr home , collect onlin purchas store , offer product reserv servic store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4219"><question_text>add assembl ? </question_text><answer id="AA4310"><answer_text>add assembl onlin , visit nearest store arrang assembl call inform . addit detail found servic page . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4220"><question_text>payment method accept ? </question_text><answer id="AA4311"><answer_text>store pay major credit debit card includ : visa , visa electron , mastercard , maestro , delta , ikea home card , ikea gift card cash . accept chequ american express.to view payment method accept onlin , pleas click . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4221"><question_text>safe person detail credit card inform ? </question_text><answer id="AA4312"><answer_text>secur custom ’ detail prioriti . integr secur checkout process . payment detail secur time . view privaci polici . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4222"><question_text>ikea home card </question_text><answer id="AA4313"><answer_text>ikea home card payment card previous offer ikea. exist holder card store . card issu contact ikano financi servic . question card , pleas contact ikano custom servic 0871 781 3045 via email customerservice@ikano.net . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4223"><question_text>offer financ option free credit ? </question_text><answer id="AA4314"><answer_text>read ikea financ option . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4224"><question_text>am entitl claim vat refund obtain ? </question_text><answer id="AA4315"><answer_text>purchas ikea store entitl claim vat refund : • eu resid • custom regist vat eu countri , uk. eu resid : export purchas outsid eu entitl vat refund . ship freight pleas request ikea ‘vat refund export outsid eu’ notic .if take board luggag , request ‘ tax freeworldwide’ receipt.custom regist vat eu uk: dispatch purchas eu countri regist vat , pleas request ikea ‘vat refund oversea busi elsewher eu’ , irish custom , ‘vat refund busi republ ireland’ . pleas note refund person origin purchas uk resid . notic request evid qualifi refund . ikea receiv evid 3 month date purchas . purchas onlin via ikea websit ship direct abroad , abl claim vat (vat claim deliveri charg ) . confirm email vat receipt . inform visit www .hmrc.gov.uk </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4225"><question_text>return item ? </question_text><answer id="AA4316"><answer_text>re free chang mind . return unus item origin packag 90 day , till receipt copi onlin form , refund . return polici . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4226"><question_text>return mattress ? </question_text><answer id="AA4317"><answer_text>unless faulti return mattress refund 90 day packag mattress unopen . understand tri mattress ’s comfort ’s exchang mattress 90 day love exchang offer . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4227"><question_text>return product ? </question_text><answer id="AA4318"><answer_text>product cancel time specif . major product select kitchen worktop rang . confirm product specif term condit . product return faulti fit purpos describ . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4228"><question_text>return assembl ? </question_text><answer id="AA4319"><answer_text>item return store origin receipt , disassembl . depend condit item valu method refund discret store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4229"><question_text>account credit refund ? </question_text><answer id="AA4320"><answer_text>sorri . refund origin card payment . event unabl access account refund gift card . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4230"><question_text>provid extra replac fit ? </question_text><answer id="AA4321"><answer_text>fit 6 digit code assembl guid , arrang post direct free charg . click fill request form . assembl guid , copi found product descript websit , product click </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4231"><question_text>i’m miss product i’v purchas . </question_text><answer id="AA4322"><answer_text>pleas receipt copi assembl guid piec miss store replac , 6 digit code assembl guid arrang post direct free charg . click fill request form . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4232"><question_text>product i’v purchas faulti damag . </question_text><answer id="AA4323"><answer_text>faulti store receipt exchang . altern return product replac refund . damag item yourself swipe famili card till , cover famili card insur . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4233"><question_text>help assembl ? </question_text><answer id="AA4324"><answer_text>product detail instruct , help instruct video popular product , store arrang assembl compani , click inform . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4234"><question_text>miss assembl guid </question_text><answer id="AA4325"><answer_text>copi found product descript websit . unabl locat assembl guid , pleas contact articl email pictur item locat . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4235"><question_text>faulti item , guarante </question_text><answer id="AA4326"><answer_text>ikea offer generous guarante polici . guarante found catalogu click . notic product purchas guarante period , pleas return item store email pictur descript fault . pleas includ proof origin purchas ikea. </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4236"><question_text>inform product recal ? </question_text><answer id="AA4327"><answer_text>inform product recal safeti alert pleas visit press page . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4237"><question_text>deliv ? </question_text><answer id="AA4328"><answer_text>yes deliv , visit store abl home deliveri servic arrang day deliveri , purchas onlin onlin deliveri servic item deliv direct home . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4238"><question_text>faster deliveri ? </question_text><answer id="AA4329"><answer_text>onlin , estim deliveri date earliest date deliv item distribut centr . visit store , home deliveri servic abl offer day deliveri . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4239"><question_text>intern ship ? </question_text><answer id="AA4330"><answer_text>onlin shop servic abl deliv item mainland uk ; deliv ship agent specifi deliveri address . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4240"><question_text>choos deliveri time ? </question_text><answer id="AA4331"><answer_text>arrang home deliveri store , contact hour due arriv , deliv 7am 8pm . onlin sent distribut centr deliveri inform . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4241"><question_text>abl onlin pick store ? </question_text><answer id="AA4332"><answer_text>onlin abl deliv direct distribut centr home . reserv store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4242"><question_text>deliveri name address ? </question_text><answer id="AA4333"><answer_text>yes , deliveri address mainland uk. </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4243"><question_text>track deliveri ? </question_text><answer id="AA4334"><answer_text>purchas onlin abl track , post code email address place . deliveri book store agre deliveri day , call hour due deliv . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4244"><question_text>chang deliveri date ? </question_text><answer id="AA4335"><answer_text>origin estim date receiv earliest date . deliv slight date , day ’s conveni . pleas contact soon requir date . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4245"><question_text>tell deliveri restrict ? </question_text><answer id="AA4336"><answer_text>difficulti access properti , pleas click inform . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4246"><question_text>day deliveri ? </question_text><answer id="AA4337"><answer_text>visit store major deliveri 48 hour , normal day subject avail , distanc live store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4247"><question_text>deliveri cost ? </question_text><answer id="AA4338"><answer_text>shop onlin , cost deliveri place item basket , ad postcod press calcul . home deliveri servic store , pleas choos store wish visit link page . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4248"><question_text>miss deliveri ? </question_text><answer id="AA4339"><answer_text>contact deliveri compani soon , contact detail deliveri paperwork , altern contact . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4249"><question_text>ikea famili ? </question_text><answer id="AA4340"><answer_text>ikea famili ikea loyalti programm . ikea famili , ’s free join . ikea famili card discount select home furnish product , food product servic . hold event in-stor free home furnish workshops/seminar preview rang . . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4250"><question_text>ikea famili ? </question_text><answer id="AA4341"><answer_text>free sign start use benefit day . sign , store , via paper applic , ikea famili kiosk onlin . temporari card registr ; plastic card sent home 2-4 week registr , temporari card entitl benefit plastic card arriv . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4251"><question_text>shop ikea card arriv ? </question_text><answer id="AA4342"><answer_text>print temporari card , onlin store famili kioskyou card , plastic temporari , time purchas qualifi ikea famili offer store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4252"><question_text>add exist purchas famili card ? </question_text><answer id="AA4343"><answer_text>qualifi offer swipe card time purchas , add exist purchas date . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4253"><question_text>lost card ? </question_text><answer id="AA4344"><answer_text>request card ; store , onlin via famili account contact . print temporari card onlin account store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4254"><question_text>chang famili card detail , cancel account ? </question_text><answer id="AA4345"><answer_text>updat detail name , address , contact detail , market prefer home onlin via famili account . cancel , simpli log choos option cancel bottom famili account page . altern contact . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4255"><question_text>log onlin account ? </question_text><answer id="AA4346"><answer_text>log . email address regist access onlin ikea famili account . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4256"><question_text>i’v forgotten email password : </question_text><answer id="AA4347"><answer_text>retriev email address attach account lost password select “password help ” log page . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4257"><question_text>sign workshop , seminar event ? </question_text><answer id="AA4348"><answer_text>event list store . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4258"><question_text>tell free product insur ? </question_text><answer id="AA4349"><answer_text>ikea famili benefit free product insur , accident damag home whilst assembl . insur valid purchas item ikea famili price . ikea famili card swipe time purchas insur product . claim insur pleas store 90 day date purchas item , famili card receipt.insur claim store , contact custom servic phone , email onlin . term condit . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4259"><question_text>famili term condit ? </question_text><answer id="AA4350"><answer_text>term condit found . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4260"><question_text>data ? </question_text><answer id="AA4351"><answer_text>ikea ltd safeguard inform provid . inform found . info found . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4261"><question_text>credit connect ikea famili card ? </question_text><answer id="AA4352"><answer_text>credit connect card . ikea current offer credit card . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4262"><question_text>ikea famili card ikea home card ? </question_text><answer id="AA4353"><answer_text>no, ikea home card credit card previous offer ikea custom . credit card issu , valid payment in-stor . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4263"><question_text>contact ikea home card ? </question_text><answer id="AA4354"><answer_text>ikea home card issu ikano financi servic . question card , contact ikano custom servic 0871 781 3045 via email customerservice@ikano.net . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4264"><question_text>ikea catalogu ? </question_text><answer id="AA4355"><answer_text>ikea catalogu produc 30 languag 210 million copi deliv home 44 countri . catalogu offer glimps divers ikea product rang . ll discov afford solut creativ approach help inspir home furnish idea live . idea inspir onlin catalogu come augment realiti . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4265"><question_text>copi ikea catalogu ? </question_text><answer id="AA4356"><answer_text>ikea catalogu mass-distribut annual ikea store . receiv &#39;s catalogu , stop ikea store near free copi . altern , view catalogu onlin download catalogu , view ikea catalogu app smart phone avail app store . unfortun unabl post copi . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4266"><question_text>catalogu ? </question_text><answer id="AA4357"><answer_text>annual catalogu distribut august/septemb valid . price guarante increas catalogu valid . discov furnish , accessori set detail inform materi , colour , size , product care , price addit content access mobil phone . plan visit ikea comfort own home ! </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4267"><question_text>environment friend ikea catalogu ? </question_text><answer id="AA4358"><answer_text>catalogu print total chlorine-fre paper contain 10-15 % post-consum wast . rainforest old-growth fibr . pre-press process 100 % digit , mean film none associ chemic . optic brighten paper . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4268"><question_text>set softwar comput view ikea site ? </question_text><answer id="AA4359"><answer_text>view ikea site normal modern web browser chrome , firefox , internet explor safari.both chrome firefox automat updat frequent basi ikea recommend user upgrad .for internet explor support version 8 11 , safari support version 5 7.if use smartphon tablet android , chrome browser built android browser android version 2.3.if use iphon ipad safari support version 5 7.the ikea site built support wide rang browser modern browser mention fine , activ test develop .one except , internet explor 7 earlier support featur . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4269"><question_text>inform collect visit site ? </question_text><answer id="AA4360"><answer_text>requir inform obtain access site , unless specif state . specif inform provid servic , famili card . inform request includ name , titl , compani , address , e-mail address , phone . anonym track traffic pattern use cooki , measur site perform improv . cooki piec inform store comput read browser . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4270"><question_text>ikea product site ? </question_text><answer id="AA4361"><answer_text>site featur hundr ikea product demonstr breadth depth product rang ; , portion ikea’ complet product rang . store carri larger select . visit local ikea store look select . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4271"><question_text>i’v forgotten account email password </question_text><answer id="AA4362"><answer_text>retriev email address attach account lost password select “password help ” log page . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4272"><question_text>own ikea concept ? </question_text><answer id="AA4363"><answer_text>ikea retail , swedish root , base franchis system . inter ikea system b.v. , locat delft , netherland , owner franchisor ikea concept . ikea store oper franchise 29 countri . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4273"><question_text>distribut ikea product ? </question_text><answer id="AA4364"><answer_text>ikea experi product , retail concept . concept , aspect . , ikea product sold ikea store franchis inter ikea system b.v. </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4274"><question_text>franchise ? </question_text><answer id="AA4365"><answer_text>ikea product sold sole store oper ikea retail system--franchis inter ikea system b.v. netherland . franchis grant inter ikea system b.v. detail expans plan . serious applic care research evalu franchis grant compani and/or individu strong financi proven record retail . pleas visit franchisor site inform . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4275"><question_text>ikea ? </question_text><answer id="AA4366"><answer_text>ikea privat compani own charit foundat netherland . ikea activ develop , purchas , distribut sell ikea product . ikea biggest franchise oper 100 ikea store . manag servic ikea provid ikea intern a/ humlebaek , denmark . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4276"><question_text>ikea busi idea ? </question_text><answer id="AA4367"><answer_text>ikea busi idea : &#34; offer wide rang well-design , function home furnish product price low peopl abl afford . &#34; inform ikea found . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4277"><question_text>job opportun ikea ? </question_text><answer id="AA4368"><answer_text>out-go , dedic , customer-servic orient team , contact ikea store near open . view open local store visit job section websit . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4278"><question_text>ikea approach environment issu ? </question_text><answer id="AA4369"><answer_text>re creat everyday life peopl . includ do help creat world care environ . inform peopl planet section websit . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4279"><question_text>ikea product manufactur </question_text><answer id="AA4370"><answer_text>ikea 1200 furnitur supplier world 100 food supplier 275 supplier transport . five countri suppli servic ikea china , poland , itali , germani sweden . profil well-design qualiti rang distinct swedish/scandinavian . low price liter built product flat pack facilit ration distribut , self-servic immedi take-away . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4280"><question_text>regist uk busi address vat ? </question_text><answer id="AA4371"><answer_text>ikea limit compani regist england regist offic witan gate hous 500-600 witan gate west milton keyn mk9 1sh compani 01986283 . vat 527773320 . ikea limit licens sell ikea brand name inter ikea system b.v. , compani regist netherland . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4281"><question_text>gift card onlin ? </question_text><answer id="AA4372"><answer_text>ikea gift card purchas onlin scratch pin card , card issu octob 2013 pin . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4282"><question_text>gift card valid ? </question_text><answer id="AA4373"><answer_text>gift card expiri date . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4283"><question_text>gift card countri ? </question_text><answer id="AA4374"><answer_text>pleas list countri accept uk gift card . </answer_text><num_votes>1</num_votes></answer></question><question id="QQ4284"><question_text>purchas gift card ? </question_text><answer id="AA4375"><answer_text>gift card purchas store onlin . </answer_text><num_votes>1</num_votes></answer></question></lecture></course>