<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE course SYSTEM "corpus.dtd"><course id="C2" title="Informatica Generale 1" lang="IT"><lecture id="L36" title="Gestione dei File, Ricorsione" date="2013-11-11"><question id="Q3372"><question_text>Qual&#39;è l&#39;utilità di accedere ad un file un maniera casuale?</question_text><answer id="A3288"><answer_text>L utilità di accedere ad un file in maniera casuale sta&#39; nel fatto che è possibile leggere e 
scrivere i dati in qualsiasi ordine.

(Con i file sequenziali è sempre necessario partire dall?inizio del file e procedere in ordine 
con la scansione attraverso il file).</answer_text><num_votes>0</num_votes></answer><answer id="A3418"><answer_text>L&#39;accesso casuale ad un file permette di accedere al suo contenuto specificando la posizione relativa al suo interno.</answer_text><num_votes>0</num_votes></answer><answer id="A3326"><answer_text>L&#39;utilità risiede nel fatto che al momento dell&#39;apertura del file(open) verrà inizializzato un indicatore di posizione del file.</answer_text><num_votes>0</num_votes></answer><answer id="A3335"><answer_text>L&#39;utilità di accedere a un file in modo casuale, sta nel fatto di poter accedere al contenuto di questo file più velocemente che in modo sequenziale, in quanto si ha un offset che consente di spostarsi all&#39;interno del file, senza partire necessariamente dall&#39;inizio, ma partendo dalla posizione che si desidera. Questa funzionalità risulta particolarmente utile se si vuole accedere in modo rapido e comodo al contenuto di un file particolarmente grande.  </answer_text><num_votes>4</num_votes></answer></question><question id="Q3371"><question_text>Quali sono e che funzione hanno i flussi che vengono aperti al momento dell&#39; esecuzione di un programma?</question_text><answer id="A3291"><answer_text>Sono stdout, stderr e stdin. I primi due sono associati al video terminale, l&#39;ultimo alla tastiera. LO stdin serve per mandare al programma i dati di input, lo stdout serve al programma per ritornare i dati di output. Lo stderr è un flusso per output ma è specifico per i messaggi d&#39;errore.</answer_text><num_votes>1</num_votes></answer><answer id="A3398"><answer_text>I flussi che vengono aperti all&#39;inizio del programma sono generalmente lo standard input/output (&#60;stdio.h&#62;). Lo standard input permette al programma di acquisire un flusso di dati in input da tastiera attraverso un operazione di lettura, invece lo standard output permette al programma, attraverso un&#39;operazione di scrittura, di generare un output. Come esempio si può prendere in considerazione l&#39;operazione di cin, cout nel C++ </answer_text><num_votes>1</num_votes></answer><answer id="A3328"><answer_text>Al momento esecuzione di un programma vengono aperti tre flussi (streams) standard: 
Due associati al video terminale:
- stdout
- stderr
E Uno associato alla tastiera: 
- stdin
(Funzioni printf or scanf usano questi flussi)</answer_text><num_votes>0</num_votes></answer></question><question id="Q3290"><question_text>A cosa serve aprire in modalità binaria in lettura/scrittura un file?</question_text><answer id="A3363"><answer_text>Semplicemente è un modo per poter capire numericamente cosa viene scritto in un file. Chiaramente è utile solo nel caso siano utilizzati dei valori boolenai, in quanto è scomodo avere in lettura una sequenza di valori come 00011101 dai quali non si capisce niente!</answer_text><num_votes>3</num_votes></answer><answer id="A3273"><answer_text>Per aprire il file in modo che si possa sia leggere che scrivere, si passa come stringa di modalità alla funzione fopen la stringa &#34;r+&#34;. Per leggere si usa come al solito la funzione fread mentre per scrivere si usa la funzione fwritef. Leggere e scrivere richiede però di introdurre il concetto di posizione corrente all&#39;interno del file. Quello che li rende differenti da un vettore di caratteri è il fatto che il dispositivo in cui è memorizzato è il disco invece che la memoria primaria. </answer_text><num_votes>2</num_votes></answer></question><question id="Q3387"><question_text>Come si possono definire il caso base e il caso induttivo? Come si risolve il caso induttivo?</question_text><answer id="A3407"><answer_text>Il caso base è quando un certo problema può essere risolto direttamente senza ricorsioni, mentre il caso induttivo è quando si hanno bisogno di una serie di passaggi per arrivare alla soluzione del problema. Per risolvere col metodo induttivo si divide il problema in problemi più piccoli (supponendo di saperli risolvere) e poi tramite calcoli si arriva alla soluzione del problema principale.</answer_text><num_votes>1</num_votes></answer><answer id="A3297"><answer_text>Il caso base rappresenta la classe di istanze sufficientemente piccole(=semplici) da poter essere risolte in maniera diretta(=senza ricorsione).
Il caso induttivo,cioè la classe di istanze rimanenti, si prestano ad essere risolte mediante il seguente procedimento:
Si estraggono dall&#39;istanza presa in considerazione una o più istanze dello stesso problema che sono più piccole di quella di partenza, poi si suppone di risolvere direttamente le istanze (in realtà è anche questo un procedimento ricorsivo) e infine compongono le varie soluzioni in modo da formare la soluzione di quella di partenza.</answer_text><num_votes>0</num_votes></answer><answer id="A3426"><answer_text>Il caso base studia la risoluzione del problema in maniera diretta, senza ricorsione (ad es. x vale per 0); il caso induttivo invece vede la risoluzione del problema attraverso un determinato procedimento ricorsivo (ad es. x vale per n e n+1). In sostanza si può affermare che il caso base è un caso particolare del caso induttivo. Per risolvere il caso induttivo si suddivide il problema in parti (istanze) più semplici in modo da poterle risolvere direttamente e successivamente si uniscono le soluzioni ottenute per pervenire alla soluzione del problema di partenza.</answer_text><num_votes>2</num_votes></answer></question><question id="Q3316"><question_text>Cosa si intende con ricorsione diretta e indiretta?</question_text><answer id="A3351"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>1</num_votes></answer><answer id="A3347"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3353"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3344"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3348"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3354"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3341"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3345"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>1</num_votes></answer><answer id="A3349"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3352"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3342"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3350"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3343"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>2</num_votes></answer><answer id="A3340"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3338"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3339"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer><answer id="A3346"><answer_text>Una funzione ricorsiva è una funzione che richiama sé stessa (ricorsione diretta) o richiama una funzione che a sua volta la richiama (ricorsione indiretta). </answer_text><num_votes>0</num_votes></answer></question><question id="Q3304"><question_text>quale è la dimostrazione utilizzata per il calcolo del tempo di convergenza dell&#39;algoritmo merge sort?</question_text><answer id="A3393"><answer_text>L&#39;algoritmo Merge Sort, per ordinare una sequenza di &#34;n&#34; oggetti, ha complessità 
T(n) = O(n\log n) sia nel caso medio che nel caso pessimo. 
Infatti la funzione merge ha complessità O(n), inoltre essa richiama se stessa due volte, e ogni volta su (circa) metà della sequenza in input.
Da questo segue che il tempo di esecuzione dell&#39;algoritmo è dato dalla ricorrenza:

T(n) = 2T(n/2)+O(n)

la cui soluzione è proprio O(n \log n). 
</answer_text><num_votes>1</num_votes></answer><answer id="A3366"><answer_text>Chiamo T(n) il numero di visite necessarie per ordinare un array di n elementi.
con mergesort: T(n)=2T(n/2)+5n
sapendo che l&#39;algoritmo divide per 2 l&#39;array,la formula diventa: T(n/2)=2T(n/4)+5(n/2),quindi T(n)=2*2T(n/4)+5n+5n.
Divido ulteriormente:T(n/4)=2T(n/8)+5(n/4) e quindi T(n)=2*2*2T(n/8)+5n+5n+5n.
Scrivo 2,4,8 come potenze arbitrarie di 2: T(n)=2^(k)T(n/2^(k))+5nk.
Assumo che n=2^(m),per k=m:T(n)=2^(m)T(n/2^(m))+5nm = nT(1)+5nm =n+5n log(2)(n)(dato che n=2^(m) implica m=log(2)(n)).
al crescere della funzione tralascio grado n,valore costante e base2 log. 
Ordinamento= O(nlog(n))</answer_text><num_votes>1</num_votes></answer></question><question id="Q3431"><question_text>L&#39;utilizzo della ricorsione richiede un uso maggiore di risorse di computazione o di memoria? Perché?</question_text><answer id="A3308"><answer_text>La ricorsione genera una massiccia occupazione dello stack, in quanto ogni chiamata di funzione che è necessaria per la risoluzione del problema produce un risultato che viene memorizzato.
La ricorsione impegna fortemente il processore, che deve popolare e distruggere lo stack.
Di conseguenza, funzioni implementate ricorsivamente, potrebbero dare problemi in termini di tempo di esecuzione. </answer_text><num_votes>2</num_votes></answer><answer id="A3376"><answer_text>La ricorsione, sebbene porti vantaggi nella scrittura di un codice, ha delle prestazioni poco vantaggiose.
Essa genera un&#39;enorme quantità di dati che occupano una gran parte della memoria. Infatti i dati che vengono richiamati delle funzioni occupano lo stack e il processore viene richiamato in causa ogni qual volta vi è una modifica in esso.</answer_text><num_votes>0</num_votes></answer><answer id="A3311"><answer_text>La ricorsione permette un utilizzo più efficiente della memoria e dunque ne richiede un uso spesso minore. Infatti con la ricorsione si utilizza sono in memoria la memoria stack e molto di più la memoria heap che è dinamica e dunque non alloca in modo permanente le variabili ma da la possibilità al programma di utilizzare meno celle di memoria ed essere dunque più veloce nell&#39;esecuzione.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3374"><question_text>Cosa può succedere ad un file quando un programma termina inaspettatamente (crash)?</question_text><answer id="A3286"><answer_text>Quando apriamo un file, per far sì che il flusso di dati che vogliamo inserirci venga scritto,è  necessario chiuderlo o tramite un apposito comando &#34;fclose()&#34; oppure in automatico al termine del programma stesso(fine del main o exit).Se il programma per qualche motivo dovesse interrompersi inaspettatamente il file non verrebbe chiuso e il flusso di dati non è detto verrebbe scritto al suo interno e di conseguenza potremmo avere perdita di dati.</answer_text><num_votes>2</num_votes></answer><answer id="A3290"><answer_text>Quando il programma termina inaspettatamente non viene eseguita l&#39;operazione di &#34;fclose&#34;, che salva nel file i dati presenti nel buffer e termina l&#39;associazione tra il flusso di dati e la periferica, quindi i dati rimasti nel buffer vanno persi; possono comunque verificarsi anche altri effetti collaterali o addirittura la perdita del file.</answer_text><num_votes>4</num_votes></answer></question><question id="Q3396"><question_text>una funzione ricorsiva può essere sempre scritta in modo non ricorsivo o ci sono dei limiti?</question_text><answer id="A3317"><answer_text>Una funzione ricorsiva può essere scritta in modo non ricorsivo; però questo non porta dei vantaggi, anzi va a &#34;complicare&#34; l&#39;algoritmo.</answer_text><num_votes>0</num_votes></answer><answer id="A3412"><answer_text>Una funzione ricorsiva scritta in modo non ricorsivo, viene definita iterativa, cioè scritta attraverso dei cicli.
Sfortunatamente, non tutte le funzioni sono facilmente &#39;trasformabili&#39; da ricorsive a non-ricorsive, in alcuni casi la funzione non può essere trasformata senza una completa riscrittura, e non sempre ne vale la pena. Bisogna inoltre osservare che le funzioni iterative sono potenti, largamente applicabili, spesso efficienti ma possono risultare artificiose, poco leggibili e quindi difficili da comprendere. </answer_text><num_votes>2</num_votes></answer><answer id="A3416"><answer_text>Si puo scrivere anche non usando la ricorsione pero complicando il codice da scrivere.
Per esempio: in alcune funzioni &#34;semplici&#34; basta utilizzare un banale ciclo per eliminare l&#39;utilizzo della ricorsione. In altre funzioni piu complesse eliminare il metodo non ricorsivo e&#39; molto piu complesso ma possibile.

Un esempio pratico puo essere la funzione fattoriale
Ricorsivo:
int FattRic(int n){
 int ris;
 if (n == 0) ris = 1;
 else ris = n * FattRic(n?1);
 return ris;
}

Non ricorsivo:
int FattRic(int n){
 int i, ris;
 ris=1;
 for (i=1;i&#60;=n;i++)
   ris = ris *i;
}
return ris;
}</answer_text><num_votes>2</num_votes></answer></question><question id="Q3362"><question_text>Qual&#39;è la differenza tra printf e fprintf?</question_text><answer id="A3274"><answer_text>printf() è una funzione contenuta nella libreria &#34;stdio.h&#34; che permette di stampare (visualizzare) a video (in una &#34;console application&#34;) ciò che viene passato come parametro, fprintf() è invece una funzione che permette la scrittura (inserimento) in un file di ciò che viene passato come parametro. A differenza della funzione printf(), fprintf() richiede, oltre alle informazioni da stampare, anche il puntatore al file di destinazione.</answer_text><num_votes>0</num_votes></answer><answer id="A3275"><answer_text>Sono entrambe una funzioni contenute nella libreria &#34;stdio.h&#34;. printf() permette di stampare (visualizzare) a video, in una &#34;console application&#34;, ciò che viene passato come parametro, fprintf() permette invece la scrittura (inserimento) in un file di ciò che viene passato come parametro. A differenza della funzione printf(), fprintf() richiede, oltre alle informazioni da stampare, anche il puntatore al file di destinazione.</answer_text><num_votes>1</num_votes></answer><answer id="A3276"><answer_text>Sono entrambe una funzioni contenute nella libreria &#34;stdio.h&#34;. printf() permette di stampare (visualizzare) a video, in una &#34;console application&#34;, ciò che viene passato come parametro, fprintf() permette invece la scrittura (inserimento) in un file di ciò che viene passato come parametro. A differenza della funzione printf(), fprintf() richiede, oltre alle informazioni da stampare, anche il puntatore al file di destinazione.</answer_text><num_votes>1</num_votes></answer><answer id="A3292"><answer_text>La funzione printf viene utilizzata per visualizzare sullo standard output una stringa costruita in base ad un formato specificato. La fprintf è una funzione derivata dalla printf che permette la scrittura dell&#39;output su file.</answer_text><num_votes>2</num_votes></answer></question><question id="Q3334"><question_text>Quali sono i vantaggi dell uso di funzioni ricorsive? Cosa si intende per &#34;caso base&#34; ?
La ricorsione è sempre utilizzabile?</question_text><answer id="A3405"><answer_text>Una funzione si dice ricorsiva quando è definita secondo il seguente schema:
-uno o più casi base,in cui è definita in termini di altre funzioni più semplici note
-un caso ricorsivo 
L&#39;utilizzo di funzioni ricorsive ha un vantaggio principale:permette di scrivere poche linee di codice per risolvere un problema anche molto complesso.Tuttavia la ricorsione non è sempre utilizzabile poiché comporta un elevato consumo dello stack del sistema e se stiamo lavorando con uno stack limitato rischiamo di avere un crash del programma.
P.s: c&#39;e scritto ask A question quindi devi fare una domanda non 3</answer_text><num_votes>4</num_votes></answer><answer id="A3379"><answer_text>i vantaggi sono che si può ridurre un problema &#34;difficile&#34;, in una serie di problemi più &#34;semplici&#34;. questi problemi più semplici devono essere il/i caso/i base.
il caso base e un problema di cui si conosce facilmente la soluzione.
la ricorsione non è sempre utilizzabile, ma la maggior parte delle volte è integrabile.</answer_text><num_votes>0</num_votes></answer><answer id="A3380"><answer_text>i vantaggi sono che si può ridurre un problema &#34;difficile&#34;, in una serie di problemi più &#34;semplici&#34;. questi problemi più semplici devono essere il/i caso/i base.
il caso base e un problema di cui si conosce facilmente la soluzione.
la ricorsione non è sempre utilizzabile, ma la maggior parte delle volte è integrabile.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3401"><question_text>Qual&#39;è il ruolo del buffer di sistema nel processo di scrittura di un file?</question_text><answer id="A3392"><answer_text>Il buffer di sistema serve a memorizzare in modo temporaneo i file in scrittura così che poi questi possano essere manipolati.</answer_text><num_votes>1</num_votes></answer><answer id="A3419"><answer_text>Quando faccio un&#39;operazione di scrittura su file scrivo i dati contenuti nel buffer indicato dal nome del file su cui sto lavorando</answer_text><num_votes>0</num_votes></answer><answer id="A3382"><answer_text>Il buffer contiene i dati che verranno poi salvati con il comando fclose nel file precedentemente dichiarato. Infatti uno dei danni provocati dal non utilizzo del comando fclose è quello della perdita dei dati. Molto importante quindi usarlo.</answer_text><num_votes>1</num_votes></answer><answer id="A3365"><answer_text>Confrontate con la memoria centrale, le unità di memoria di massa richiedono tempi di accesso e scrittura molto elevati. Il ruolo del buffer di sistema (area della memoria centrale in cui viene memorizzato lo stream di dati prima di essere scritto sul file) è quello di rendere più veloce l&#39;esecuzione di un programma in cui è richiesta la scrittura su file . Una volta completata la scritture il buffer si svuota.  </answer_text><num_votes>1</num_votes></answer></question><question id="Q3291"><question_text>Cosa contiene il tipo strutturato FILE?</question_text><answer id="A3364"><answer_text>Il concetto di file intende la memorizzazione di dati in modo permanente, e quindi l?utilizzo in un secondo momento, oppure se la memoria centrale non è sufficiente per l?esecuzione del programma. 
Nel programma questo comporta la creazione di una variabile di tipo File, l?apertura di un flusso verso il file, le relative operazioni di lettura e scrittura e la importante operazione di chiusura che termina il flusso. Il file strutturato è una sequenza di lunghezza non prefissata di valori dello stesso tipo.  
</answer_text><num_votes>0</num_votes></answer><answer id="A3329"><answer_text>Un insieme di file.</answer_text><num_votes>0</num_votes></answer><answer id="A3295"><answer_text>Il tipo strutturato FILE è una sequenza, di lunghezza non prefissata, di valori dello stesso tipo (byte o caratteri) che contiene:
-Campo per Modalità di utilizzo: Lettura, scrittura o lettura e scrittura;
-Un campo per la Posizione corrente: Punta al prossimo byte da leggere o scrivere sul file;
-Un campo Indicatore di errore (per lettura e/o scrittura);
-Un campo contenente un indicatore di end-of-file (eof);
-Dichiarazione di variabile che punta a file in C: FILE *pf;
</answer_text><num_votes>4</num_votes></answer><answer id="A3404"><answer_text>E&#39; un buffer che contiene, similmente a un file di testo, tutti i dati che vengono letti e scritti su un file o una periferica. C accede a questo buffer per leggere e scrivere su periferiche o file reali sia binari che di testo.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3415"><question_text>Tra le operazioni di gestione dei file ve ne sono due molto importanti che sono &#34;r&#34;(lettura modalità testo) e &#34;rb&#34;(lettura modalità binario). Qual è la differenza tra queste due modalità?</question_text><answer id="A3410"><answer_text>Semplicemente la lettura in modalità binario legge esattamente i byte come 0 e 1 senza convertirli in un testo di caratteri ANSI C.

Invece la modalità testo converte i byte memorizzati in caratteri anche se potrebbe incorrere in qualche errore di corrispondenza.</answer_text><num_votes>0</num_votes></answer><answer id="A3409"><answer_text>Semplicemente la lettura in modalità binario legge esattamente i byte come 0 e 1 senza convertirli in un testo di caratteri ANSI C.

Invece la modalità testo converte i byte memorizzati in caratteri anche se potrebbe incorrere in qualche errore di corrispondenza.</answer_text><num_votes>0</num_votes></answer><answer id="A3408"><answer_text>Entrambe le modalità sono di lettura. La differenza sussiste nel fatto che l&#39; operazione &#34;r&#34; ci permette di leggere in modalità testo e quindi in caratteri di scrittura, che noi tutti conosciamo, mentre l&#39; operazione &#34;rb&#34; ci permette di leggere in formato binario e cioè il formato con cui lavorano i computer o calcolatori.</answer_text><num_votes>2</num_votes></answer><answer id="A3302"><answer_text>si usa &#34;r&#34;(lettura modalità testo) quando i file contengono caratteri stampabili e informazioni
interpretabili da un umano
&#34;rb&#34;(lettura modalità binario), invece viene usato quando i file contengono dati di vario genere (mix di caratteri stampabili e non)
</answer_text><num_votes>0</num_votes></answer></question><question id="Q3434"><question_text>A che cosa serve la funzione fopen(), come deve essere utilizzata? Quali sono le modalità che &#34;supporta&#34;?</question_text><answer id="A3322"><answer_text>Un file viene aperto con la funzione fopen, che restituisce uno stream di I/O allegato al file specificato da cui possono essere fatte lettura e scrittura. La funzione fopen contiene il nome del file e la modalità (es: FILE* fp;  fp = fopen(nomefile,modalità); ). Le modalità previste sono: &#34;r&#34; (lettura modalità testo), &#34;w&#34; (scrittura modalità testo), &#34;rb&#34; (lettura modalità binario) e &#34;wb&#34; (scrittura modalità binario), in cui lo stream è posizionato a inizio file, oppure &#34;a&#34; (scrittura modalità testo) e &#34;ab&#34; (scrittura modalità binario), in cui lo stream è posizionato a fine file. </answer_text><num_votes>4</num_votes></answer><answer id="A3307"><answer_text>la funzione fopen() si utilizza nel caso in cui si vuole aprire un file, in lettura o in scrittura:
ad esempio scrivendo 

FILE* fin;
fin=fopen(nomefile, &#34;r&#34;);

si vuole aprire il file(&#34;nomefile&#34; indicherà appunto il nome del file) in sola lettura(&#34;read&#34;); mentre se si vuole aprire un file in sola scrittura:
fin=fopen(nomefile, &#34;w&#34;);

le modalità che supporta sono:
&#34;r&#34;: lettura testo - inizio file
&#34;w&#34;: scrittura testo
&#34;a&#34;: scrittura modalità testo - fine file
&#34;rb&#34;: lettura modalità binario 
&#34;wb&#34;:scrittura modalità binario 
&#34;ab&#34;: scrittura modalità binario</answer_text><num_votes>0</num_votes></answer><answer id="A3374"><answer_text>La funzione fopen() permette la creazione di un collegamento tra un flusso e un file di una periferica. La funzione consente di aprire un file gia&#39; esistente o di crearne uno di nuovi e di associarvi un flusso; permette anche di leggere i dati in maniera differente: lettura e/o scrittura in modalita&#39; testo all&#39;inizio del file, scrittura in modalita&#39; testo alla fine del file, lettura e/o scrittura in modalita&#39; binario all&#39;inizio del testo e scrittura in modalita&#39; binario alla fine del testo.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3421"><question_text>Come sono definite le funzioni fwrite() e fread() e a cosa servono?</question_text><answer id="A3381"><answer_text>Sono definite come segue:
int fread (void* punt, int dim_elemento, int n_elementi, FILE* pf);
int fwrite (void* punt, int dim_elemento, int n_elementi, FILE* pf);

fread() legge n_elementi di dim_elemento byte ciascuno dal &#38;#64257;le indicato da pf. Tali elementi vengono copiati in memoria a partire dall&#39;indirizzo punt. Il risultato è il numero di elementi letti.
fwrite() invece scrive n_elementi, di dim_elemento byte ciascuno, sul &#38;#64257;le indicato da pf, prelevandoli dalla memoria a parire da punt. La funzione restituisce il numero di elementi scritti.</answer_text><num_votes>1</num_votes></answer><answer id="A3334"><answer_text>Le funzioni fread() e fwrite() sono due funzioni che vengono utilizzate per la lettura e la scrittura di un file in bianrio. Per entrambe le funzioni è necessario passare il puntatore al file (&#34;FILE *fp&#34;), il tipo di dato da scrivere (es int, o una struttura, dimelemento) e il puntatore all&#39;elemento che si vuole memorizzare su file (void *ptr). Abbiamo pure la possibilità di scrivere per più volte lo stesso dato, passando alla funzione un valore (&#34;numelementi&#34;).
Quinidi concludendo:
- fwrite(void *ptr,dimelemento,numelementi, FILE *fp);
- fread(void *ptr,dimelemento,numelementi, FILE *fp);</answer_text><num_votes>0</num_votes></answer><answer id="A3417"><answer_text>queste funzioni servono a:
fwrite serve a scrivere un blocco di dati binari e prelevandoli dalla zona di memoria indirizzata da  ptr. Restituisce  il numero di elementi effettivamente letti  ed è definita intfwrite(void*ptr, dimelemento, numelementi, FILE   *fp)
invece fread serve a leggere un blocco di dati  maggiori di un byte e li memorizza nella zona di memoria indirizzata da ptr . Restituisce  il numero di elementi effettivamente letti. ed è definita int fread(void *ptr, dimelemento, numelementi, FILE *fp) con int che può cambiare a seconda di cosa vogliamo per esempio float ,int ecc.</answer_text><num_votes>0</num_votes></answer><answer id="A3277"><answer_text>Sintassi: size_t fwrite (void *ptr, size_t size, size_t blocks, FILE *fp); 
             size_t fread (void *ptr, size_t size, size_t blocks, FILE *fp);
Servono a scrivere e leggere, rispettivamente, blocchi di dati (anche strutture) di dimensione &#34;size_t size&#34;, scrivendo o leggendone &#34;size_t blocks&#34; e immagazzinandoli nella variabile puntata da ptr. Restituiscono il numero di byte scritto o letto.
Queste due funzioni sono usate per la scrittura/lettura di dati binari su file, modalità (binaria) che si rende necessaria per gestire file contenenti dati di tipo strutturato (dimensione=cost)</answer_text><num_votes>0</num_votes></answer><answer id="A3281"><answer_text>int fwrite(*ptr,dimensioneelemento,numelementi,FILE *fp);
int fread(*ptr,dimensioneelemento,numelementi,FILE *fp). Sono delle funzioni che servono a scrivere/leggere un blocco di dati in un file BINARIO. é necessario specificare, quindi sia la dimensione di un singolo elemento che il numero di elementi da scrivere/leggere. I dati da  scrivere sul file vengono presi dalla zona di memoria puntata da ptr e scritti nel file puntato da *fp. I dati da leggere vengono presi dal file puntato da *fp e memorizzati nella zona di memoria puntata da *ptr. Entrambi restituiscono il numero di elementi letti</answer_text><num_votes>2</num_votes></answer></question><question id="Q3336"><question_text>che cosa si intende per stream? di quali tipi può essere? </question_text><answer id="A3284"><answer_text>Lo stream è un flusso di dati, per meglio dire un&#39;astrazione a livello di linguaggio di programmazione. può essere di due tipi lo stream:
-di tipo binario (sequenza pura di byte che vengono memorizzati dalla periferica esattamente come sono stati scritti);
-di tipo testo (è una sequenza di caratteri, ma stavolta non è garantita la sequenza tra i caratteri scritti e quelli memorizzati dalla periferica).</answer_text><num_votes>2</num_votes></answer><answer id="A3301"><answer_text>Lo strem è un&#39;astrazione che mette a disposizione dell&#39;utente di C un&#39;interfaccia consistente per la gestione delle operazioni di Input ed Output che sia uguale indipenddentemente dalla periferica fisica usata. esso puo essere binario(sequenza di byte) o di testo(sequenza di caratteri).</answer_text><num_votes>1</num_votes></answer><answer id="A3312"><answer_text>C fornisce una interfaccia consistente perla gestione I/O indipendente della periferica. Ovvero viene fornito un livello di astrazione a livello di linguaggio di programmazione. 
Questa astrazione viene chiamata stream (periferica logica) e la periferica (hard disk, 
stampante etc..) file.
E&#39; possibile collegare un file ad uno stream tramite un&#39;operazione di &#34;open&#34;. Una volta eseguita questa operazione i dati possono essere scambiati tra il programma utente ed il file. 
Ci sono due tipi di stream: binario (sequenza di byte) e di tipo testo (sequenza di caratteri).</answer_text><num_votes>1</num_votes></answer></question><question id="Q3391"><question_text>Cos&#39;e&#39; un algoritmo ricorsivo? Quali sono le differenze tra algoritmo ricorsivo e algoritmo iterativo?</question_text><answer id="A3294"><answer_text>In informatica viene detto algoritmo ricorsivo un algoritmo espresso in termini di se stesso, ovvero in cui l&#39;esecuzione dell&#39;algoritmo su un insieme di dati comporta la semplificazione o suddivisione dell&#39;insieme di dati e l&#39;applicazione dello stesso algoritmo agli insiemi di dati semplificati.
Un algoritmo iterativo è una tipologia di algoritmo costituito da una sequenza di azioni che viene ripetuta finite volte.</answer_text><num_votes>3</num_votes></answer><answer id="A3336"><answer_text>Un algoritmo ricorsivo consiste, in una funzione che richiama se stessa, infatti il suo scopo e scomporre il problema in problemi più piccoli fino a che non si arrivano a delle soluzioni base, la differenza con quello interativo sta proprio qua, con questo non posso farlo.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3324"><question_text>Quali sono i vantaggi/svantaggi di gestire un file in modalità testo rispetto ad uno in modalità binaria?</question_text><answer id="A3325"><answer_text>Con i file binari si ha una corrispondenza 1 a 1 garantita per la sequenza di byte, cosa che non si ottiene con i file testo, inoltre non occorre fare nessuna traduzione.</answer_text><num_votes>0</num_votes></answer><answer id="A3356"><answer_text>In un file di tipo testo si ha la codifica dei dati tramite una sequenza di caratteri, dove generalmente non è garantita la corrispondenza tra file scritti o letti e quelli in memorizzati nella periferica. Un file di tipo binario, invece, è formato da una sequenza di bytes, i quali corrispondono uno ad uno con la periferica. All&#39;interno non c&#39;è una vera e propria traduzione dell&#39;informazione in quanto i numeri di byte letti o scritti sono gli stessi memorizzati nella periferica. Quindi è più vantaggioso gestire un file binario rispetto ad uno di tipo testo perchè ha un lettura più rapida.</answer_text><num_votes>2</num_votes></answer></question><question id="Q3389"><question_text>Spiegare la differenza tra stream e file e descrivere in che modo vengono utilizzati nell&#39;ambito della programmazione, fare degli esempi del loro utilizzo.</question_text><answer id="A3370"><answer_text>In C gli stream sono delle astrazioni rappresentative di un file o di un dispositivo fisico, che vengono manipolate attraverso l&#39;uso di puntatori. I file sono contenitori di informazioni che sono associati alle periferiche(es.hard disk) e gestiti dal sistema operativo; ciascuna periferica di I/O e&#39; rappresentata da un file cosicche&#39; l&#39;accesso ad esse viene visto come accesso a files. Un file viene associato ad uno stream con un&#39;operazione di &#39;open&#39;, dopo la quale i dati possono essere scambiati tra il programma utente e il file; un file si dissocia da uno stream con l&#39;operazione di &#39;chiusura&#39;.</answer_text><num_votes>0</num_votes></answer><answer id="A3283"><answer_text>Con stream si intende l&#39;interfaccia, il flusso di comunicazione attraverso cui l&#39;utente opera la gestione del file, che è invece un contenitore di informazioni memorizzate sulla periferica hardware e a cui si ha accesso attraverso lo stream. Ad esempio un file può essere associato ad uno stream mediante il comando &#34;open&#34;; in questo modo ha origine uno scambio di dati tra il programma utente ed il file. </answer_text><num_votes>0</num_votes></answer><answer id="A3406"><answer_text>Gli streams (o flussi) sono quelle astrazioni fornite a livello di linguaggio di programmazione per la gestione I/O indipendente della periferica. Permettono di accedere ai file in maniera simile e si comportano tutti alla stessa maniera, ovvero le operazioni che operano su di essi sono le stesse per tutti. I file sono invece dei contenitori di informazioni associati a periferiche e gestiti dal Sistema Operativo. Il file può essere associato ad uno stream mediante un&#39;operazione di &#34;open&#34;. Una volta eseguita questa operazione i dati possono essere scambiati tra il programma utente ed il file.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3404"><question_text>Quali sono le principali differenze tra le funzioni fscanf e fgets? Quando è meglio usare una o l&#39;altra?</question_text><answer id="A3402"><answer_text>La funzione fscanf funziona esattamente come la scanf, ma opera su file; restituisce il numero di campi letti con successo e, in caso di errore, 0 o EOF. La funzione fgets necessita, oltre che della specifica della stringa dove depositare la riga letta, della quantità massima di caratteri da leggere e del canale attraverso il quale effettuare la lettura; la funzione legge dal file fino al numero di caratteri specificato o al newline, se questo viene incontrato prima. Non si può infatti conoscere l?esatta lunghezza del dato contenuto nel campo e così si utilizza il newline come delimitatore.</answer_text><num_votes>0</num_votes></answer><answer id="A3327"><answer_text>Fscanf e Fgets sono entrambe funzioni di lettura di dati. La prima legge i dati in input fino ad uno spazio bianco, mentre la seconda legge fino ad un invio a capo. Inoltre fgets salva i dati letti in un array inserendo un NULL come ultima cella dell&#39;array, fscanf invece legge solo in basa alla formattazione data all&#39;inizio. Se si è sicuri di ciò che si avrà nell&#39;input allora è conveniente usare fscanf, ma essendo essa molto instabile (Manda il programma in overflow se il dato in input è di un formato diverso da quello aspettato) spesso conviene usare fgets poiché causa meno errori.</answer_text><num_votes>4</num_votes></answer></question><question id="Q3341"><question_text>e&#39; possibile eseguire la lettura di dati in modalità binaria da un file scritto non in modalità binaria? cosa succede?</question_text><answer id="A3422"><answer_text>si è possibile solo che i file in binario hanno un dimensione limitata e minore rispetto a quello di testo, è più difficile correggerli in caso di errore; e nella lettura vengono a formarsi una serie molto lunga di 0 e 1, difficile da comprendere. </answer_text><num_votes>2</num_votes></answer><answer id="A3413"><answer_text>Sì è possibile la lettura in modalità binaria di un file non in modalità binaria, ma questo apparirebbe come un insieme di &#34;zeri e uni&#34;, poi non tradotto è stato tradotto in codifica ASCII e i caratteri vengono visualizzati come i numeri(in binario) ai quali corrispondono.
</answer_text><num_votes>0</num_votes></answer><answer id="A3371"><answer_text>La lettura di un file binario avviene tramite la funzione fread.
è possibile eseguire l&#39;operazione di lettura di dati in modalita binaria da un file non scritto in modalita binaria, ma il dato viene interpretato erroneamente e quindi lo si legge sbagliato.</answer_text><num_votes>0</num_votes></answer><answer id="A3372"><answer_text>La lettura di un file binario avviene tramite la funzione fread.
è possibile eseguire l&#39;operazione di lettura di dati in modalita binaria da un file non scritto in modalita binaria, ma il dato viene interpretato erroneamente e quindi lo si legge sbagliato.</answer_text><num_votes>0</num_votes></answer><answer id="A3369"><answer_text>La lettura di un file binario avviene tramite la funzione fread.
è possibile eseguire l&#39;operazione di lettura di dati in modalita binaria da un file non scritto in modalita binaria, ma il dato viene interpretato erroneamente e quindi lo si legge sbagliato.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3315"><question_text>Che differenza c&#39;è tra fputs() e fputc()? Come operano le due funzioni? Cosa ricevono in input e cosa danno in output? Cosa indica la f?</question_text><answer id="A3397"><answer_text>La f indica che le funzioni operano nel campo dei file, quindi l&#39;output non sarà più lo schermo ma un file (solitamente di testo).
Ecco le differenze:
- int fputc(int a, FILE* stream) apre lo stream sul file, prenderà in ingresso il char &#34;a&#34; e scriverà sul file questo carattere
- int fputs(char* s, FILE* stream) apre lo stream sul file, prenderà in ingresso il puntatore a char &#34;s&#34;, scriverà su file tutti i caratteri della stringa fino a quando non troverà il carattere di controllo /0.
</answer_text><num_votes>1</num_votes></answer><answer id="A3332"><answer_text>Le funzioni fputs() e fputc() differiscono per il modo in cui operano: la prima scrive linee (stringhe di char terminate da newline) sul file specificato come parametro di ingresso, mentre la seconda scrive come prossimo carattere del file il carattere specificato tra i parametri di ingresso. La prima riceve in input il puntatore al file e la stringa da inserire, la seconda riceve in input il carattere e il puntatore al file; la prima restituisce 0 se l&#39;operazione è riuscita, un valore diverso da 0 in caso contrario, la seconda restituisce (come intero) il carattere inserito.La f indica file.</answer_text><num_votes>0</num_votes></answer><answer id="A3331"><answer_text>La f indica che le operazioni verranno svolte su flussi(cioè file). Con fputs() inseriamo su file una stringa immessa da tastiera mentre con fputc() inseriamo su file un carattere. La funzione fputs() riceve in input il puntatore alla stringa da inserire e il puntatore del file, mentre fputc() riceve il valore intero del carattere da inserire e il puntatore al file. In caso di successo fputs() restituisce in output un numero non negativo e fputc() ritorna il carattere scritto; in caso di errore restituiranno entrambi EOF(End Of File).</answer_text><num_votes>1</num_votes></answer></question><question id="Q3354"><question_text>Quali sono le principali caratteristiche di un algoritmo ricorsivo e quali sono i vantaggi/svantaggio rispetto ad una programmazione non ricorsiva?</question_text><answer id="A3425"><answer_text>Una funzione è detta ricorsiva se per determinare il proprio valore, essa ricorre al calcolo di un&#39;altro valore ripetendo la chiamata a se stessa. Per essere valida, deve prevedere una condizione (detta punto di ritorno) per la quale restituisce un valore, al fine di evitare il loop. E&#39; da notare come il calcolo dei valori avvenga in ordine inverso rispetto a quello delle chiamate. L&#39;uso della ricorsione può rendere più semplice la programmazione, che risulta compatta ed elegante, sebbene sia meno efficiente dell&#39;iterazione in termini di occupazione della memoria e di velocità di esecuzione.</answer_text><num_votes>1</num_votes></answer><answer id="A3401"><answer_text>Le principali caratteristiche affinchè un algoritmo possa essere espresso in forma ricorsiva sono:
-la possibilità di formulare l&#39;algoritmo in funzione di se stesso;
-l&#39;esistenza di una condizione di terminazione, affinche non si verfichino cicli infiniti; 
Il principale vantaggio di tali funzioni è che permettono di risolvere problemi complessi con poche righe di programma.Dal punto di vista delle prestazioni potrebbero essere svantaggiosi.Funzioni che occupano una grossa quantità di spazio in memoria potrebbero dare problemi a tempo di esecuzione.</answer_text><num_votes>1</num_votes></answer><answer id="A3396"><answer_text>La RICORSIONE è un elegante strumento concettuale, utile in situazioni che richiedono una soluzione induttiva, ovvero quando la soluzione può essere ridotta e risolta in problemi simili più piccoli.

C.Base: istanza semplice, risolvibile in modo diretto senza ricorsione.
C.Induttivo: istanze non risolvibili direttamente ma attraverso un certo procedimento.

E&#39; Diretta se un sott.programma chiama se stesso durante l&#39;esecuzione, Indiretta se viene chiamato da altri che aveva aperto in precedenza.

Vantaggiosa per la Gestione Dinamica e per le Pile, ma elaborato e non sempre utilizzabile.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3305"><question_text>cos&#39;è una variabile di tipo FILE?</question_text><answer id="A3287"><answer_text>Un FILE è un tipo strutturato che contiene: 
-Campo per Modalità di utilizzo: Lettura, scrittura o lettura e scrittura; ?
-Un campo per la Posizione corrente: Punta al prossimo byte da leggere o scrivere sul file; ?--Un campo Indicatore di errore (per lettura e/o scrittura) ?
-Un campo contenente un indicatore di end-of-file (eof).
?Dichiarazione di variabile che punta a file in C: FILE *fp;</answer_text><num_votes>0</num_votes></answer><answer id="A3415"><answer_text>Un &#34;FILE&#34; è un tipo strutturato contenente: campo per Modalità di utilizzo: riguardante la lettura, scrittura o lettura e scrittura; un campo per la Posizione corrente: punta al prossimo byte da leggere o scrivere sul file; un campo Indicatore di errore (per lettura e/o scrittura), un campo contenente un indicatore di end-of-file (eof)?.
Dichiarazione di variabile che punta a file in C:
FILE *fp;</answer_text><num_votes>1</num_votes></answer><answer id="A3389"><answer_text>è una variabile che apre o crea un file esterno al programma , ad esempio con la funzione open() , con lo scopo di editare il tale file. Buon natale a tutti :) </answer_text><num_votes>1</num_votes></answer><answer id="A3387"><answer_text>E&#39; una variabile che punta ad un file che il sistema operativo gestisce tramite tabella dei file aperti.</answer_text><num_votes>0</num_votes></answer><answer id="A3386"><answer_text>E&#39; una variabile che punta ad un file che il sistema operativo gestisce tramite tabella dei file aperti.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3332"><question_text>Dal punto di vista dell&#39;utilizzo delle risorse di sistema, è meglio utilizzare un algoritmo iterativo o ricorsivo? Perchè?</question_text><answer id="A3320"><answer_text>Innanzitutto ricordiamo che gli algoritmi iterativi e ricorsivi dal punto di vista COMPUTAZIONALE sono equivalenti(cioè in teoria sono convertibili). Si noti che se la versione ricorsiva(per definizione matematica) è più elegante e compatta, allo stesso tempo risulta meno efficiente di quella iterativa poichè occupando lo stack per un numero di istanze pari alle chiamate della funzione, utilizza una grossa quantità di spazio in memoria e rallenta notevolmente il tempo di esecuzione del processore. Dunque se le prestazioni sono l&#39;obiettivo principale del programma si preferisce l&#39;iterazione.</answer_text><num_votes>3</num_votes></answer><answer id="A3411"><answer_text>Con algoritmo ricorsivo e&#39; possibile ridurre l&#39;utilizzo delle risorse di sistema, perchè un determinato programma puo&#39; richiamare se stesso durante la sua esecuzione in modo diretto o indiretto</answer_text><num_votes>1</num_votes></answer><answer id="A3421"><answer_text>Nell&#39;iterazione si eseguono ripetutamente delle righe di codice (cicli for, while, do..while) mentre con la ricorsione è tutta la routine che richiama sé stessa. Ciò si ottiene solitamente tramite una -ripetuta- chiamata a funzione, che non ha un costo trascurabile. Per questo generalmente un algoritmo ricorsivo ha un codice più compatto rispetto al suo analogo iterativo, ma ha un consumo di memoria maggiore. Il calcolatore infatti deve tenersi in memoria ogni chiamata di funzione fino all&#39;ultima, dalla quale parte per risolvere il problema.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3340"><question_text>Elencare e descrivere i tre passi che caratterizzano l&#39;algoritmo di ordinamento &#34;merge sort&#34;. </question_text><answer id="A3437"><answer_text>Il merge sort è un algoritmo di ordinamento basato su confronti che utilizza un processo di risoluzione ricorsivo, sfruttando la tecnica del Divide et Impera, che consiste nella suddivisione del problema in sottoproblemi della stessa natura di dimensione via via più piccola.
(1) Se la sequenza da ordinare ha lunghezza 0 o 1, o è ordinata, nessuna operazione. Altrimenti:
(2) La sequenza viene divisa in due metà 
(3) Ognuna di queste sottosequenze viene ordinata, applicando ricorsivamente l&#39;algoritmo
(4) Le due sottosequenze ordinate vengono fuse </answer_text><num_votes>0</num_votes></answer><answer id="A3289"><answer_text>Se la sequenza da ordinare ha lunghezza 0 oppure 1, è già ordinata. Altrimenti:
La sequenza viene divisa (divide) in due metà (se la sequenza contiene un numero dispari di elementi, viene divisa in due sottosequenze di cui la prima ha un elemento in più della seconda)
Ognuna di queste sottosequenze viene ordinata, applicando ricorsivamente l&#39;algoritmo(impera)
Le due sottosequenze ordinate vengono fuse (combina). Per fare questo, si estrae ripetutamente il minimo delle due sottosequenze e lo si pone nella sequenza in uscita, che risulterà ordinata</answer_text><num_votes>3</num_votes></answer><answer id="A3309"><answer_text>I tre passi che caratterizzano l&#39;algoritmo MERGE SORT sono: Divide (dove la sequenza di elementi è divisa in due sotto sequenze di n/2 elementi); Impera (che non è altro che l&#39;ordinazione delle sotto sequenze in modo ricorsivo usando Merge Sort) e Combina (la fusione delle due sotto sequenze ordinate)</answer_text><num_votes>0</num_votes></answer></question><question id="Q3317"><question_text>In che caso è meglio usare una funzione ricorsiva rispetto ad una non ricorsiva?</question_text><answer id="A3324"><answer_text>É meglio utilizzare una funzione ricorsiva nel caso in cui un problema si possa suddividere in sottoproblemi risolvibili mediante una funzione. 
Un esempio è un programma che stampi la sequenza di numeri di Fibonacci poichè (eccetto caso n=0,1) il programma utilizzerà la funzione per n-1 e n-2  per n volte definite dall&#39;utente per poi stamparne i risultati.</answer_text><num_votes>0</num_votes></answer><answer id="A3420"><answer_text>La ricorsione ha un vantaggio fondamentale: permette di scrivere poche linee di codice per risolvere un problema anche molto complesso. Tuttavia, essa ha anche un enorme svantaggio poichè la ricorsione occupa lo stack per un numero di istanze pari alle chiamate della funzione che è necessario effettuare per risolvere il problema.
Pertanto, se le prestazioni sono obiettivo principale del programma e non si dispone di sufficiente memoria, è meglio utilizzare funzioni non ricorsive.</answer_text><num_votes>3</num_votes></answer><answer id="A3362"><answer_text>La ricorsione è uno strumento concettuale presente in molti campi a partire dalla matematica ai linguaggi di programmazione. E&#39; un utile ed elegante strumento realizzativo per la formulazione di algoritmi. </answer_text><num_votes>0</num_votes></answer><answer id="A3300"><answer_text>Una funzione ricorsiva si usa quando si riesce a dividere un problema in un caso base, di cui si conosce a priori la soluzione, e in un caso induttivo risolvibile attraverso un procedimento che prevede di richiamare, direttamente o indirettamente, la stessa funzione iniziale per risolvere dei problemi più semplici rispetto al primo.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3350"><question_text>che ruolo ha il sistema operativo nella gestione file mediante il linguaggio c/c++?</question_text><answer id="A3385"><answer_text>Qualsiasi linguaggio di programmazione deve comunicare con il SO per poter accedere ai file, anche nel linguaggio C/C++ i file vengono gestiti direttamente dal sistema operativo (SO). In particolare in C/C++ esiste una libreria ad-hoc che gestisce la comunicazione con il SO. In questo modo è possibile accedere alle periferiche di ingresso ed uscita e trattarle come files.</answer_text><num_votes>1</num_votes></answer><answer id="A3399"><answer_text>Il ruolo del sistema operativo nella gestione file mediante il linguaggio c/c++ è quello di associare in modo univoco un nome e una posizione sul filesystem ad un file. Non si può interagire direttamente con un file ma per poterlo fare attraverso un&#39;applicazione c/c++, serve che il sistema operativo associ a quel file un identificatore, che altro non è che una variabile o un puntatore di un tipo particolare che farà da tramite all&#39;accesso del file.</answer_text><num_votes>0</num_votes></answer><answer id="A3306"><answer_text>Il sistema operativo(SO) gestisce una struttura dati che memorizza i file attualmente utilizzati dai programmi in esecuzione.Quando un programma vuole aprire un file (fopen), apre uno stream indicando al SO la sua intenzione di aprire un file. Il SO quindi:
-crea un nuovo elemento nel vettore dei file aperti contente tutti i dati necessari alla gestione del file;
-restituisce alla variabile puntatore di tipo FILE l&#39;indirizzo della struttura che descrive il file in questione.
I campi contenuti nella struttura sono: modalità di utilizzo, posizione corrente sul file, indicatore di errore e EOF</answer_text><num_votes>1</num_votes></answer></question><question id="Q3294"><question_text>Cosa sono gli streams ed i files in C++?
Che caratteristiche/proprietà hanno?
Cosa consentono di fare?</question_text><answer id="A3333"><answer_text>con stream si intende il flusso con cui avviene la trasmissione di dati, mentre con file si intende la memorizzazione dei dati sulla memoria di massa, infatti gli stream consentono di leggere,scrivere e accedere ai file , vi sino due tipi di file, &#34;normali&#34; e binari, i primi salvano semplicemente un&#39;immagine dei dai ,mentre quelli binari li codificano.</answer_text><num_votes>0</num_votes></answer><answer id="A3298"><answer_text>Il C/C++ permette di gestire gli input/output delle varie periferiche indipendentemente dal tipo di periferica; tutto ciò viene reso possibile grazie ad un livello di astrazione reso possibile dal linguaggio di programmazione stesso; tale astrazione viene chiamata stream (flusso) e rappresenta il canale attraverso cui passano le informazioni, mentre la periferica viene chiamata file; i flussi (di tipo binario o testo) si comportano nella stessa maniera e quindi vengono gestiti tramite le stesse funzioni, mentre invece non tutti i files sono simili a causa della diversità delle periferiche.</answer_text><num_votes>2</num_votes></answer><answer id="A3313"><answer_text>Gli stream servono a mettere in contatto (creare un ponte) tra files. I files sono un insieme di dati organizzati secondo una struttura (definizione generale), caratterizzati attraverso un nome e una posizione in memoria (per accedere a un file ho bisogno di queste due informazioni).
Attraverso un stream è possibile APRIRE, LEGGERE/SCRIVERE e CHIUDERE un file (è bene ricordare che un file va sempre chiuso in questo modo vado a svuotare il buffer dei dati che avevo in memoria e li scrivo nel file).</answer_text><num_votes>0</num_votes></answer></question><question id="Q3408"><question_text>Qual&#39;è l&#39;utilizzo del flag EOF nella gestione degli errori all&#39;interno del tipo strutturato FILE?</question_text><answer id="A3373"><answer_text>La funzione int feof( FILE *f); restituisce un valore diverso da 0 se la posizione corrente del file ha raggiunto la fine del file. Restituisce 0 se non siamo alla fine del file.</answer_text><num_votes>0</num_votes></answer><answer id="A3394"><answer_text>All&#39;interno del tipo strutturato FILE il flag EOF (end-of-file) ha la funzione di restituire una variabile TRUE quando si è arrivati in fondo al FILE.
Ad esempio nella lettura/scrittura di caratteri e stringhe con le funzioni putchar(), fputc() , *fputs quando si è raggiunta la fine del FILE la funzione ce lo segnalerà restituendo la variabile EOF TRUE. E&#39; quindi possibile utilizzare il flag come condizione di uscita da un ciclo while il quale scorrerà il FILE dall&#39;inizio alla fine.  
</answer_text><num_votes>2</num_votes></answer><answer id="A3403"><answer_text>All&#39;interno del tipo file viene strutturato un campo &#34;End Of File&#34;, che assume valore &#34;TRUE&#34; quando viene raggiunta la fine.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3381"><question_text>Quali sono le operazioni per la gestione di una variabile di tipo FILE? elencali e descrivili.</question_text><answer id="A3293"><answer_text>il flusso ifstream derivata dalla classe istream è utilizzata per gestire la lettura da file (solo lettura)
il flusso ofstream derivata dalla classe ostream è utilizzata per gestire la scrittura su file (solo scrittura)
il flusso fstream derivata da iostream è utilizzata per gestire sia la lettura che la scrittura da file (lettura+scrittura contemporaneamente)</answer_text><num_votes>0</num_votes></answer><answer id="A3318"><answer_text>Instaurazione di un&#39;associazione tra flusso e file di una periferica ed è definito così:FILE *fopen (nomefile, modalità) da indirizzo della struttura di tipo FILE.Modalità:?r? lettura modalità testo inizio file,?w? scrittura modalità testo inizio file ,?a? scrittura modalità testo fine file,?rb? lettura modalità binario inizio file, ?wb? scrittura modalità binarioinizio file ,?ab? scrittura modalità binario fine file.Terminazione dell&#39;associazione tra flusso e file di una periferica e vengono scritti dati memorizzati nel buffer nel file indirizzato da fp:
int fclose (FILE *fp).</answer_text><num_votes>1</num_votes></answer><answer id="A3375"><answer_text>Per accedere ad un File è necessario predisporre una variabile che lo rappresenta, il puntatore a file  (FILE * fp).
Apertura : FILE *fopen(nomefile, modalità); dove la modalita puo essere in letture &#34;r&#34;, in scrittura &#34;w&#34; e così via.
CHIUSURA : int fclose(FILE *fp); resituisce 0 se tutto è andato bene, altrimenti EOF.
LETTURA/SCRITTURA :
int getc (FILE *fp);
int putc (int c, FILE *fp);
int fgetc (FILE *fp);
int fputc (int c, FILE *fp);
CANCELLA: int remove (nomefile)
RINOMINA : int rename (vecchionome, nuovonome)
</answer_text><num_votes>1</num_votes></answer></question><question id="Q3357"><question_text>Quali sono i flussi in C e quali sono le loro caratteristiche?</question_text><answer id="A3400"><answer_text>Ci sono tre modi per utilizzare i flussi o (streams) che sono:
-i FLUSSI DI COMMUNICAZIONE per creare o aprire un FILE, che può essere di tipo BINARIO cioè una sequenza di byte o di tipo TESTO cioè una sequenza di caratteri;
-programmare in C permette di associare un FILE ad un flusso solo se viene dichiarato (#include stdio.h) e permette cosi lo scambio di dati tra il programma e il file;
-il programma utilizza anche i FLUSSI STANDARD, che vengono eseguiti in modo autonomo e sono: (stdout, stderr) per il video del terminale e (stdin) per la tastiera del terminale.</answer_text><num_votes>3</num_votes></answer><answer id="A3390"><answer_text>Esistono tre flussi standard che si aprono automaticamente con l&#39;esecuzione del programma: stdin,stdout e stderr. Questi flussi sono associati ai file che rappresentano il video o la tastiera. Le funzioni di ingresso e di uscita sono utilizzate da printf e scanf.</answer_text><num_votes>0</num_votes></answer><answer id="A3315"><answer_text>Il linguaggio C prevede che ogni programma disponga, in modo predefinito, di tre flussi di file già costituiti: standard input, standard output e standard error. Il primo è predisposto per la lettura e di norma è collegato alla tastiera; il secondo e il terzo consentono solo la scrittura e sono collegati normalmente allo schermo.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3400"><question_text>Cosa istanzia il sistema operativo quando viene istanziato un file? E cosa fa&#39; lo stesso sistema operativo quando invece chiudiamo il file?</question_text><answer id="A3360"><answer_text>Quando viene istanziato un file (FILE *f;) il sistema operativo crea uno &#34;stream&#34;, o flusso, associato al file.
Questo flusso ci permette appunto di leggere o scrivere sul file. I flussi sono utilizzati soprattutto per comunicare con le periferiche come l&#39;output a video e la tastiera.
Quando chiudiamo il file il sistema operativo &#34;dissocia&#34; lo stream dal file. Un file viene chiuso in maniera automatica anche quando il programma termina l&#39;esecuzione. Durante la chiusura i dati vengono scritti sul file. Se il programma si arresta inaspettatamente è possibile che alcuni dati vadano persi.</answer_text><num_votes>0</num_votes></answer><answer id="A3359"><answer_text>Quando viene istanziato un file (FILE *f;) il sistema operativo crea uno &#34;stream&#34;, o flusso, associato al file.
Questo flusso ci permette appunto di leggere o scrivere sul file. I flussi sono utilizzati soprattutto per comunicare con le periferiche come l&#39;output a video e la tastiera.
Quando chiudiamo il file il sistema operativo &#34;dissocia&#34; lo stream dal file. Un file viene chiuso in maniera automatica anche quando il programma termina l&#39;esecuzione. Durante la chiusura i dati vengono scritti sul file. Se il programma si arresta inaspettatamente è possibile che alcuni dati vadano persi.</answer_text><num_votes>0</num_votes></answer><answer id="A3304"><answer_text>Il sistema operativo gestisce tramite la tabella dei file aperti la variabile che punta ad un File; oltre ai tre flussi standard, quando viene istanziato un File, il sistema operativo instaura un&#39;associazione tra flusso e file di una periferica; nello stesso modo quando un File viene chiuso, si termina l&#39;associazione tra flusso e file di una periferica.</answer_text><num_votes>1</num_votes></answer><answer id="A3358"><answer_text>Quando viene istanziato un file (FILE *f;) il sistema operativo crea uno &#34;stream&#34;, o flusso, associato al file.
Questo flusso ci permette appunto di leggere o scrivere sul file. I flussi sono utilizzati soprattutto per comunicare con le periferiche come l&#39;output a video e la tastiera.
Quando chiudiamo il file il sistema operativo &#34;dissocia&#34; lo stream dal file. Un file viene chiuso in maniera automatica anche quando il programma termina l&#39;esecuzione. Durante la chiusura i dati vengono scritti sul file. Se il programma si arresta inaspettatamente è possibile che alcuni dati vadano persi.</answer_text><num_votes>2</num_votes></answer><answer id="A3321"><answer_text>Ritengo che la domanda non sia molto chiara e mal posta.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3308"><question_text>Qual è la differenza tra una ricorsione di tipo diretto e una di tipo indiretto?</question_text><answer id="A3299"><answer_text>Si ha una ricorsione diretta quando un sottoprogramma P chiama, durante la sua esecuzione, se stesso.
Si ha una ricorsione indiretta quando un sottoprogramma P chiama, durante la sua esecuzione, un sottoprogramma Q che a sua volta chiama un terzo sottoprogramma R. Successivamente R chiama nuovamente P.</answer_text><num_votes>2</num_votes></answer><answer id="A3378"><answer_text>Si parla di ricorsione indiretta quando nell&#39;algoritmo una funzione ne richiama un&#39;altra che a sua volta richiama la prima, altrimenti si parla di ricorsione diretta.</answer_text><num_votes>0</num_votes></answer><answer id="A3285"><answer_text>Nella ricorsione di tipo diretto una funzione richiama se stessa (ad esempio la funzione P richiama P)
Mentre nella ricorsione di tipo indiretto una funzione richiama un altra funzione che a sua volta richiama la prima (ad esempio la funzione P richiama Q che richiama P)</answer_text><num_votes>0</num_votes></answer></question><question id="Q3297"><question_text>Quali sono le principali operazioni usabili su un tipo FILE?</question_text><answer id="A3395"><answer_text>Le funzioni base per i tipo FILE si trovano nella libreria stdio.h e sono fopen() per aprire un file, fclose() per chiuderlo, fscanf() e fprintf() per scrivere o leggere un file, fread() o fwrite() per la lettura o la scrittura dei dati di un file in blocco e alcune altre tra cui fseek() o ftell(). 
In generale i file ,proprio come i flussi, posso essere formati da testo (leggibili poi tramite blocco note se nel nome mettiamo .txt come estensione) oppure da numeri binari (che impediscono la lettura al di fuori del programma).</answer_text><num_votes>0</num_votes></answer><answer id="A3296"><answer_text>Innanzitutto se un file esiste già è possibile aprirlo (fopen) e successivamente chiuderlo (fclose); le principali modalità sono quelle di lettura (fopen &#34;example.txt&#34;, rt) e di scrittura (fopen &#34;example2.txt&#34;, w). Queste sono possibili anche in versione binaria, cambiando leggermente il codice. Tuttavia con i comandi feof, fprintf, fscanf, fputs, fgets, fputc, fgetc è possibile utilizzare un file .txt in qualsiasi modo previsto da C/C++. </answer_text><num_votes>0</num_votes></answer><answer id="A3384"><answer_text>Le operazioni principali usabili su un tipo FILE sono:
Operazioni di gestione dei file:
apertura &#34;fopen()&#34;, chiusura &#34;fclose()&#34;, cancellazione &#34;remove()&#34; e ridenominazione &#34;rename()&#34; di un file;
Operazioni di lettura/scrittura:
formattata &#34;fprintf() e fscanf()&#34;, di caratteri &#34;fgetc() e fputc()&#34; e di file binari &#34;fread() e fwrite()&#34;;
Operazioni di gestione degli errori:
&#34;ferror()&#34;controlla se è stato commesso un errore nella precedente operazione di lettura o scrittura,
&#34;feof()&#34;controlla se è stata raggiunta la fine del file nella precedente operazione di lettura.</answer_text><num_votes>4</num_votes></answer></question><question id="Q3360"><question_text>Aprendo dei file e dimenticando di chiuderli, cosa succede quando il programma termina (due casi)?</question_text><answer id="A3391"><answer_text>Alla fine di una sessione di scrittura o lettura ad un file è necessario chiudere il file in modo tale che il suo contenuto venga salvato permanentemente nella memoria di massa. Questa operazione viene eseguita tramite la funzione fclose(), che può restituire due risultati distinti: se l&#39;operazione di chiusura è stata eseguita correttamente restituirà il valore 0, se invece la chiusura non è andata a buon fine ritornerà la costante EOF.</answer_text><num_votes>1</num_votes></answer><answer id="A3377"><answer_text>Quando si dimentica di usare la chiusura di un file (fclose), possono succedere 2 casi:
- perdita dei dati(rimasti nel buffer);
- perdita di files.</answer_text><num_votes>1</num_votes></answer><answer id="A3323"><answer_text>Nel momento in cui un programma termina la propria esecuzione improvvisamente, ovvero andando in crash, i file rimasti aperti possono non aver inciso nella memoria il loro contenuto e quindi si possono perdere dei dati. D&#39;altra parte se le modifiche erano state salvate precedentemente non viene perso alcun dato.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3378"><question_text>Cosa si intende per accesso random? Per cosa si distingue da quello sequenziale?</question_text><answer id="A3423"><answer_text>Le periferiche fisiche lavorano utilizzando file ad accesso random oppure sequenziale. Con i file ad accesso random è possibile al momento di apertura del file (open) accedere in una determinata posizione con un identificatore di posizione (puntatore). Con file ad accesso sequenziale questo non è possibile quindi per raggiungere una determinata posizione occorre scorrere lungo il file.</answer_text><num_votes>0</num_votes></answer><answer id="A3282"><answer_text>Con accesso random si intende la lettura o l&#39;utilizzo di una variabile in una posizione casuale. La differenza con l&#39;accesso sequenziale è che in quest&#39;ultimo l&#39;accesso alle variabili avverrà in ordine, non in modo casuale.</answer_text><num_votes>0</num_votes></answer><answer id="A3280"><answer_text>Con accesso casuale (accesso random) si indica la caratteristica di poter accedere ad un elemento arbitrario di una sequenza in tempo costante, indipendente dalla dimensione della sequenza stessa e dalla posizione dell&#39;elemento in essa. L&#39;elemento è arbitrario nel senso che la sua posizione non è prevedibile, motivo per il quale si usa il termine &#34;casuale&#34;. Il concetto opposto è quello di accesso sequenziale, in cui l&#39;accesso ad un elemento richiede più o meno tempo a seconda della sua posizione.</answer_text><num_votes>1</num_votes></answer><answer id="A3355"><answer_text>Premesso che la domanda non è pertinente all&#39;argomento, con accesso casuale si indica la caratteristica di poter accedere ad un elemento arbitrario di una sequenza in tempo costante e indipendente dalla dimensione della sequenza stessa. Un esempio di struttura che consente l&#39;accesso random è l&#39;array. Il concetto opposto è quello di accesso sequenziale, in cui l&#39;accesso ad un elemento richiede più o meno tempo a seconda della sua posizione. Un esempio di struttura che consente l&#39;accesso sequenziale sono le liste concatenate.</answer_text><num_votes>0</num_votes></answer><answer id="A3279"><answer_text>Con accesso casuale (accesso random) si indica la caratteristica di poter accedere ad un elemento arbitrario di una sequenza in tempo costante, indipendente dalla dimensione della sequenza stessa e dalla posizione dell&#39;elemento in essa. L&#39;elemento è arbitrario nel senso che la sua posizione non è prevedibile, motivo per il quale si usa il termine &#34;casuale&#34;. Il concetto opposto è quello di accesso sequenziale, in cui l&#39;accesso ad un elemento richiede più o meno tempo a seconda della sua posizione.</answer_text><num_votes>0</num_votes></answer><answer id="A3330"><answer_text>------------2 MODALITA&#39; DI ACCESSO AD UN FILE-------------
1)RANDOM: Permette di accedere in tempo costante ad una qualsiasi parte del file indipendentemente dalla dimensione di quest&#39;ultimo;
2)SEQUENZIALE: Il tempo richiesto per accedere ad una informazione di un file viene condizionato dalla sua posizione all&#39;interno dello stesso.
N.B.
-In un file ad accesso casuale è quindi possibile leggere e scrivere i dati in qualsiasi ordine.
-Nei file sequenziali è sempre necessario partire dall?inizio del file e procedere in ordine con la scansione dei dati con conseguente perdita di tempo.

</answer_text><num_votes>1</num_votes></answer></question><question id="Q3373"><question_text>Nell&#39;ambito della gestione dei file cosa fanno e come si usano le funzione remove e rename?</question_text><answer id="A3367"><answer_text>La funzione remove permette di eliminare il file il cui nome viene indicato tra parentesi:
remove (&#34;file.txt&#34;);
Rename permette invece di cambiare nome al file:
rename (&#34;VecchioNome.txt&#34;,&#34;NuovoNome.txt&#34;);
Bisogna tenere a mente che se il file è aperto o non è possibile eliminarlo, l&#39;effetto dell&#39;esecuzione dipende da come si implementa il programma. E&#39; necessario quindi utilizzare delle funzioni di controllo al fine di verificare se l&#39;operazione è andata a buon fine (la funzione restituisce 0 in caso di successo o 1 in caso di errore).</answer_text><num_votes>2</num_votes></answer><answer id="A3319"><answer_text>La funzione remove viene utilizzata quando si vuole cancellare un determinato file. Quindi nell&#39;implementazione del codice, alla funzione va passato il nome del FILE (es. int rename( nome_file))che si vuole cancellare. La funzione rename invece serve per poter rinominare un determinato file. Alla funzione vanno passati il nome originale del file e il nome nuovo con cui lo si vuole modificare(es. int rename( nome_originale, nuovo_nome)). Entrambe le funzioni restituiscono 0 se le operazioni avvengono con successo, altrimenti restituiscono un valore diverso da 0. </answer_text><num_votes>0</num_votes></answer><answer id="A3388"><answer_text>La funzione 
remove(&#34;nomedelfile.formato&#34;); 
serve per eliminare un file, mentre
rename(&#34;nomeprecedente.formato&#34;, &#34;nuovonome.formato&#34;); 
serve per rinominarlo. 
Se ad un file viene assegnato come nuovo nome quello di un file già esistente quest&#39;ultimo viene solitamente sovrascritto.
Entrambe le funzioni restituiscono un feedback: 0 se non ci sono errori, oppure -1 aggiornando la finestra Elenco errori con il codice dell&#39;errore verificatosi. 
Per usare le due funzioni è necessario includere nel programma la libreria di standard input e output:
#include&#60;stdio.h&#62;</answer_text><num_votes>0</num_votes></answer></question><question id="Q3321"><question_text>che differenza c&#39;è tra un file normale e un file binario?</question_text><answer id="A3305"><answer_text>Un file normale o meglio di testo è un file che contiene solo caratteri di scrittura semplici, che compongono un testo leggibile direttamente dagli utenti senza bisogno di installare programmi appositi.
Il termine si usa in contrapposizione a file binario, che è invece un file contenente dati numerici binari non direttamente leggibili dall&#39;utente. In realtà, dal punto di vista delle macchine, non c&#39;è distinzione tra i due tipi, poiché tutti i file non sono altro che sequenze di byte. La differenza sta solo in ciò che i byte rappresentano e come vengono interpretati dai file.</answer_text><num_votes>1</num_votes></answer><answer id="A3357"><answer_text>Un file normale in cui le informazioni sono rappresentate come flussi di caratteri. In particolare non è però garantita la corrispondenza uno ad uno tra input e output. Infatti alcuni caratteri possono essere tradotti.
Invece un file binario non è altro che un flusso di bytes uguali all&#39;input. Non vi è traduzione dell&#39;informazione quindi la corrispondenza è garantita. Un file binario è però difficile da consultare, in quanto i bytes spesso risultano protetti.</answer_text><num_votes>0</num_votes></answer><answer id="A3361"><answer_text>Un file binario è rappresentato da una sequenza di bytes mentre un file di tipo testo (normale) è caratterizzato dall&#39;essere una sequenza di caratteri.
Nel secondo caso occorre un processo di codifica/decodifica: questo comporta che la corrispondenza tra caratteri scritti/letti e quelli realmente memorizzati nella periferica non sia garantita. Nel caso di un file binario, invece, la corrispondenza è garantita, in quanto non avviene alcuna traduzione dell&#39;informazione.
 </answer_text><num_votes>1</num_votes></answer><answer id="A3424"><answer_text>L&#39;unica differenza tra file normale e binario e&#39; il modo della sua codifica</answer_text><num_votes>0</num_votes></answer></question><question id="Q3295"><question_text>In che modo utilizza la memoria, una funzione che lavora in modalità ricorsiva ?</question_text><answer id="A3314"><answer_text>una funzione ricorsiva gestisce la memoria in maniera dinamica, e più propriamente &#34;costruendo&#34; una pila di dati: ovvero la funzione, partendo da un caso complesso, calcola un primo risultato parziale e lo parcheggia nella memoria per risolvere il problema che ora sarà un pò più semplice... e cosi via fino al caso base di cui la funzione riesce a trovare la soluzione ed utilizzarla per risolvere le &#34;soluzioni parziali&#34; fino ad allora ottenute. </answer_text><num_votes>3</num_votes></answer><answer id="A3383"><answer_text>Una funzione ricorsiva crea una nuovo zona di memoria ad esempio ogni volta che la funzione richiama se stessa </answer_text><num_votes>0</num_votes></answer></question><question id="Q3286"><question_text>l&#39;accesso in modalità binaria porta dei vantaggi o svantaggi in confronto alla modalità testo? come mai?</question_text><answer id="A3414"><answer_text>l &#39; accesso in modalità binaria porta dei vantaggi in confronto alla modalità testo in quanto il file binario ha :Pros Minore Overhead (minore dimensione) , Facilità dell&#39;accesso random e delle modifiche, Cons Portabilità tra calcolatore, non ha text editor 
</answer_text><num_votes>1</num_votes></answer><answer id="A3316"><answer_text>L&#39;accesso in modalità binaria porta dei vantaggi rispetto alla modalità di tipo testo per quanto riguarda il numero di byte letti/scritti che sono gli stessi memorizzati nella/dalla periferica. La corrispondenza testo, invece, tra caratteri scritti/letti  e quelli memorizzati nella periferica non è garantita.</answer_text><num_votes>1</num_votes></answer></question></lecture><lecture id="L25" title="Algoritmi, il sistema operativo (E1.1), l’ambiente di sviluppo DEVC++ (E1.1), dichiarazione, inizializzazione e utilizzo delle variabili (E1.2)" date="2013-09-16"><question id="Q2047"><question_text>Un computer può avere più microprocessori? e se si come potrebbe essere gestita l&#39;esecuzione di un programma?</question_text><answer id="A3440"><answer_text>Un approccio per incrementare le performance di un computer consiste nell&#39;utilizzo di più processori, come nelle architetture SMP utilizzate in server e workstation a partire dagli anni &#39;90. I processori multi-core consentono potenzialmente una moltiplicazione delle performance in base al numero dei core a patto che i programmi siano &#34;scritti&#34; per sfruttare queste potenzialità: architetture multicore richiedono un lavoro di ottimizzazione da parte dei programmatori. certi compilatori c prevedono già il supporto per utilizzo di processori multicore.</answer_text><num_votes>0</num_votes></answer><answer id="A1975"><answer_text>Si questo è attualmente possibile, l&#39;esecuzione dei programmi avviene in parallelo così da aumentare le performance del computer. E&#39; importante inoltre che un microprocessore informi gli altri dello spazio di memoria che sta andando ad utilizzare,per evitare che un altro sovrascriva dati nella stessa cella.Questo quando la memoria dei microprocessori è condivisa,ci sono anche architetture a memoria distribuita dove ogni microprocessore è dotato di un banco privato di memoria. </answer_text><num_votes>0</num_votes></answer><answer id="A1872"><answer_text>Si, un computer può avere 2 o più processori che operano in parallelo. L’esecuzione di un programma su di un sistema di elaborazione a più microprocessori utilizza il calcolo parallelo che rendere l’esecuzione di un programma più rapida, perché viene svolta da più elementi in contemporanea. In pratica, è spesso difficile suddividere un programma in modo che le diverse unità di elaborazione possano svolgere ciascuna la propria parte senza interferire con l’altra.</answer_text><num_votes>0</num_votes></answer><answer id="A1920"><answer_text>In un computer possono essere presenti più microprocessori. Per esempio ci sono 2 CPU separate, ma saldate sullo stesso pezzo di silicio, che funzionano separatamente.
Sicuramente condividono il bus dati e dovranno girare alla stessa frequenza.
L’esecuzione di un programma viene divisa su di essi. Uno esegue certe operazioni mentre l&#39;altro altre operazioni. Infine i dati convergono tutti sul bus dati. 
</answer_text><num_votes>3</num_votes></answer></question><question id="Q2038"><question_text>Quali valori posso attribuire ad una variabile di tipo char?</question_text><answer id="A1825"><answer_text>Ad una variabile di tipo carattere posso atteibuire valori non numerici, ma valori rappresentanti caratteri di tipo ASCII, identificata con il tipo &#60;char&#62;.</answer_text><num_votes>0</num_votes></answer><answer id="A1989"><answer_text>Alla variabile char posso attribuire qualsiasi carattere definito dallo standar ASCII. Posso dunque attribuirle una lettera maiuscola o minuscola.
Quindi il tipo char identifica un carattere e sono necessari 8 bit per la sua rappresentazione.</answer_text><num_votes>1</num_votes></answer><answer id="A1956"><answer_text>ad una variabile char è possibile attribuibile un carattere alfanumerico maiuscolo o minuscolo, un simbolo o qualsiasi inserimento da tastiera anche non visibile (ad esempio uno spazio).</answer_text><num_votes>4</num_votes></answer></question><question id="Q2101"><question_text>Cosa accade a una variabile, se ad essa viene assegnato un numero troppo grande (numero di bits maggiore del numero di bits che posso memorizzare), mi viene segnalato un errore di overflow oppure il programma continua assegnando il valore massimo che la variabile può contenere?</question_text><answer id="A2023"><answer_text>Il programma continua assegnando alla variabile il numero massimo di bits che quel tipo di variabile può contenere, eliminando i bits in più; ad esempio se una variabile potesse contenere solo 4 bits, assegnando il valore binario 10010, ciò che verrà memorizzato nella variabile sarà 0010, senza riportare alcun errore</answer_text><num_votes>0</num_votes></answer><answer id="A2005"><answer_text>Se ad una variabile viene assegnato un valore troppo grande, il programma segnala nella parte riservata ai messaggi (in basso) l&#39;errore riguardante la variabile digitata, ma il programma viene comunque eseguito con un valore che non è quello desiderato. Infatti se si va fuori dal range di definizione, il risultato che compare segue l&#39;aritmetica in complemento a 2, che una volta superato il valore più alto che è possibile memorizzare, fa riparte il conteggio da quello più basso.</answer_text><num_votes>3</num_votes></answer><answer id="A1883"><answer_text>Dichiarando una variabile float od int, il compilatore C/C++ alloca automaticamente uno spazio di 4 bytes per memorizzare il suo valore. 
Questo significa, che per una variabile di tipo int, si può assegnare un range di valori che va da 0 a 4294967295, fenomeno analogo per la variabile float.
Quello che accade assegnando un valore troppo grande, è un errore  sia in fase di compilazione, che in fase di esecuzione  (nel caso voglia assegnare il valore da tastiera in esecuzione).</answer_text><num_votes>0</num_votes></answer></question><question id="Q2094"><question_text>Le variabili: cosa succede se non si dichiara una variabile?</question_text><answer id="A1948"><answer_text>Se in un programma scritto in Dec c++ scrivo un programma in cui richiamo una variabile senza averla dichiarata, il compilatore in fase di compilazione mi darà errore riportandomi:&#34;undeclared (first use in this function)&#34;. In particolare dichiarare una variabile serve al compilatore per conoscere la tipologia del dato e per sapere quanto spazio andare a riservare per la variabile (char 8bit, int 16 bit, float 32 bit). </answer_text><num_votes>3</num_votes></answer><answer id="A1837"><answer_text>L&#39;esecuzione non sarà possibile. Dichiarando una variabile si riserva una certa quantità di memoria dove poi verranno inseriti i dati, quindi se non si dichiara non ci sarà nessun spazio disponibile per inserire i dati e il compilatore ci indicherà che c&#39;è un errore.</answer_text><num_votes>2</num_votes></answer><answer id="A1986"><answer_text>Se non si dichiara una variabile non si possono salvare i risultati delle operazioni che si effettuano</answer_text><num_votes>0</num_votes></answer></question><question id="Q2097"><question_text>che differenza c&#39;è tra &#34;macchina fisica&#34; e &#34;macchina virtuale&#34;?</question_text><answer id="A1939"><answer_text>La macchina fisica non è altro che l&#39;insieme di componenti elettronici necessari per il funzionamento del calcolatore, mentre la macchina virtuale è un software in grado di simulare il funzionamento della macchina fisica tramite un&#39;interfaccia grafica.</answer_text><num_votes>1</num_votes></answer><answer id="A1797"><answer_text>Ogni utente interagisce con la macchina virtuale e non con la macchina fisica.
Il termine “virtuale” indica che questa macchina non esiste realmente, ma che il software realizza parte delle sue funzioni.
L&#39;insieme delle funzioni di una macchina virtuale descrivono il lavoro che può eseguire.

</answer_text><num_votes>1</num_votes></answer><answer id="A1921"><answer_text>A differenza della macchina fisica, nella macchina virtuale i componenti hardware sono simulati. 
Questo significa che il sistema operativo che sarà installato nella macchina virtuale utilizzerà un hardware non fisico ma simulato dal programma (ad es Virtual Machine) installato nel sistema operativo principale, ovvero installato sulla macchina fisica. Di conseguenza avremo che
in una macchina fisica può essere in esecuzione più di una macchina virtuale.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2032"><question_text>A che cosa serve il registro di stato, il registro dati ed il registro indirizzi in una CPU?</question_text><answer id="A1966"><answer_text>Il registro di stato (State Register) controlla condizioni e anomalie durante il ciclo di esecuzione; utilizzo dei Flag (C,Z,S,V);
Il registro dati (Data Register) contiene il dato prelevato da una cella di memoria oppure il dato che dovrà esservi trasferito;
Il registro indirizzi (Accumulator Register) viene utilizzato per eseguire somme e memorizzare i risultati parziali delle operazioni.
</answer_text><num_votes>0</num_votes></answer><answer id="A1855"><answer_text>Il registro di stato serve a controllare che non insorgano problemi nella CPU durante le operazioni.
Il registro dati contiene una copia delle parole lette/da scrivere in MM; esso serve pertanto a fornire un dato da elaborare alla periferica (operazione di scrittura) o a prelevare un dato messo a disposizione dalla periferica (operazione di lettura).
Il registro indirizzi contiene l&#39;indirizzo della memoria RAM dalla/nella quale il dato deve essere prelevato/inserito.</answer_text><num_votes>1</num_votes></answer><answer id="A1945"><answer_text>Il registro di stato serve a riportare le indicazioni relative al risultato delle varie operazioni; il registro dati, invece, carica il contenuto della cella di memoria (lettura) oppure copia il proprio contenuto sulla cella di memoria (scrittura).
Infine il registro indirizzi contiene le informazioni relative alle varie posizioni delle celle di memoria.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2058"><question_text>Come si presenta il contenuto di una variabile dichiarata non inizializzata?</question_text><answer id="A2006"><answer_text>Il contenuto può essere vario, nel senso che non si è certi di che cosa contenga il registro associato a detta variabile. Infatti è possibile che esso contenga informazioni di tipo alfanumerico (es: 0, -20, 14875269, ecc.). Inoltre, è assolutamente sconsigliato l&#39;uso di una variabile non inizializzata all&#39;interno del programma, in quanto non si conosce il suo contenuto.</answer_text><num_votes>2</num_votes></answer><answer id="A1944"><answer_text>Il contenuto di una variabile non inizializzata è indeterminato, cioè contiene al suo interno quello che è presente al momento dell&#39;allocazione e gli è assegnato dal compilatore.</answer_text><num_votes>1</num_votes></answer><answer id="A1874"><answer_text>Ti rispondo con un esempio pratico, scrivi in C questo programma:

#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;

int main(int argc, char *argv[])
{
  int a;
  printf(&#34;Valore = %a\n&#34;, a);
  system(&#34;PAUSE&#34;);	
  return 0;
}


Compila ed esegui. Come puoi vedere il valore non è stato dichiarato ed il programma mostra a video il contenuto della cella che è occupato dal sistema.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2057"><question_text>quale è il &#34;ruolo&#34; del clock di sistema?</question_text><answer id="A1970"><answer_text>Il clock e l&#39;orologio interno del sistema, è utile per scandire il tempo di qualsiasi operazione del computer. 
In generale sincronizza il funzionamento di tutti i dispositivi dell&#39;operatore. E&#39; comunque sempre il clock che impone una determinata frequenza e quindi velocità alla Cpu (si misura in Hertz).</answer_text><num_votes>0</num_votes></answer><answer id="A1890"><answer_text>Nella macchina di Von Neuman le fasi d&#39;elaborazione si susseguono in modo sincrono rispetto ad un &#34;orologio di sistema&#34; detto clock, che quindi scandisce il lavoro della CPU.
Funzionalmente il clock è un generatore di tensione che produce segnali periodici. L&#39;elettronica della macchina traduce le oscillazione della tensione in commutazioni tra due livelli logici 0 e 1 (il funzionamento del calcolatore è binario). Il numero di commutazioni al secondo è la frequenza del clock (espressa in Hz).</answer_text><num_votes>0</num_votes></answer><answer id="A1980"><answer_text>Il clock di sistema, o circuito di temporizzazione, consente di sincronizzare l’esecuzione di tutte le operazioni eseguite dalla CPU. Tale orologio interno è responsabile di un segnale ad onda quadra caratterizzato da una rapida successione di due livelli di tensione, alto e basso. Poiché maggiore è la frequenza di tale segnale e maggiore è il numero di operazioni che vengono eseguite per unità di tempo, si può affermare che tale frequenza incida in maniera considerevole sulla velocità di un PC.</answer_text><num_votes>2</num_votes></answer><answer id="A1896"><answer_text>Il clock di sistema scandisce il tempo di esecuzione di un&#39;istruzione di un programma. Più alto è la frequenza del clock e più istruzioni potranno essere eseguite in un determinato lasso di tempo.
</answer_text><num_votes>1</num_votes></answer><answer id="A1982"><answer_text>Il ruolo del clock di sistema è quello di scandire i tempi di esecuzione delle varie istruzioni. Questo componente funziona mandando degli impulsi e ogni clock ha una sua frequenza, misurata in Hertz. Un clock con una frequenza più elevata genererà quindi un numero maggiore di impulsi per unità di tempo e di conseguenza saranno eseguite più velocemente le istruzioni. </answer_text><num_votes>0</num_votes></answer></question><question id="Q1984"><question_text>Riguardo all&#39;architettura interna della CPU,specificare le funzioni dell&#39; ALU (unità aritmetico logica) e dell&#39; UC (unità di controllo) e la relazione che intercorre esse.</question_text><answer id="A1958"><answer_text>L&#39;ALU ha la funzione di eseguire operazione aritmetiche e logiche, è una componente fondamentale del CPU assieme al CU che ha il compito di 
coordinare le azioni necessarie per lo svolgimento delle istruzioni. L&#39;unità di controllo riceve dei segnali relativi allo stato della ALU.</answer_text><num_votes>0</num_votes></answer><answer id="A1886"><answer_text>L&#39; UC è l&#39;unità di controllo che coordina tutte le azioni necessarie per l&#39;esecuzione di una o più istruzioni nella CPU; di conseguenza è coinvolta nella gestione
 dell&#39; ALU attraverso azioni dette micro-istruzioni. L&#39; ALU è una tipologia di processore digitale in grado di svolgere operazioni logiche o aritmetiche. 
In sintesi possiamo dire che l&#39; UC gestisce l&#39; ALU che svolge le operazioni.</answer_text><num_votes>2</num_votes></answer></question><question id="Q1961"><question_text>Come si può definire un algoritmo e quali sono le sue proprietà?</question_text><answer id="A2012"><answer_text>Un algoritmo è una sequenza precisa di operazioni, comprensibili da un esecutore e definisce una sequenza finita di passi che portano alla realizzazione di un compito, (in informatica deve essere scritto in un linguaggio di programmazione comprensibile al calcolatore e la sua codifica è detta programma). Le proprietà: correttezza: l&#39;algoritmo deve essere corretto e deve portare alla soluzione del problema; efficienza: l&#39;algoritmo ottiene la risoluzione del problema usando tempo e risorse minimi.</answer_text><num_votes>3</num_votes></answer><answer id="A1897"><answer_text>Un algoritmo è un procedimento che risolve un determinato problema attraverso un numero preciso e finito di operazioni, comprensibili dall&#39;esecutore. Le sue proprietà sono due: correttezza perché l&#39;algoritmo deve pervenire alla soluzione del problema senza saltare nessun passo; ed efficienza perché l&#39;algoritmo deve arrivare al superamento del quesito con il minor numero di operazioni possibili. Ambedue queste proprietà devono coesistere per la corretta riuscita del programma.   </answer_text><num_votes>0</num_votes></answer></question><question id="Q2162"><question_text>Che tipo di valori può contenere una variabile di tipo double rispetto ad una variabile di tipo float?</question_text><answer id="A2007"><answer_text>Sia le variabili di tipo double che le variabili di tipo float possono contenere valori appartenenti all&#39;insieme dei numeri reali. 
Semplicemente l&#39;utilizzo di una variabile di tipo double permette di avere un numero di cifre maggiore dopo la virgola(fino a 15-16 cifre). 
Una variabile di tipo float riserva infatti in memoria 4 byte mentre una di tipo double ne riserva 8.
</answer_text><num_votes>1</num_votes></answer><answer id="A1913"><answer_text>I tipi primitivi float e double rappresentano i numeri in virgola mobile, che rappresentano l&#39;insieme dei numeri reali. La differenza tra i due tipi è il numero di bit riservato per la memorizzazione delle variabili, che si riflette sul range di numeri e sul numero di cifre dopo la virgola che si possono memorizzare; i float usano 32 bit, quindi rappresentano numeri da 10^(-45) a 10^(-38) circa; i double(doppia precisione) usano 64 bit, quindi descrivono i numeri da 10^(-324) a 10^(308) circa.
 </answer_text><num_votes>0</num_votes></answer><answer id="A1901"><answer_text>La variabile di tipo float contiene un numero reale mentre la variabile double contiene anch&#39;essa un numero reale &#34;lungo&#34; con la differenza che la variabile double ha un numero di bit riservatialla rappresentazione dei numeri maggiore di quella della variabile float. Nel specifico la fariabile float ha 32 bit mentre la variabile double ha 64 bit.</answer_text><num_votes>1</num_votes></answer><answer id="A1908"><answer_text>Entrambe sono utilizzate per dichiarare variabili di numeri reali(es. numeri con la virgola). L&#39;unica differenza sta nel fatto che una variabile di tipo double può avere una mantissa(cifre a destra della virgola) più lunga e quindi più precisa rispetto a quella di una variabile dichiarata in tipo float. In altre parole double ha più bit dedicati alla memorizzazione(64 bit) al contrario di float, che ne ha di meno(32 bit).</answer_text><num_votes>2</num_votes></answer></question><question id="Q2039"><question_text>Se devo visualizzare a video una stringa, devo inserire %s o %c nel printf?</question_text><answer id="A1881"><answer_text>Per visualizzare a video una stringa va inserito %s nel printf.</answer_text><num_votes>0</num_votes></answer><answer id="A1861"><answer_text>Per visualizzare a video una stringa bisogna inserire %s all&#39;interno del comando di stampa ottenendo una riga di codice che sarà simile a questa:
printf(&#34;%s&#34;, stringa);
Se avessi inserito %c all&#39;interno del comando di stampa avrei visualizzato a schermo una variabile di tipo char.
printf(&#34;%c&#34;, variabilechar);
In entrambi i casi la stringa, o la variabile di tipo char, devono comunque essere state dichiarate ed inizializzate, altrimenti in fase di compilazione vengono rilevati degli errori.</answer_text><num_votes>4</num_votes></answer><answer id="A1801"><answer_text>La lettera a seguito del % dipende dal tipo di variabile che gli si deve assegnare:
%d per variabili intere
%f per variabili float / double
%e per decimali in notazione esponenziale
%c per variabili di tipo carattere ( char )

 </answer_text><num_votes>0</num_votes></answer><answer id="A1880"><answer_text>Per visualizzare a video una stringa va inserito %s nel printf.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2068"><question_text>Perchè è necessario svuotare il file STDIN quando si deve leggere una variabile di tipo char da tastiera?</question_text><answer id="A2029"><answer_text>Le variabili di un programma sono memorizzati nella memoria primara del calcolatore.
La memoria primaria è molto piccola per cui non si possono memorizzare grandi quantità di dati;
perche una variabile di tipo char viene rappresentato in memoria mediante un byte,conviene 
svuotare il file STDIN quando si deve leggere. </answer_text><num_votes>0</num_votes></answer><answer id="A1946"><answer_text>È necessario svuotare il file STDIN quando si deve leggere una variabile di tipo carattere da tastiera, perché dopo aver eseguito il programma nel inserire i nostri valori da tastiera rimangono memorizzati non solo questi valori ma anche altri caratteri (come INVIO) anche dopo la chiusura
dell&#39;esecuzione, causando un mal funzionamento del programma.
Per esempio se un utente digita il numero 8 e che conferma con INVIO, verrebbe prelevato dal file di input il valore 8 e il valore INVIO.</answer_text><num_votes>1</num_votes></answer><answer id="A1902"><answer_text>Siccome la funzione scanf col %c, attende in input un carattere e prima di inserirlo nella variabile predestinata lo mette nel file std, quando premo invio dopo aver messo il carattere ad esempi &#34;p&#34; il compilatore mette nel file std anche il codice asci del tasto invio considerando anchesso un input, cosi il file std è &#34;sporco&#34;, per far in modo che nel prossimo scanf vada tutto bene, devo pulire il file std con la funzione fflush, cosi l&#39;inserimento del prossimo input potrà avvenire.</answer_text><num_votes>3</num_votes></answer></question><question id="Q1997"><question_text>Che cosa significano i parametri della funzione main: &#34;(int argc, char *argv[])&#34;? </question_text><answer id="A1935"><answer_text>il parametro argc significa &#34;argument count&#34; e contiene il numero di stringhe inserite dall&#39;utente a linea di comando, mentre argv significa &#34;argument vector&#34; ed è il parametro che contiene gli array delle stringhe. Ogni argomento dell&#39;array è un puntatore a carattere. </answer_text><num_votes>0</num_votes></answer><answer id="A1938"><answer_text>Il parametro argc, dichiarato come int (int argc), e argv, dichiarato come array di puntatori a char (char*argv[]) servono per passare al programma i parametri inseriti nella linea di comando (command tail) al momento in cui si richiede al sistema operativo di mandare in esecuzione il programma stesso.
</answer_text><num_votes>2</num_votes></answer></question><question id="Q2146"><question_text>Spiega brevemente le funzioni che svolgono i componenti dell&#39;architettura hardware di un calcolatore.</question_text><answer id="A1923"><answer_text>L&#39;architettura hardware di un calcolatore è composta da: un processore o CPU che svolge l&#39;elaborazione dei programmi, una memoria centrale o RAM utilizzata per memorizzare dati e istruzioni da eseguire,  una memoria di massa utilizzata per memorizzare grandi quantità di dati e programmi in maniera permanente (quindi non volatile come la RAM), periferiche di vario tipo ed infine un bus di sistema che interconnette tutti gli altri componenti permettendo scambio di dati tra di essi.</answer_text><num_votes>1</num_votes></answer><answer id="A1847"><answer_text>La CPU contiene dispositivi elettronici in grado di acquisire, interpretare ed eseguire le istruzioni; la memoria centrale (RAM) è una memoria volatile ed accoglie dati e programmi sui quali opera il calcolatore; la memoria di massa (ROM) memorizza grandi quantità di dati e programmi in maniera persistente, cioè non volatile; le periferiche permettono lo scambio di informazioni tra il calcolatore e l&#39;esterno; il Bus di sistema interconnette gli altri componenti, consentendo lo scambio di dati.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2027"><question_text>Cosa sono e cosa servono i simboli %d %f %c %e %g %s %u %x ?</question_text><answer id="A2020"><answer_text>Questi simboli sono dei caratteri di conversione e la loro funzione è la seguente:
- %d l&#39;argomento è convertito in notazione decimale;
- %f l&#39;argomento contiene un numero decimale;
- %c l&#39;argomento contiene un unico carattere;
- %e l&#39;argomento contiene un numero decimale espresso in notazione scientifica;
- %g l&#39;argomento contiene un numero decimale, il più corto tra %e e %f;
- %s stringa;
- %u l&#39;argomento è convertito in decimale senza segno;
- %x l&#39;argomento è convertito in esadecimal</answer_text><num_votes>0</num_votes></answer><answer id="A1912"><answer_text>Questi sono caratteri di controllo per variabili in ambiente C. %d si utilizza per le variabili di tipo intero con segno, mentre i decimali senza segno sono denotati con %u. %f è usato per variabili di tipo float (reale) e %c per i caratteri. Un insieme di caratteri (stringa) si denota con %s. %e si usa per la notazione esponenziale per argomento di tipo float. il %x è per caratteri esadecimali. il %g è una particolare estensione rispetto al %e. Li troviamo nei comandi printf e scanf.</answer_text><num_votes>2</num_votes></answer><answer id="A1972"><answer_text>il simbolo % (seguito da una lettera),permette di sovrascrivere (e quindi inizializzare) o rendere leggibile il contenuto della cella di memoria relativa alla variabile che abbiamo gia dichiarato.
Nel caso del %d,il calcolatore ci stamperà a video o saremo noi a inserirlo un numero intero,per il %f il numero è reale,per il %c un carattere,il %s è relativo ad una stringa,%e relativo a notazione scientifica,%g relativo o agli esponenziali o ai reali, %x numero esadecimale,%u un integrale.</answer_text><num_votes>0</num_votes></answer><answer id="A2021"><answer_text>Questi simboli sono dei caratteri di conversione e la loro funzione è la seguente:
- %d l&#39;argomento è convertito in notazione decimale;
- %f l&#39;argomento contiene un numero decimale;
- %c l&#39;argomento contiene un unico carattere;
- %e l&#39;argomento contiene un numero decimale espresso in notazione scientifica;
- %g l&#39;argomento contiene un numero decimale, il più corto tra %e e %f;
- %s stringa;
- %u l&#39;argomento è convertito in decimale senza segno;
- %x l&#39;argomento è convertito in esadecimal</answer_text><num_votes>0</num_votes></answer></question><question id="Q2020"><question_text>E&#39; possibile svolgere operazioni tra variabili di tipo diverso, ad esempio una moltiplicazione tra una variabile &#34;int&#34; e una variabile &#34;float&#34;? Perché?</question_text><answer id="A2011"><answer_text>Sì, è possibile effettuare operazioni tra variabili di tipo diverso, a patto che il risultato sia inserito in un contenitore di tipo float (in questo caso). Se il risultato fosse assegnato ad una variabile di tipo intero perderemo tutte le cifre decimali. Un espressione scritta correttamente è del tipo c = (float) a*b  , dove a è una variabile di tipo int e b una di tipo float.</answer_text><num_votes>3</num_votes></answer><answer id="A1790"><answer_text>certo, ad esempio la media viene definita come somma numero int e media numero float; occorre però ricordarsi di definire poi l&#39;operazione nel campo float mettendolo tra parentesi prima dell&#39;operazione. Ad esempio media = (float) somma/x; con x indice degli elementi di cui ottenere la media.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2135"><question_text>Perchè nella progettazione dei calcolatori è stato scelto di utilizzare il sistema binario? Sarebbe possibile progettare calcolatori che funzionano in decimale o in altre basi numeriche?</question_text><answer id="A2031"><answer_text>I moderni elaboratori elettronici verificano la presenza (o meno) di corrente all&#39;interno dei circuiti. L&#39;unità fondamentale con cui le informazioni vengono rappresentate, il bit, assume pertanto soltanto due stati: &#34;1&#34; e &#34;0&#34;. Sarebbe certamente possibile realizzare computer sensibili, ad esempio, all&#39;intensità di corrente, permettendo loro di operare su basi differenti, ma allo stato attuale della tecnologia sarebbe particolarmente complesso assicurare un calcolo affidabile con molti più stati.</answer_text><num_votes>1</num_votes></answer><answer id="A1961"><answer_text>Perchè con un unico tipo di sengnale On/Off si possono scambiare tutte le informazioni che si desiderano. La scrittura aumenta di lunghezza ma l&#39;elaboratore è così in grado di distinguere facilmente segnali diversi. Creare elaboratori con basi numeriche differenti è possibile e già esistono (Trit-Calcolatori Ternari). In base decimale sarebbe complicato realizzare 10 segnali differenti.</answer_text><num_votes>1</num_votes></answer><answer id="A1947"><answer_text>Sono state testate parti del calcolatore progettate in base ternaria (ma anche con basi 4, 8 o 16, come multipli del sistema binario) soprattutto nella progettazione di componenti di memoria o di trasmissione di informazioni.
Tuttavia il sistema binario è ancora la più comune poichè semplifica molto i processi e li rende di conseguenza più veloci; inoltre in alcuni casi non esiste una terza alternativa (es: on/off): per questo determinati componenti saranno sempre basati sul sistema binario.</answer_text><num_votes>2</num_votes></answer><answer id="A1931"><answer_text>Poiché è più semplice interpretare nei circuiti elettrici due sole fasi date dallo 0 e dall&#39; 1 (&#34;non passa corrente 0&#34;, &#34;passa corrente 1&#34;). Si è possibile progettare calcolatori con diversi sistemi numerici, ma ciò renderebbe più difficile la progettazione e il controllo degli errori nel sistema.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2041"><question_text>La funzione fflush(stdin) serve per svuotare il buffer prima di leggere in input un carattere.
Ma quando va effettivamente utilizzata?</question_text><answer id="A1977"><answer_text>fflush(stdin) serve per impedire errori nella lettura degli input da tastiera per le variabili di tipo char. Una scrittura del tipo:
scanf(&#34;%c&#34;,&#38;dato1);
scanf(&#34;%c&#34;,&#38;dato2);
non è funzionale poichè dopo l&#39;inserimento del primo carattere la pressione del tasto &#34;INVIO&#34; sarà interpretata come il secondo input.
Scrivere:
scanf(&#34;%c&#34;,&#38;dato1);
fflush(stdin);
scanf(&#34;%c&#34;,&#38;dato2);
impedisce questo errore pooichè fflush(stdin) eliminerà dal buffer il carattere &#34;INVIO&#34; prima del secondo input</answer_text><num_votes>2</num_votes></answer><answer id="A1943"><answer_text>Dopo l&#39;inserimento di un certo tipo di dato, a differenza delle variabili di tipo int o float, per l&#39;inserimento di un dato successivo di tipo carattere è necessario svuotare prima il buffer di input. infatti, l&#39;operazione di scanf potrebbe essere ripetuta, ma essendoci nel buffer ancora certi tipi di carattere, e quindi si ricorrerebbe in un errore. per far sì che questo non accada, bisogna inserire fflush(stdin) prima di scanf(&#34;%c&#34;,&#38;car) e printf(&#34;car=%c \n&#34;,car).</answer_text><num_votes>0</num_votes></answer><answer id="A2027"><answer_text>La funzione fflush va utilizzata quando, prima di acquisire una variabile carattere, ho letto una variabile di altro tipo. Questo perchè nel buffer di scanf rimangono memorizzati anche altri caratteri (ad esempio i caratteri di invio) che non sono validi per una variabile numerica e ci rimangono finchè non viene inserita una variabile char.</answer_text><num_votes>2</num_votes></answer><answer id="A1851"><answer_text>La funzione fflush(stdin)  va utilizzata dopo una scanf per pulire il buffer di tastiera da ogni carattere rimasto “non voluto”. </answer_text><num_votes>0</num_votes></answer></question><question id="Q2040"><question_text>Cosa sono e a cosa servono i codici ASCII?</question_text><answer id="A2004"><answer_text>Il codice ASCII è un sistema di codifica a 7 bit che viene comunemente usato nei calcolatori. Questo codice permette di determinare una tabella di codici che fanno riferimento a caratteri. I primi 32 (0-31) e il 127 sono caratteri non stampabili perché di controllo. I restanti rappresentano tutti i caratteri stampabili. Sono state proposte anche soluzioni ad 8 bit per permettere di raddoppiare i caratteri però quella ancora più comunemente utilizzata è a 7 bit. Sistema approvato ISO 646.</answer_text><num_votes>4</num_votes></answer><answer id="A1997"><answer_text>Per ASCII si intende un codice standard usato per la codifica dei caratteri. Secondo il codice &#34;extended ASCII&#34; ad ogni carattere viene riservato un byte e corrisponderà, quindi, una sequenza di 8 bit.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2001"><question_text>RAM e ROM sono due tipi di memoria con caratteristiche generali simili, in cosa consistono le differenze?</question_text><answer id="A1992"><answer_text>Le differenze principali sono: la memoria RAM è volatile quindi può essere cancellata o sovrascritta, invece la ROM non può essere modificata o sovrascritta in nessun modo perchè è solo possibile leggere il suo contenuto senza apportare nessuna modifica. Inoltre la ROM è permanente ed è caratterizzata da un tempo d&#39;accesso maggiore rispetto alla RAM, che viene continuamente modificata essendo rapidamente e direttamente accessibile.</answer_text><num_votes>2</num_votes></answer><answer id="A2025"><answer_text>La differenza principale tra una memoria RAM e una memoria di tipo ROM è che la prima è volatile, la seconda permanente. Pertanto il contenuto della Ram verrà perso qundo cessa l&#39;alimentazione del sistema.
Un&#39;altra differenza è il tempo di accesso: mentre nella RAM (Random Access Memory)il tempo di accesso è molto breve e indipendente dall&#39;indirizzo della parola a cui voglio accedere, nelle ROM esso è maggiore. Queste ultime sono inoltre delle memorie ad accesso sequenziale.
</answer_text><num_votes>1</num_votes></answer><answer id="A2014"><answer_text>La RAM è una memoria volatile, nella quale vengono &#34;conservati&#34; i dati in corso di elaborazioni e le istruzioni dei programmi del computer in esecuzione, ma tutto ciò viene perso quando si va a spegnere il calcolatore.
La ROM, invece, è una memoria permanente di sola lettura, che viene scritta una sola volta ed è tipicamente utilizzata per memorizzare dati e programmi che servono al momento dell’accensione del calcolatore.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2003"><question_text>Che cos&#39;è la macchina di &#34;von Neumann&#34;? Quali sono le differenze con una macchina astratta di linguaggio C?</question_text><answer id="A1999"><answer_text>La macchina di von Neumann rappresenta il modo in cui la maggior parte dei calcolatori è organizzata a livello hardware. I suoi elementi principali sono: la CPU, la memoria centrale, la memoria di massa, le periferiche e il bus di sistema.
Una macchina astratta di linguaggio C si basa su quella di von Neumann, ma diversamente da essa possiede uno Standard Input e uno Standard Output. Questi sono suddivisi in celle (variabili), ognuna delle quali contiene un dato immesso dall&#39;utente.</answer_text><num_votes>0</num_votes></answer><answer id="A1822"><answer_text>La macchina di &#34;von Neumann&#34; è un modello hardware che opera in maniera sequenziale.E&#39; formato da varie componenti:il Processore,la Memoria centrale,la Memoria di massa e varie periferiche;sono interconnesse dal Bus di sistema che trasferisce i dati e sincronizzate dal &#34;clock&#34; e dall&#39;unità di controllo.La macchina astratta C rispetta queste caratteristiche su una struttura software.E&#39; composta dall&#39;Unità centrale,dall Memoria centrale,da periferiche standandard I/O e dal Bus di sistema.
</answer_text><num_votes>2</num_votes></answer><answer id="A1983"><answer_text>Per macchina di von Neumann si intende il modello hardware dei moderni calcolatori in cui la CPU,le memorie e le periferiche 
comunicano attraverso un bus di sistema. Le fasi di elaborazione delle istruzioni da parte della CPU sono scandite da un clock e la
CU stabilisce la funzione da svolgere. La macchina lavora in maniera sequenziale. La macchina C è un&#39;astrazione della prima e permette 
di memorizzare ed eseguire programmi in C attraverso l&#39;uso di strutture dati e algoritmi.</answer_text><num_votes>1</num_votes></answer></question><question id="Q1969"><question_text>Per quale motivo bisogna utilizzare il comando fflush(stdin)?
In particolare, cosa succede se viene valorizzata da tastiera una variabile di tipo &#34;char&#34; dopo averne valorizzata una di tipo &#34;int&#34;, senza utilizzare il comando fflush(stdin)?</question_text><answer id="A1793"><answer_text>Quando si inserisce un valore da tastiera e si preme invio, questo viene salvato in un file chimato &#34;stdin&#34;.
Ad esempio se si inserisce prima una variabile di tipo intero (int) e successivamente un carattere (char), quest&#39;ultimo non è possibile inserirlo dato che il valore carattere viene preso dal file &#34;stdin&#34;.
Quindi prima di scrivere il comando &#34;scanf(&#34;%c&#34;, &#38;i);&#34; è necessario svuotare il buffer stdin col comando &#34;fflush(stdin)&#34;.


 </answer_text><num_votes>0</num_votes></answer><answer id="A1811"><answer_text>Il comando fflush(stdin) serve a cancellare ciò che c&#39;è all&#39; interno dell&#39;input buffer.Volendo acquisire da tastiera un valore da associare ad una variabile di tipo intero si digita prima il dato numerico e dopo si preme il tasto invio. Il valore digitato viene inserito nell&#39;indirizzo della variabile mentre nell&#39;input buffer rimane un valore pari al tasto INVIO.Se viene poi valorizzata una varibile di tipo char a questa viene associato INVIO in quanto valore valido per quel tipo di variabile.</answer_text><num_votes>4</num_votes></answer></question><question id="Q2143"><question_text>Cosa significa la stringa: &#34; system(&#34;PAUSE&#34;); &#34;? E&#39; essenziale al fine del funzionamento del programma o può essere omessa?</question_text><answer id="A1974"><answer_text>Il &#34;system(&#34;PAUSE&#34;); &#34; è una direttiva che viene data al compilatore, la quale sospende
l&#39;esecuzione del programma fino a che non viene premuto un tasto.
Senza questa direttiva il programma si chiuderebbe appena eseguita l&#39;ultima istruzione.
Quindi il &#34;system(&#34;PAUSE&#34;);&#34; è essenziale se si vuole che il programma non si chiuda automaticamente a fine processo.</answer_text><num_votes>0</num_votes></answer><answer id="A1957"><answer_text>La stringa &#34;system(&#34;PAUSE&#34;);&#34; è essenziale per un programma. E&#39; consigliabile, se non indispensabile, utilazzare questa stringa poichè senza di essa la finestra di esecuzione del programma si chiuderebbe all&#39;istante, impedendo così il controllo del risultato. Inserendo invece &#34;system(&#34;PAUSE&#34;);&#34; è possibile mantenere aperta la finestra di esecuzione per tutto il tempo necessario alla consultazione. La finestra viene poi chiusa premendo un qualsiasi tasto da tastiera. </answer_text><num_votes>1</num_votes></answer><answer id="A1815"><answer_text>system(&#34;PAUSE&#34;) serve per sospendere l&#39;esecuzione del programma fino a che un utente non preme un tasto (a video verrà visualizzato: &#34;premere un tasto per continuare&#34;).In pratica serve per visualizzare nella finestra l&#39;output previsto durante l&#39;esecuzione del programma (utile anche per verificarne la correttezza).Se non è presente la finestra viene chiusa al termine dell&#39;esecuzione senza poter visualizzare il &#34;risultato&#34; e dunque potrebbe anche essere omesso(dipende dal tipo di programma creato)</answer_text><num_votes>1</num_votes></answer></question><question id="Q2013"><question_text>Cosa si intende per fase di fetch?</question_text><answer id="A1984"><answer_text>ll Fetch è la prima delle tre fasi fondamentali dell&#39;elaborazione sequenziale di un programma per calcolatori elettronici, la quale a sua volta si articola in 4 passi, ogni passo corrisponde a un trasferimento di dati fra i registri della CPU e/o allocazioni specifiche della memoria centrale. La fase Fetch è la fase di prelievo delle istruzioni, per caricarle nell&#39;IR (instruction register). 
Alla fase Fetch seguono la fase Decode, e in fine la fase Execute.</answer_text><num_votes>0</num_votes></answer><answer id="A1792"><answer_text>La fase di fetch è la prima delle tre fasi per l&#39;esecuzione di un programma.La fase di fetch la CPU va a leggere le istruzioni dalla memoria RAM.
In particolare la fase di fetch viene eseguita in 4 passi:
1.la CU copia il contenuto di PC in AR
2.viene letto dalla RAM il contenuto all&#39;indirizzo dato da AR
3.il dato letto messo a disposizione nel DR
4.il contenuto del DR spostato in CIR
CU-ControlUnit,PC-ProgramCounter,AR-AddressRegister,DR-DataRegister,CIR-CurrentInstructionRegister</answer_text><num_votes>2</num_votes></answer><answer id="A1942"><answer_text>Il fetch è la prima fase del ciclo di esecuzione di un programma e comprende:
1 L&#39;invio da parte dell&#39;unità di controllo di un segnale affinché il contenuto del program counter sia trasferito nell&#39;address register.
2 L&#39;invio di un segnale alla memoria affinché venga letto il dato appena trasferito.
3 L&#39;inserimento del dato letto nel data register.
4 L&#39;invio di un segnale di controllo da parte dell&#39;UC affinché il contenuto del data register sia spostato nel registro di istruzione corrente.
</answer_text><num_votes>2</num_votes></answer><answer id="A1985"><answer_text>ll Fetch è la prima delle tre fasi fondamentali dell&#39;elaborazione sequenziale di un programma per calcolatori elettronici, la quale a sua volta si articola in 4 passi, ogni passo corrisponde a un trasferimento di dati fra i registri della CPU e/o allocazioni specifiche della memoria centrale. La fase Fetch è la fase di prelievo delle istruzioni, per caricarle nell&#39;IR (instruction register). 
Alla fase Fetch seguono la fase Decode, e in fine la fase Execute.</answer_text><num_votes>0</num_votes></answer><answer id="A1954"><answer_text>La fase di fetch è la fase di acquisizione di ogni istruzione. Essa è composta da quattro passi:
1. L&#39;unità di controllo manda un segnale affinché il contenuto del registro contatore di programma venga trasferito nel registro indirizzi
2. La memoria riceve un dato di controllo per leggere il dato nel registro indirizzi
3. Il dato viene trasferito nel registro dati
4. L&#39;unità di controllo manda un segnale affinché il contenuto del registro dati sia spostato nel registro istruzione corrente.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2117"><question_text>Che peso hanno i diversi componenti hardware sulla velocità di un computer, in proporzione fra loro? Avendo a disposizione un budget limitato, su quali componenti sarebbe preferibile investire?</question_text><answer id="A1839"><answer_text>Sicuramente CPU e memoria RAM in coppia per poter caricare molti dati ed elaborarli velocemente. Poi la memoria fissa: hard disk con accesso lento, ma più capienti, o memorie allo stato solido (ssd) più veloci ma di capacità ridotta. Le altre periferiche (scheda audio, video, rete, ecc..) non sono molto influenti sulla velocità di calcolo (ultimamente però alcuni software sfruttano anche la GPU in parallelo alla CPU per calcoli complessi). Se si necessita solo di velocità, investire sui primi 3</answer_text><num_votes>0</num_votes></answer><answer id="A1827"><answer_text>Il componente hardware che ha maggior peso sulla velocità di un computer e la CPU, infatti più è elevata la frequenza degli impulsi del clock, più è elevato il numero di istruzioni eseguite in un unità di tempo. Secondariamente le prestazioni di un PC sono influenzate dalla memoria RAM disponibile (e dal tipo di memoria -SRAM o DRAM-), e dalla velocità di trasferimento dati sul disco di memoria. Per questo motivo è preferibile investire sulla potenza del processore. </answer_text><num_votes>0</num_votes></answer><answer id="A1950"><answer_text>La CPU ha il peso maggiore nella velocità del computer, seguono i registri, la SRAM, la DRAM, memoria di massa ed infine tutti i rimanenti componenti. È doveroso precisare che non esiste una scala precisa con cui stabilire quale componente influisce maggiormente sulla velocità finale del computer. Avendo un budget limitato bisognerebbe investire nei componenti nell&#39;ordine in cui sono stati scritti sopra, considerando che gli investimenti dovrebbero basarsi sull&#39;utilizzo dell&#39;utente specifico.</answer_text><num_votes>1</num_votes></answer><answer id="A1971"><answer_text>Alcuni componenti di un computer sono meno fondamentali dagli altri comunque la velocità di un computer dipende dalla velocità di calcolo del processore e dalla sua memoria cache montato su una giusta scheda madre e dalla memoria RAM che contiene tutti i dati ed i programmi che sono coinvolti nell&#39;elaborazione corrente.Infine la velocità del computer nell&#39;eseguire un&#39;elaborazione dipende dal numero di applicazioni in esecuzione.Quindi sarebbe opportuno investire sul MICROPROCESSORE E sul RAM.</answer_text><num_votes>1</num_votes></answer></question><question id="Q1983"><question_text>Cos&#39;è l&#39;overflow? Fai un esempio.</question_text><answer id="A2028"><answer_text>L&#39;overflow si verifica quando,eseguita un&#39;operazione numerica,il numero risultante supera il massimo numero che il calcolatore puó rappresentare </answer_text><num_votes>1</num_votes></answer><answer id="A2026"><answer_text>Con overflow si intende quando un programma richiede uno spazio maggiore di quello a disposizione, o quando durante l’esecuzione di un programma genera un valore aritmetico maggiore della capacità della cella di memoria dedicata al risultato.
Per esempio creando un ciclo infinito in cui andremo ad incrementare una variabile ad ogni ciclo sicuramente prima o poi si verificherà un overflow (con una cella di memoria di 8 bit il massimo numero che si può salvare prima di entrare in overflow è 255).</answer_text><num_votes>4</num_votes></answer></question><question id="Q2165"><question_text>Come mai nello scanf, dentro gli apici dove di solito scrivo %d, è meglio non scrivere altro? per esempio scanf(“valore=%d”, &#38;valore); Cosa dovrei inserire da tastiera in questo caso per assegnare un valore valido alla variabile valore?</question_text><answer id="A1809"><answer_text>E&#39; meglio non scrivere altro perché in caso contrario dovrei inserire da tastiera anche ciò che non è l&#39;identificatore e sta tra gli apici affinché la variabile venga valorizzata in modo corretto. In questo caso per assegnare un valore valido alla variabile valore dovrei scrivere all&#39;interno del programma &#34; valore= &#34; seguito dal valore intero desiderato. </answer_text><num_votes>0</num_votes></answer><answer id="A1854"><answer_text>Perchè inserendo = il calcolatore ragiona in altro modo, fa altro ragionamento, paragona il %d ad un altra variabile con un risultato non conforme a ciò che volevamo raggiungere. </answer_text><num_votes>0</num_votes></answer><answer id="A1877"><answer_text>Nello scanf è meglio non scrivere altro oltre al carattere di controllo (es. %d) poichè se si inserisce un qualsiasi altro valore, ci possono essere problemi durante l&#39;esecuzione del programma.
Si dovrebbe inserire:
printf(&#34;valore= &#34;); scanf(&#34;%d&#34;,&#38;valore);</answer_text><num_votes>1</num_votes></answer><answer id="A1976"><answer_text>Inserire caratteri diversi dai caratteri di controllo all&#39;interno delle virgolette nella funzione scanf(&#34;&#34;) provoca errori nella lettura dell&#39;input. Utilizzando la notazione scanf(“valore=%d”, &#38;valore) oltre a non ottenere lo stesso risultato che si otterrebbe con printf(&#34;valore=&#34;) scanf (&#34;%d&#34;,&#38;valore), nella variabile &#34;valore&#34; potrebbe essere inserito un valore errato (qualsiasi sia l&#39;input da tastiera).</answer_text><num_votes>1</num_votes></answer></question><question id="Q2012"><question_text>Cosa si intende per linguaggio ad alto livello?</question_text><answer id="A1949"><answer_text>Con linguaggio ad alto livello si intende un linguaggio comprensibile e utilizzabile sia dalla persona che desidera utilizzare tale linguaggio per programmare sia dal compilatore con cui si programma. I linguaggi ad alto livello più comuni sono C, C++, Pascal, Java e molti altri.
Tramite il compilatore il linguaggio ad alto livello viene tradotto nel linguaggio binario, unico linguaggio che la macchina conosce e comprende.
</answer_text><num_votes>0</num_votes></answer><answer id="A2019"><answer_text>Un linguaggio ad alto livello è un linguaggio di programmazione più vicino alla logica del linguaggio naturale, in questo modo si rende il programma più leggibile e indipendente dalle caratteristiche dell&#39;hardware rispetto ad un linguaggio di basso livello.</answer_text><num_votes>1</num_votes></answer><answer id="A2016"><answer_text>Per linguaggio ad alto livello si intende un linguaggio che permette di avere un livello di astrazione tale da poter essere compreso sia dal programmatore, che riconosce al suo interno delle strutture base, ma anche dal compilatore, programma che potrà convertirlo in un linguaggio comprensibile dal calcolatore.</answer_text><num_votes>2</num_votes></answer></question><question id="Q1962"><question_text>Perché nell&#39;utilizzo del comando &#34;scanf&#34; è importante, dopo aver dichiarato un opportuno carattere di controllo, inserire una &#34;&#38;&#34; prima del nome della variabile nella quale vogliamo sia memorizzato il dato?</question_text><answer id="A1926"><answer_text>In quanto al contrario del comando &#34;printf&#34;, &#34;scanf&#34; salva un valore per cui è necessario attribuire un indirizzo in cui quel valore andrà salvato e ciò avviene utilizzando l&#39;operatore &#34;&#38;&#34;.</answer_text><num_votes>0</num_votes></answer><answer id="A1934"><answer_text>La &#38; commerciale è necessaria in quanto restituisce nel comando di scanf l&#39;indirizzo dell&#39;operatore in cui allocare/assegnare il valore in input. Nel momento in cui non ci fosse la &#38; commerciale, come ad esempio:
scanf(&#34;%d&#34;, a); 
&#34;a&#34; verrà visto come operatore , ossia come &#34;valore&#34;, e quindi scanf non sarà in grado di assegnarne il valore di input in quando non ne vede l&#39;indirizzo, quindi &#34;&#38;a&#34; viene passato come indirizzo di &#34;a&#34;.</answer_text><num_votes>2</num_votes></answer><answer id="A1973"><answer_text>la funzione dell&#39;&#34;&#38;&#34;e nella sintassi della funzione &#34;scanf&#34; verrà trattata nell&#39;argomento riquardante i puntatori.
Il suo significato è comunque quello di assegnare il valore inserito alla variabile dichiarata altrimenti il compilatore non capirebbe 
dove salvare in dato inserito. L&#39;&#34;&#38;&#34; è definito puntatore proprio per il motivo che segnala al compilatore la variabile predisposta ad accogliere il valore dichiarato. </answer_text><num_votes>2</num_votes></answer></question><question id="Q2163"><question_text>Perché comandi come &#34;scanf&#34; e &#34;printf&#34; non fanno parte delle parole chiave del linguaggio C? 
Quale libreria è necessario includere?</question_text><answer id="A2008"><answer_text>Il linguaggio C (come qualunque) consente la realizzazione di programmi servendosi dell&#39;utilizzo di &#34;keywords&#34; (parole chiavi).
I comandi &#34;scanf&#34; e &#34;printf&#34; non fanno rigorosamente parte del linguaggio C, bensì della libreria standard; per usufruire di questi bisogna includere la libreria &#60;stdio.h&#62;.</answer_text><num_votes>0</num_votes></answer><answer id="A1796"><answer_text>&#34;printf()&#34; e &#34;scanf()&#34; non sono keywords del C ma comandi che consentono al programma di interagire con il mondo esterno. &#34;printf()&#34; permette di scrivere a video una messaggio (output), mentre &#34;scanf()&#34; consente di leggere i dati inseriti da tastiera e di memorizzarli in variabili (input).
Per poter utilizzare questi comandi è necessario inserire la libreria per la gestione delle periferiche input/output della macchina virtuale, ovvero scrivere fuori dalla &#34;main{}&#34;: &#34;#include &#60;stdio.h&#62;&#34;.
</answer_text><num_votes>1</num_votes></answer><answer id="A1964"><answer_text>per utilizzare le istruzioni scanf e printf è necessario includere la libreria &#34;#&#60;stdio.h&#62;&#34;
le keyword sono parole fondamentali,infatti non è necessario inizializzare alcuna libreria per utilizzarle,queste rimangono tali anche per le applicazioni
del c (es:microcontrollori), mentre le istruzioni da te elencate non sono fisse, se utilizzo il linguaggio c su un altra piattaforma avrò
librerie e istruzioni diverse, invece le keyword rimarranno tali perchè proprie del c.</answer_text><num_votes>1</num_votes></answer><answer id="A1803"><answer_text>Le parole chiave del linguaggio C sono parole riservate al linguaggio stesso, ad esempio int, char, float..., che non possono essere usate come identificatori di funzioni e variabili.
Scanf e printf sono invece funzioni predefinite del linguaggio C che permettono di effettuare l&#39;input e l&#39;output alla consolle e fanno parte della libreria di standard input\output presente nell&#39;intestazione del programma (#include &#60;stdio.h&#62;).</answer_text><num_votes>1</num_votes></answer></question><question id="Q1973"><question_text>Quali sono le due caratteristiche che differiscono tra le memorie di archiviazione di massa e la memoria centrale (R.A.M.)?</question_text><answer id="A1988"><answer_text>La memoria RAM si tratta di una memoria volatile, ovvero tutto il contenuto all&#39;interno di essa viene perso quando cessa l&#39;alimentazione del sistema. Al contrario la memoria di archiviazione di massa può contenere dati in maniera permanente anche allo spegnimento del calcolatore. La memoria RAM è inoltre molto più piccola di quella di massa ma presenta un tempo di accesso (tempo che intercorre tra la richiesta e gli elementi da leggere/scrivere) di gran lunga maggiore rispetto a quella di massa.</answer_text><num_votes>0</num_votes></answer><answer id="A1990"><answer_text>La memoria RAM è una memoria &#34;volatile&#34;, poiché quando essa non viene più alimentata perde i dati al suo interno. 
Le RAM sono molto più veloci (e anche molto più costose) rispetto alle memorie di archiviazione di massa, le quali sono memorie persistenti a differenza delle prime.</answer_text><num_votes>1</num_votes></answer><answer id="A1802"><answer_text>La memoria RAM è una memoria volatile, a differenza dei dispositivi di memoria di massa che sono memorie persistenti (es. Hard Disk); le due memorie differisco tuttavia anche su un&#39;altro aspetto: la RAM (per l&#39;appunto Random Access Memory) è molto più veloce delle memorie di massa in quanto il suo tempo d&#39;accesso alle locazioni di memoria che la caratterizzano è indipendente dall&#39;indirizzo delle loro Words.</answer_text><num_votes>3</num_votes></answer><answer id="A2017"><answer_text>La memoria centrale è volatile:si perdono le informazioni quando cessa l&#39;alimentazione del sistema; la memoria di massa è non volatile:è in grado di mantenere le informazioni in essa contenute anche quando cessa l&#39;alimentazione del sistema(hard disk e ROM).
La memoria centrale ha un tempo d&#39;accesso fisso che non dipende dalla dimensione/posizione della parola di codice da cercare;in quella di massa invece il tempo d&#39;accesso dipende dalla velocità di lettura dei dati e dalla loro posizione.</answer_text><num_votes>0</num_votes></answer><answer id="A2002"><answer_text>La memoria RAM ha la funzione primaria di ricevere un’enorme quantità di dati finché il pc sta elaborando, ha il compito di creare un accesso diretto a tutti gli indirizzi in un tempo breve e una velocità molto elevata. Per quanto riguarda la memoria di massa,invece, ha il compito di raccogliere una grande quantità di dati che vengono immagazzinati, viene definita a differenza della RAM come una memoria non volatile, che ha il compito di registrare, conservare e permettere la rilettura dei dati.</answer_text><num_votes>0</num_votes></answer></question><question id="Q1976"><question_text>In che modo fattori esterni, come la quantità di memoria disponibile influenzano la velocità del sistema nonostante gli impulsi del clock?</question_text><answer id="A1821"><answer_text>Se un clock permette alte velocità di elaborazione ma i dati arrivano lentamente
anche il calcolatore sarà lento in quanto elaborerà i dati in modo veloce ma solo quando li riceve.
Ci saranno veloci fasi di elaborazione seguite da lente fasi di attesa.Esempio:
Paragoniamo un flusso di dati ad uno d&#39;acqua corrente in un tubo con strozzature(ram...);
Se leviamo una strozzatura non otteniamo nulla poichè rimangono le altre.
Per velocizzare il flusso si devono ridurre tutte le strozzature.</answer_text><num_votes>0</num_votes></answer><answer id="A1979"><answer_text>Oltre che dalla frequenza degli impulsi generati dal clock – dipendente dalla CPU – la velocità del sistema può essere influenzata anche dalla quantità di memoria disponibile.
Con il diminuire della quantità di memoria a disposizione, infatti, diminuirà anche il numero di dati ed istruzioni che potranno essere contenute in essa e conseguentemente eseguite in un’unità di tempo, indipendentemente dagli impulsi generati dall’orologio interno.
Questo contribuirà a ridurre la velocità del sistema.</answer_text><num_votes>2</num_votes></answer><answer id="A1824"><answer_text>In un computer un rallentamento è dato dal fatto che ogni processo in corso è sempre concorrente agli altri per la quantità di risorse (es: CPU e memoria) allocate. A fronte di una certa frequenza di clock dato che un programma lavora su memoria RAM, con tempo di accesso costante, uno dei motivi di rallentamento è dato dalla richiesta di spazio di memoria non disponibile (cioè quando la RAM è piena) e quindi dalla scarsa disponibilità dello stesso.
</answer_text><num_votes>2</num_votes></answer></question><question id="Q2082"><question_text>qual&#39;è stata la necessità che ha portato alla differenzazione tra memoria volatile e non volatile, e quindi perchè nel calcolatore c&#39;è bisogno di due unità di memoria (centrale e di massa) che hanno strutture completamente diverse?</question_text><answer id="A2030"><answer_text>Le necessità che hanno portato alla differenziazione sono state:  
-il bisogno di ottenere una memoria alla quale accedere velocemente per riuscire così ad implementare il maggior numero di operazioni della CPU nell&#39;unità di tempo(volatile) ;
-una memoria in grado di mantenere le informazioni anche quando non viene alimentata, cioè avere la capacità di salvare permanentemente i dati(non volatile).
Questo ha portato alla formazione di unità separate, con compiti diversi, anche nel calcolatore.</answer_text><num_votes>1</num_votes></answer><answer id="A1894"><answer_text>Il computer ha bisogno di una memoria non volatile (ROM) perchè deve aver la possibilità di mantenere sempre salvati i programmi del sistema per il suo funzionamento. Mentre la RAM è stata creta per salvare lo stato dei processi che sono in continuo cambiamento. Quindi per questo sono state create due schede di memoria diverse.</answer_text><num_votes>0</num_votes></answer><answer id="A1987"><answer_text>La memoria centrale in quanto volatile, presenta un tempo di accesso alle celle molto ridotto che è inoltre indipendente dall&#39;indirizzo della &#34;word&#34; alla quale si vuole accedere, caratteristica che permette una diretta collaborazione con la CPU. Essa però necessita di un&#39;alimentazione costante per trattenere i dati inseriti nel sistema ed inoltre ridotte capacità di essa obbligano la compresenza di altre memorie di massa in grado di memorizzare maggiori quantità di programmi in modo persistente.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2067"><question_text>Cosa si intende per sistema Legacy?</question_text><answer id="A1968"><answer_text>Letteralmente &#34;Sistema Ereditario&#34; ovvero un sistema/applicazione (Es. l&#39;applicazione commerciale COBOL) di non recente invenzione/costruzione, con però ancora del valore.
Cioè un sistema &#34;datato&#34; che conserva ancora il suo valore all&#39;interno di un mondo in continua evoluzione. 
Sistema di non facile modifica o sostituzione od upgrade.

Julius K. Baah Donkor
Matricola: 167124</answer_text><num_votes>1</num_votes></answer><answer id="A1808"><answer_text>Con sistema &#39;legacy&#39; ci si riferisce ad un software o un hardware che, pur essendo datato, continua ad essere utilizzato per la sua funzionalità o per mancanza di alternative valide.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2128"><question_text>Perché all&#39;inizio del programma servono queste righe:
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
 A cosa servono e come funzionano?</question_text><answer id="A1967"><answer_text>Il simbolo # rappresenta un Direttiva, ovvero un simbolo che comunica al processore di includere qualcosa. In questo caso stiamo includendo due librerie: &#60;stdio.h&#62; è l&#39;header file (.h) della libreria standard del linguaggio c che contiene definizioni di variabili, funzioni etc utilizzati nelle operazioni di input e output; &#60;stdlib.h&#62; è sempre l&#39;header file delle libreria standard che dichiara variabili e costanti di utilità generale, come per esempio i tipi di dato.</answer_text><num_votes>2</num_votes></answer><answer id="A1899"><answer_text>Sono librerie che fanno parte della libreria standard del C.
&#60;stdio.h&#62; fornisce le funzionalità basilari di input/output del C, per esempio ti permette di usare le funzioni printf e scanf.
&#60;stdlib.h&#62; è neccessario per eseguire operazioni come per esempio conversioni e allocazione di numero pseudo casuali .
Se non vengono incluse queste librerie in un progetto, tante funzioni importanti di utilità generale come appunto printf e scanf non possono essere usate.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2116"><question_text>Qual è la differenza tra algoritmo e programma?</question_text><answer id="A1918"><answer_text>L&#39;algoritmo indica in pseudo-codice o in un linguaggio naturale o quasi tale il metodo da usare per risolvere un problema mentre nella stesura del programma si è fatto un passaggio in più in quanto si è &#34;tradotto&#34; l&#39;algoritmo in un linguaggio di programmazione che possa essere eseguito da un calcolore. (N.B. il concetto di algoritmo non prevede necessariamente che il problema debba essere risolto da un calcolatore)</answer_text><num_votes>1</num_votes></answer><answer id="A1833"><answer_text>Più che di differenza sarebbe opportuno parlare di rapporto tra algoritmo e programma; infatti tra i due intercorre lo stesso ordine di rapporto esistente tra genere (algoritmo) e specie(programma); infatti mentre un generico algoritmo può essere scritto in un qualunque linguaggio (linguaggio naturale,matematico, ecc...), un programma è un algoritmo che viene scritto in un linguaggio (c.d. di programmazione) che viene compreso dal calcolatore che sarà l&#39;esecutore di quell&#39;algoritmo. </answer_text><num_votes>1</num_votes></answer><answer id="A2010"><answer_text>L&#39;algoritmo è una sequenza di passi che porta alla risoluzione di un problema e il programma è la traduzione dell&#39;algoritmo in un linguaggio comprensibile alla macchina.</answer_text><num_votes>0</num_votes></answer><answer id="A1819"><answer_text>Un algoritmo è un procedimento che risolve un determinato problema attraverso un numero finito di passi discreti e non ambigui. 
Invece un programma è un algoritmo posto in forma comprensibile al computer(scritto tramite un linguaggio di programmazione), cioè un insieme di istruzioni che, tramite un esecutore(computer), producono soluzioni per i problemi posti. 
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2029"><question_text>In cosa consiste un procedimento top-down, e perchè a volte tale procedimento risulta fondamentale?</question_text><answer id="A1969"><answer_text>Nella scrittura di un algoritmo il procedimento top-down consiste nell&#39;aggiungere dei sotto-algoritmi (funzioni) che specificano un&#39;istruzione dell&#39;algoritmo principale nel caso in cui risultasse ambigua o non abbastanza precisa. In questo modo si realizza un algoritmo di livello superiore chiaro e sintetico che si appoggia ad algoritmi di livello inferiore per eseguire in modo esteso le istruzioni più dettagliate.</answer_text><num_votes>1</num_votes></answer><answer id="A2015"><answer_text>Un procedimento top-down consiste nello scomporre un problema in tanti sottoproblemi più piccoli e dettagliati.Questo metodo risulta utile per la corretta comprensione di un problema, che è spesso una fase fondamentale nella rioluzione del problema per un informatico.</answer_text><num_votes>0</num_votes></answer><answer id="A1857"><answer_text>Il procedimento top-down consiste nella suddivisione del programma di partenza in tanti sottoproblemi più semplici da risolvere. Il sottoproblema viene suddiviso a sua volta, se ancora necessario in sottoproblemi più semplici fino ad ottenere sottoproblemi elementari, cioè non ulteriormente scomponibili. Tale procedimento risulta fondamentale per il miglioramento dell&#39;ingegneria del software ovvero: affidabilità, leggibilità, riutilizzabilità e revisionabilità.
</answer_text><num_votes>1</num_votes></answer><answer id="A1919"><answer_text>Il top-down è un procedimento che prevede di affrontare un problema partendo dall&#39;ultima fase di questo: l&#39;obiettivo (top), e affrontare mano a mano i sottoproblemi nei quali può essere scomposto (down). Questo procedimento risulta fondamentale per affrontare solo e soltanto problemi direttamente collegati con quello finale, in quanto l&#39;obiettivo rimane sempre focalizzato. Come nelle ricette di cucina, si parte dal piatto finale per poi scomporlo negli ingredienti necessari e non viceversa.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2129"><question_text>Se assegno un valore float a una variabile integer, che valore troverò poi nella variabile?</question_text><answer id="A1993"><answer_text>Troverò il valore troncato, quindi senza decimali dopo la virgola.
Esempio: 67.7 diventerà 67</answer_text><num_votes>0</num_votes></answer><answer id="A1917"><answer_text>Troverai solamente la parte intera del numero assegnato alla variabile.
Ad esempio: assegnando il valore di 5.77 a una variabile di tipo integer, troverai il valore di 5 assegnato alla suddetta variabile, (in parole povere, il numero viene semplicemente troncato (NON ARROTONDATO!!)).</answer_text><num_votes>3</num_votes></answer><answer id="A2003"><answer_text>Nella variabile troverò solo il valore integer (ovvero i numeri a sinistra della virgola)</answer_text><num_votes>0</num_votes></answer></question><question id="Q2069"><question_text>Come funziona la conversione da decimale a binario?</question_text><answer id="A1804"><answer_text>Per convertire un numero decimale in binario è necessario dividere il numero decimale con il divisore 2, nel caso in cui il calcolo dia resto si segna 1 e viceversa si segna 0.

25|1
12|0
06|0
03|1
01|1

Quello a destra della linea verticale è il numero binario di 25 che deve essere letto dal basso verso l&#39;alto.

Quindi 25 (10) = 11001 (2)
(10)= valore decimale   (2)= valore binario</answer_text><num_votes>0</num_votes></answer><answer id="A1991"><answer_text>Per convertire un numero da decimale a binario è necessario effettuare una serie di divisioni per 2 del numero decimale. Il numero binario si ottiene considerando, dalla cifra meno significativa alla più significativa, i resti delle divisioni effettuate.
Per esempio se voglio convertire il numero 49 in binario devo operare in questo modo:
49:2=24 resto 1
24:2=12 resto 0
12:2=6 resto 0
6:2=3 resto 0
3:2=1 resto 1
1:2=0 resto 1
Il numero 49 in notazione binaria è 110001</answer_text><num_votes>3</num_votes></answer><answer id="A1959"><answer_text>Per trasformare un numero binario in decimale:
ogni cifra del numero decimale corrisponde ad una potenza del 2, se questa cifra è &#34;1&#34; allora la prendiamo e la mettiamo da parte, se questa cifra è &#34;0&#34; passiamo alla successiva(procedi da destra verso sinistra),lo si calcola tramite l’algoritmo della 
divisione, dividendo successivamente per 2 (base del sistema binario) il numero decimale da 
convertire e considerando i resti al contrario.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2008"><question_text>Cosa succede se assegno un valore non intero ad una variabile di tipo int? Se assegno ad esempio un valore di 3.9 e lo sommo al numero 4 cosa viene dato come risultato?</question_text><answer id="A1807"><answer_text>allora quello che succede se assegno un valore non intero ad una variabile di tipo intera è che il compilatore sarà capace di leggere solo la parte reale del valore e di conseguenza non leggera le cifre dopo la virgola. il risultato della somma tra 3.9 e 4 sarà 7.</answer_text><num_votes>0</num_votes></answer><answer id="A1998"><answer_text>Se assegno un valore non intero ad una variabile intera, come ad esempio 3.9, il programma inizializzerà la variabile soltanto con la parte intera del numero. Ad esempio assegnando il valore 3.9 alla variabile &#34;i&#34; e stampandola a video, leggeremo &#34;i=3&#34;. Infatti, se alla variabile intera i=3.9 sommo j=4, come risultato otterremo il valore 7, il quale è esattamente la somma delle parti intere dei due valori.</answer_text><num_votes>2</num_votes></answer><answer id="A1937"><answer_text>I numeri interi, rappresentati dal tipo int, sono quelli “senza la virgola”. 
Quindi se svolgiamo una qualsiasi operazione non verrà considerata la parte decimale.
Se assegno un valore non intero, ad esempio 3.9 il valore visualizzato a console sarà soltanto la parte intera (3), mentre per stampare anche la mantissa bisogna dichiarare una variabile di tipo float.
Se sommo 4 al numero 3.9, il risultato mostrato a schermo sara 7,quindi solo la parte intera, omettendo i numeri dopo la virgola.</answer_text><num_votes>1</num_votes></answer><answer id="A2001"><answer_text>Se si assegna un valore non intero ad una variabile di tipo int (variabile di tipo intero), la variabile assumerà il valore corrispondente alla sola parte intera del numero assegnato.
Nel caso venga assegnato il valore 3.9 ad una variabile di tipo int, essa assumerà il valore 3, pertanto sommandola al numero 4 il risultato ottenuto sarà 7.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2158"><question_text>Spiegare le regole per la definizione di un nome di una variabile</question_text><answer id="A1868"><answer_text>Le variabili sono distinte in base ad identificatori simbolici. Ogni identificatore è composto da una successione di lettere, cifre e il simbolo underscore, ma al primo posto non va mai una cifra. Il linguaggio C è case sensitive, bisogna quindi fare molta attenzione all&#39;utilizzo di maiuscole e minuscole. E&#39; vietato utilizzare uno stesso identificatore per più variabili e una variabile per più identificatori. Esistono infine nomi che non si possono utilizzare anche se corretti lessicalmente.</answer_text><num_votes>3</num_votes></answer><answer id="A1978"><answer_text>Definire il nome di una variabile significa assegnare un nome a scelta dell&#39;utente ad una locazione di memoria.
Per eseguire questa operazione bisogna seguire delle regole:
-è obbligatorio definire il tipo di dato che conterrà la variabile(int,float,char,...);
-poi si definisce il nome a scelta dell&#39;utente(è consigliato scegliere un nome che richiami il significato del dato che viene inserito).
Esempi:  int altezza; float lato; </answer_text><num_votes>2</num_votes></answer></question><question id="Q2050"><question_text>quando è necessario usare il comando di conversione delle variabili (casting)?</question_text><answer id="A1795"><answer_text>E&#39; necessario usarlo quando il compilatore esegue operazioni (somma, differenza etc) fra due o più variabili disomogenee (ad es., int a=5; float b=2.5;) e salva il risultato nella variabile int c=a+b; così facendo si perde la parte decimale (c=7 anziché 7.5). Quindi, anche per una maggior comprensione e pulizia del codice, è meglio specificare il formato di &#34;output&#34; (int, float, unsigned...) per evitare risultati indesiderati. Con l&#39;esempio di prima, si scrive 
int c = (int) (a+b); //c vale 7.</answer_text><num_votes>1</num_votes></answer><answer id="A1965"><answer_text>Il comando di casting converte un tipo di variabile in un altro tipo, è necessario usarla quando si vuole compiere un operazione che ,usando il tipo di variabile dichiarata , risulterebbe errata o approssimata. Il comando di casting è denotato da due parentesi tonde () al cui intero è scritto il tipo di variabile in cui va convertita la variabile. Per esempio il casting va utilizzato nella divisione tra numeri interi il cui risultato è un numero reale, convertendo le variabili intere in reali.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2137"><question_text>Che differenza c&#39;è tra linguaggi compilati e linguaggi interpretati?</question_text><answer id="A1995"><answer_text>Nei linguaggi compilati partendo da un assembler di alto livello tramite dei tools(compilatori) si passa alla compilazione in linguaggio 
macchina specifico per quel calcolatore con quel tipo di sistema operativo il quale verra&#39; poi eseguito. La differenza dei linguaggi interpretati 
sta nel fatto che il compilatore non traduce fino a linguaggio macchina ma simula il programma in un ambiente virtuale.
Questo rende possibile eseguire il programma su calcolatori con S.O. differenti.

 </answer_text><num_votes>1</num_votes></answer><answer id="A1963"><answer_text>Il linguaggio è compilato quando il codice viene tradotto direttamente dal compilatore in linguaggio macchina. In questo caso è il compilatore a inserire nel programma compilato tutta la complessità che caratterizza la struttura interna del programma, andando a caricarlo direttamente in memoria e rendendolo immediatamente eseguibile. Il linguaggio è interpretato quando è un interprete esterno al compilatore a tradurre il codice in linguaggio macchina al momento dell&#39;esecuzione.</answer_text><num_votes>0</num_votes></answer><answer id="A1863"><answer_text>I linguaggi compilati sono linguaggi come C e C++ dove per eseguire il programma deve essere prima compilato. Quindi se carico il programma su un altro calcolatore devo ricompilarlo.I linguaggi interpretati, come il Java, non passano attraverso il compilatore,ma funzionano su una macchina virtuale che esegue direttamente il codice. Essi funzionano su ogni macchina direttamente. A suo svantaggio, i linguaggi interpretati però hanno una velocità di esecuzione inferiore rispetto ai compilati.

</answer_text><num_votes>1</num_votes></answer><answer id="A1994"><answer_text>Nei linguaggi compilati partendo da un assembler di alto livello tramite dei tools(compilatori) si passa alla compilazione in linguaggio 
macchina specifico per quel calcolatore con quel tipo di sistema operativo il quale verra&#39; poi eseguito. La differenza dei linguaggi interpretati 
sta nel fatto che il compilatore non traduce fino a linguaggio macchina ma simula il programma in un ambiente virtuale.
Questo rende possibile eseguire il programma su calcolatori con S.O. differenti.

 </answer_text><num_votes>0</num_votes></answer></question><question id="Q2042"><question_text>Relativamente all&#39;architettura hardware del calcolatore la CPU in che modo riesce a gestire le periferiche e tutti i suoi componenti contemporaneamente? </question_text><answer id="A1996"><answer_text>Secondo il modello di von Neumann la macchina gestisce le operazioni in maniera sequenziale (non possono essere eseguite istruzioni in modalità parallela quindi non contemporaneamente). Le operazioni, infatti, vengono effettuate in modo sincrono rispetto ad un clock di sistema che genera intervalli di tempo. In ciascuno di questi intervalli l&#39;Unità di Controllo stabilisce le funzioni da svolgere. CPU, suoi componenti e periferiche inoltre comunicano attraverso bus di sistema.</answer_text><num_votes>3</num_votes></answer><answer id="A1831"><answer_text>La CPU, o anche Central Processing Unit, è il processore dei calcolatori. Gestisce tutte le sue periferiche contemporaneamente grazie a:
-il bus di sistema, che collega fra di loro tutti i componenti, rendendoli dunque raggiungibili ai messaggi di altre componenti
-la frequenza del clock che stabilisce la velocità del processore, avendo così la possìbilità di aumentarne le prestazioni, riuscendo a svolgere più attività contemporaneamente 
</answer_text><num_votes>1</num_votes></answer></question><question id="Q1967"><question_text>Dato che una variabile integer ( int ) occupa uno spazio di memoria equivalente a 4 byte ( 32 bit ), 
mi sembra chiaro che il numero da memorizzare non può essere di lunghezza infinita;
quale è il numero memorizzabile più grande utilizzando una variabile integer (limite superiore ed inferiore)?</question_text><answer id="A1962"><answer_text>Vi sono due tipologie di variabile integer: signed o unsigned. L&#39;utente può decidere di usare una o l&#39;altra a seconda dei valori che verranno successivamente assegnati alla variabile. La variabile signed int può contenere valori da -2147483648 a +2147483647. Invece, la variabile unsigned int può contenere solo valori positivi, cioè da 0 a +4294967295.</answer_text><num_votes>1</num_votes></answer><answer id="A1928"><answer_text>Utilizzando una variabile di tipo &#34;int&#34; i numeri da memorizzare devono essere compresi tra -32768 e 32767,
ma se si utilizza il modificatore &#34;unsigned&#34; i numeri che si possono memorizzare devono essere compresi tra da 0 e 65535.</answer_text><num_votes>0</num_votes></answer><answer id="A1914"><answer_text>Una variabile tipo int di 32 bit può rappresentare dei numeri interi sia positivi che negativi, infatti, un bit ne indica il segno.
In questo caso si avrà un limite massimo dei positivi di +2147483647 e dei negativi di ?2147483648.
Per calcolare il numero massimo di numeri rappresentabisi si fa 2^n, però per rappresentare il segno serve un bit quindi si potranno rappresentare -2^(n-1) numeri negativi e +2^(n-1) numeri positivi in cui non è compreso lo 0. Il numero massimo sarà +2^(n-1)-1</answer_text><num_votes>1</num_votes></answer><answer id="A1904"><answer_text>La variabile int immagazzina i valori negativi con la tecnica del complemento a due.

Il numero totale di valori immaganizzabili in una variabile int a 32 bit sono: 2^32=4294967296.
Con la tecnica del complemento a due i valori possono essere anche negativi quindi sono compresi tra -(2^32)/2 e +(2^32)/2-1.
Questo significa che il limite inferiore è: -2.147.483.648; mentre quello superiore è: 2.147.483.647.</answer_text><num_votes>1</num_votes></answer><answer id="A2000"><answer_text>Il numero più grande è 2147483647, il più piccolo -2147483648. Il tipo int occupa si 32 bit, ma ne dedica uno al segno (+ o -). Il numero in se
avrà quindi a disposizione 31 bit, ed è calcolabile facendo 2^31 -1 che è appunto uguale a 2147483647. Per il numero minore basta fare lo stesso, unica
differenza è che il modulo sarà di 1 più grande (- 2^31). Questo perchè lo 0 viene considerato positivo, e quindi il numero di negativi e positivi è uguale.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2132"><question_text>Per quanto riguarda il sistema operativo e la gestione della memoria centrale, in che modo funziona la &#34;rilocazione&#34;?</question_text><answer id="A1929"><answer_text>La rilocazione consiste nella  traduzione da indirizzi logici , ovvero gli indirizzi generati dal processore su cui è in esecuzione un processo, a fisici , cioè la locazione esatta,  fisica nella memoria principale. Esistono due tipi diversi di rilocazione che presentano due funzionamenti fra loro differenti: quella statica e quella dinamica.Lo scopo di tale meccanismo, in entrambi i casi, è quindi quello di mettere in corrispondenza gli indirizzi logici con gli indirizzi fisici.</answer_text><num_votes>2</num_votes></answer><answer id="A2032"><answer_text>La Rilocazione dipende dalla mem centrale e dal sist operativo.Generalizzando,il PC legge il valore della mia variabile e attraverso il BUS del sistema le assegna uno spazio virtuale nella mem centrale.Questo spazio nn è altro che il numero binario che corrisponde al valore della variabile la cui memoria può variare in base al tipo di incognita(ex:int,char,float..).Rilocazione quindi,consiste nel spostare un blocco di dati di memoria contenente per esempio la mia variabile in un BUS del sistema.</answer_text><num_votes>0</num_votes></answer><answer id="A1834"><answer_text>la rilocazione, all&#39;atto di caricamento del processo, mette in corrispondenza &#34;indirizzi virtuali&#34;, con &#34;indirizzi fisici&#34; dove sono presenti le risorse necessarie per il processo.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2166"><question_text>Quante variabili è possibile dichiarare? Esiste un limite?</question_text><answer id="A1960"><answer_text>Non c&#39;è un limite, però se le variabili dichiarate vengono messe nello stack del programma che ha dimensione limitata è possibile che si riempia e il programma stesso vada in errore.</answer_text><num_votes>0</num_votes></answer><answer id="A2022"><answer_text>Si, esiste un massimo di variabili che si possono dichiarare, ma si tratta di un numero molto grande. Questo varia a seconda del tipo di variabili che vengono utilizzate (int,float,char...) e a seconda della disponibilità di memoria RAM dove queste verranno memorizzate. A seconda del tipo di variabile perchè sappiamo bene che ogni tipo si distingue per lo spazio che occupa in memoria. Inoltre a seconda della quantità disponibile di memoria RAM perchè è in questa memoria che vengono memorizzate. </answer_text><num_votes>2</num_votes></answer><answer id="A1936"><answer_text>Il numero di variabili che è possibile dichiarare non è limitato ma varia in base alle caratteristiche tecniche del computer che si sta impiegando in fase di programmazione. </answer_text><num_votes>0</num_votes></answer></question><question id="Q2052"><question_text>Quali sono i bus presenti in un calcolatore e quale è il loro utilizzo?</question_text><answer id="A1953"><answer_text>Sono il bus di sistema e il bus di estensione.  Il primo svolge  principalmente tre funzioni:
- funzione  bus di dati, permettendo lo scambio di informzaioni bidirezionali tra i componenti
- funzione bus di indirizzo, dove gli indirizzi inviati in modo unidirezionale  dicono alla cpu dove svolgere la funzione richiesta
- funzione bus di controllo,coordinando le operazioni del sistema in modo tale da eviare conflitti
Il secondo permette la comunicazione con nuove periferiche tramite le slot.</answer_text><num_votes>0</num_votes></answer><answer id="A2013"><answer_text>Il bus di un calcolatore serve per far comunicare tra loro i vari componenti del calcolatore stesso (memoria di massa, periferiche, memoria centrale, CPU). 
La funzione del bus è quella di collegare due elementi, uno trasmette e uno riceve.
Il bus è costituito da tre tipi di linee: linea di controllo, bus dati e bus indirizzi.</answer_text><num_votes>0</num_votes></answer><answer id="A1952"><answer_text>Sono il bus di sistema e il bus di estensione.  Il primo svolge  principalmente tre funzioni:
- funzione  bus di dati, permettendo lo scambio di informzaioni bidirezionali tra i componenti
- funzione bus di indirizzo, dove gli indirizzi inviati in modo unidirezionale  dicono alla cpu dove svolgere la funzione richiesta
- funzione bus di controllo,coordinando le operazioni del sistema in modo tale da eviare conflitti
Il secondo permette la comunicazione con nuove periferiche tramite le slot.</answer_text><num_votes>0</num_votes></answer><answer id="A1981"><answer_text>I bus presenti in un calcolatore sono tre: il bus dati, il bus indirizzi e il bus controlli. Il bus dati serve per trasferire i dati dall&#39;unità master all&#39;unità slave o viceversa; il bus indirizzi serve per trasmettere il contenuto del registro indirizzi alla memoria centrale; infine, il bus controlli serve per trasferire codice di informazioni da eseguire dall&#39;unità centrale all&#39;unità slave, e informazioni di avvenuto compimento dell&#39;operazione richiesta dall&#39;unità slave all&#39;unità master.</answer_text><num_votes>3</num_votes></answer><answer id="A1951"><answer_text>Sono il bus di sistema e il bus di estensione.  Il primo svolge  principalmente tre funzioni:
- funzione  bus di dati, permettendo lo scambio di informzaioni bidirezionali tra i componenti 
- funzione bus di indirizzo, dove gli indirizzi inviati in modo unidirezionale  dicono alla cpu dove svolgere la funzione richiesta
- funzione bus di controllo,coordinando le operazioni del sistema in modo tale da eviare conflitti
Il secondo permette la comunicazione con nuove periferiche tramite le slot.</answer_text><num_votes>0</num_votes></answer></question><question id="Q1999"><question_text>E&#39; possibile che una variabile si chiami &#34;1counter&#34; ? Motivare la risposta. </question_text><answer id="A1924"><answer_text>No, perchè il primo carattere del nome della variabile non può essere un numero, deve essere una lettera.</answer_text><num_votes>0</num_votes></answer><answer id="A1932"><answer_text>No, non è possibile, poichè il carattere &#34;1&#34; posto all inizio del nome della variabile non è compreso dal compilatore. 
Una variabile &#34;counter1&#34; invece è tranquillamente possibile.</answer_text><num_votes>0</num_votes></answer><answer id="A1955"><answer_text>no,  una variabile identifica una porzione di memoria destinata a contenere dei dati, e può avere un nome composto da lettere e cifre, ma che necessariamente non inizi con un numero.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2056"><question_text>Qual è la relazione tra linguaggio di programmazione e linguaggio macchina? E cosa si intende per livelli di astrazione?</question_text><answer id="A2018"><answer_text>Il linguaggio di programmazione definisce il “livello di astrazione” ed è costituito da un alfabeto, con cui vengono costruite un insieme di parole chiave e da un insieme di regole sintattiche per l’uso corretto delle parole del linguaggio. Se il linguaggio è troppo vicino alla macchina, risulta difficile programmare, mentre nel caso in cui sia troppo vicino al programmatore, i programmi risultano essere inefficienti. L&#39;hardware esegue comandi mediante circuiti binari (linguaggio macchina). 
</answer_text><num_votes>0</num_votes></answer><answer id="A1830"><answer_text>Il linguaggio di programmazione viene tradotto in linguaggio macchina per poter essere eseguito. I livelli di astrazione indicano quanto un linguaggio di programmazione dista da un linguaggio macchina (basso) o linguaggio naturale (alto).</answer_text><num_votes>3</num_votes></answer></question><question id="Q2022"><question_text>Riguardo l&#39;allocazione di dati all&#39;interno della memoria centrale, spiegare le funzioni del registro di dati e del registro di indirizzi.</question_text><answer id="A1859"><answer_text>Registro di dati: contiene il dato attualmente oggetto di elaborazione e il risultato al termine dell’esecuzione.

Registro di indirizzi: contengono gli indirizzi e sono usati per accedere alla cella a cui si vuole far riferimento.</answer_text><num_votes>0</num_votes></answer><answer id="A1870"><answer_text>I registri sono il punto più alto della gerarchia della memoria, costituiscono il modo più rapido per il sistema di gestire i dati e possono essere direttamente indirizzati dalle istruzioni di input e output del microprocessore. Vi sono molte classi di registri, come per esempio il registro di dati (DR)e il registro di indirizzi (AR). Il primo viene usato per memorizzare numeri interi, parole lette o da scrivere nella MM. Il secondo contiene gli indirizzi ed è usato per accedere alla memoria. </answer_text><num_votes>1</num_votes></answer></question><question id="Q1964"><question_text>A cosa serve la ricerca dicotomica? Perchè abbrevia il tempo di ricerca? </question_text><answer id="A1852"><answer_text>La ricerca dicotomica, o ricerca binaria, è usata quando si deve cercare un determinato dato in un gruppo, magari molto numeroso, di dati array memorizzati (obbligatoriamente ordinati) e si vuole ridurre i tempi lunghi che risulterebbe avere una ricerca sequenziale.
La ricerca dicotomica,infatti, risulta essere più veloce perché esegue meno confronti,utilizzando un accesso casuale ai dati, di una ricerca sequenziale e dunque, nel caso di un compilatore, gli permette di eseguire meno operazioni.</answer_text><num_votes>0</num_votes></answer><answer id="A1841"><answer_text>La ricerca dicotomica (o binaria) è un algoritmo di ricerca che permette di trovare, tramite accesso casuale, un determinato valore in un insieme ordinato di dati. Questo algoritmo opera meno confronti rispetto per esempio ad un algoritmo di ricerca sequenziale. Per prima cosa trova l&#39;elemento medio dei dati ordinati; se corrisponde a quello cercato, termina la ricerca. Altrimenti valuta se il valore è maggiore o minore dell&#39;elemento medio e ripete il processo finché non trova l&#39;elemento cercato</answer_text><num_votes>1</num_votes></answer><answer id="A1866"><answer_text>La ricerca dicotomica è un algoritmo per velocizzare il ritrovamento di un dato in una lista.
Essa elabora una lista ordinata. 
Viene ricercato il dato nel punto centrale della lista, se non si trova in questa posizione si prosegue nella metà lista dove il dato si dovrebbe trovare.
Si ricontrolla il dato centrale nella metà presa in esame.
Il processo si ripete fino al ritrovamento del dato.
La ricerca è più veloce perchè non controlla tutti i dati ma scarta metà lista ad ogni ciclo.</answer_text><num_votes>1</num_votes></answer></question><question id="Q1971"><question_text>Quale problema si può riscontrare quando si effettuano delle operazioni con variabili di tipo float? Come si può risolvere?</question_text><answer id="A1940"><answer_text>Un tipico problema può insorgere quando si effettuano operazioni tra variabili di tipo diverso (float e int). E&#39; necessario anteporre &#34;(float)&#34; (senza
virgolette) all&#39;identificatore della variabile di tipo int che desideriamo invocare, specificando così che intendiamo trattarla come un float. Inoltre i
valori numerici interi devono terminare con .0 (es. 3.0, 7.0). Es:
int a = 6;
float f;
f= (float) a / 3.0; // f ora vale 2
Questa operazione è detta di typecasting.</answer_text><num_votes>0</num_votes></answer><answer id="A1888"><answer_text>Il problema principale è l&#39;approssimazione della variabile float,es: 20.30 può venir scritto dal compilatore come 20.2999. Infatti i numeri in virgola mobile non sono esatti e possono condurre a risultati &#34;strani&#34;. Per superare il problema non bisogna verificare che i valori siano esattamente quelli che ci si aspetterebbe usando l&#39;aritmetica standard, ma bisogna verificare che i valori calcolati si trovino all&#39;interno di un intorno del risultato atteso definito da un certo margine eps.</answer_text><num_votes>1</num_votes></answer><answer id="A1941"><answer_text>Un tipico problema può insorgere quando si effettuano operazioni tra variabili di tipo diverso (float e int). E&#39; necessario anteporre &#34;(float)&#34; (senza
virgolette) all&#39;identificatore della variabile di tipo int che desideriamo invocare, specificando così che intendiamo trattarla come un float. Inoltre i
valori numerici interi devono terminare con .0 (es. 3.0, 7.0). Es:
int a = 6;
float f;
f= (float) a / 3.0;
Questa operazione è detta di typecasting.</answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L32" title="Conversioni Basi, Rappresentazioni Informazioni, Tipi di Dati" date="2013-10-18"><question id="Q2884"><question_text>Dopo aver spiegato la differenza tra la rappresentazione di numeri interi &#34;in modulo e segno&#34; e quella &#34;in complemento&#34;, descrivere la procedura utilizzata per rappresentare i numeri interi in CA2 e illustrarne i vantaggi e/o gli svantaggi rispetto ad un&#39;altra rappresentazione.</question_text><answer id="A2861"><answer_text>Nella rappresentazione in complemento si hanno due vantaggi:
1 lo zero non viene ripetuto
2 non è richiesta una circuiteria specifica per il trattamento del segno.
La codifica in CA2 per i numeri positivi è la normale codifica cioè il MSB è 0 (numero positivo) e gli altri indicano il valore del numero intero, per i numeri negativi invece codifico il numero come se fosse positivo, poi inverto gli zeri con gli uno e infine sommo 1. es 6=0110 inverto gli zeri con gli uno 1001 infine sommo 1 ottengo 1010=-6 </answer_text><num_votes>0</num_votes></answer><answer id="A2821"><answer_text>La rappresentazione in &#34;modulo e segno&#34; usa il primo bit come BIT DI SEGNO, quindi con N bit vengono usati N-1 bit per il modulo.
Quella in &#34;complemento&#34; non richiede di esaminare il segno.
Avendo N bit, con CA2 si codificano i valori da -2^(N-1) a 2^(N-1)-1. Il bit più significativo rappresenta il segno, se è 0,si procede con la normale decodifica, se è 1 si decodifica poi si sottrae 2^(N-1). Per invertire un numero binario, si invertono le singole cifre e poi si aggiunge 1.
CA2 è meno intuitiva, ma non ha una doppia codifica per lo 0, e le addizioni sono usate anche per le sottrazioni.</answer_text><num_votes>1</num_votes></answer><answer id="A2845"><answer_text>La differenza maggiore tra le due rappresentazioni e l&#39; eliminazione della ridondanza dello zero (cioe lo zero ha due rappresentazioni) presente nella rappresentazione in modulo e segno, in quella in complemento. In CA2 si associa al bit piu significativo (MSB) il segno del numero. Se MSB=0 allora si decodifica normalmente, se invece MSB=1 allora si procede con la decodifica e poi si sottrae 2^n-1 .</answer_text><num_votes>0</num_votes></answer><answer id="A2785"><answer_text>La rappresentazione in &#34;modulo e segno&#34; usa un bit per la decodifica del segno, secondo lo schema:
1=-
0=+
Quella &#34;in complemento&#34; prevede di eseguire una procedura (diversa per CA2 e CA1) per determinare il numero rappresentato.
Nel CA2 si opera nel seguente modo:
-se MSB=0-&#62;normale decodifica
-se MSB=1-&#62;dopo la decodifica si sottrae 2^(N-1)
Il CA2 ha lo svantaggio di essere meno intuitivo del &#34;modulo e segno&#34;.
Tra i vantaggi:
-eliminazione dell&#39;ambiguità dello zero
-possibilità di utilizzare il componente elettronico full-adder sia per le addizioni che per le sottrazioni tra numeri</answer_text><num_votes>3</num_votes></answer></question><question id="Q2810"><question_text>Di che cosa si sta parlando, quando si parla di &#34;conversione implicita&#34; in C?</question_text><answer id="A2829"><answer_text>La conversione implicita in C ( in inglese coercion) è un tipo di conversione di tipo di dati che viene svolta in maniera automatica dal compilatore, cioè quando un operatore ha operandi di tipo diverso, questi vengono convertiti in un tipo comune seguendo delle regole specifiche. Il compilatore tenta la conversione in una sequenza ben definita finché una non riesca, pero in alcuni casi con questa conversione si può verificare una perdita d&#39;informazioni e si può perdere precisione.</answer_text><num_votes>0</num_votes></answer><answer id="A2808"><answer_text>Quando si fanno operazioni con variabili di tipo diverso, il linguaggio C le converte in un tipo comune. La conversione è implicita perchè non c&#39;è bisogno di specificare la richiesta di conversione, ma può portare ad incomprensioni e risultati inaspettati all&#39;interno del programma, ad esempio può verificarsi un overflow per un int convertito in float o un troncamento in caso di float convertito in int. Per ovviare a questi problemi si può ricorrere all&#39;operazione di casting (conversione esplicita), ossia inserendo tra parentesi tonde il tipo che si vuole per il risultato dell&#39;operazione.</answer_text><num_votes>4</num_votes></answer><answer id="A2814"><answer_text>In C esistono due tipi di conversione : implicita ed esplicita. 
La conversione di tipo implicita in C  viene attuata in modo automatico dal compilatore. La conversione implicita riconduce i vari tipi di dati presenti in un&#39;espressione, ad un unico tipo, in modo che essi siano confrontabili. 
Ad esempio se andrò ad assegnare ad una variabile di tipo &#39;&#39; int&#39;&#39; il contenuto di una variabile di tipo &#39;&#39; float&#39;&#39;:

int i =0;
float f=2.8;

i=f;

il compilatore convertirà il valore contenuto nella variabile float (2.8), in un valore intero (2), con conseguente perdita di informazione. </answer_text><num_votes>0</num_votes></answer><answer id="A2837"><answer_text>Per conversione implicita si intende la conversione del tipo di una o più variabili realizzata in modo automatico dal C per consentire la valutazione di un&#39;espressione. Si tratta di un&#39;operazione rischiosa, in quanto potrebbe comportare la perdita di informazioni delle variabili (ad esempio il passaggio di una variabile di tipo float in int, con conseguente perdita della parte decimale). Essa si contrappone alla conversione esplicita, realizzata &#34;ad hoc&#34; dal programmatore, che permette di gestire le variabili e i tipi nel modo desiderato e più utile per il programma che si sta realizzando.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2790"><question_text>come funziona la conversione da binario a decimale e viceversa?</question_text><answer id="A2916"><answer_text>Per passare da decimale a binario bisognare dividere il numero decimale per 2 fino a che non si arriva a 0, riportando sempre il resto della divisione. Il numero binario, dunque, lo si trova prendendo i numeri del resto dal basso verso l&#39;alto, ovvero dall&#39;ultimo al primo resto della divisione. 
Per il viceversa bisogna prendere il numero binario e moltiplicare ogni membro per la potenza di 2 corrispondente. Ad esempio il primo numero va moltiplicato per 2^0, il secondo per 2^1, il terzo per 2^2, e così via. Alla fine si sommano tutti i risultati e si ottiene il numero in decimale.</answer_text><num_votes>1</num_votes></answer><answer id="A2820"><answer_text>Per convertire un numero binario in decimale si moltiplica ciascuna cifra del numero binario per una potenza di 2 il cui esponente aumenta di 1 procedendo da destra a sinistra, in quanto esso e&#39; in relazione alla posizione della cifra nel numero; infine si sommano i risultati ottenuti. Es. 0011=(0x8 + 0x4 + 1x2 + 1x1)=(2+1)=3. Per convertire un numero decimale in binario si operano successive divisioni per 2 del numero decimale; il risultato e&#39; la sequenza di 0 e 1 ottenuti considerando nell&#39;ordine, dalla cifra meno significativa a quella piu&#39; significativa i resti della divisione. Es.14=1101.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2799"><question_text>Qual è la differenza tra la rappresentazione di un numero binario in virgola fissa e in virgola mobile? Qual è la più vantaggiosa?</question_text><answer id="A2847"><answer_text>la rappresentazione in virgola fissa non fa altro che codificare parte intera tenendo conto del segno e la  parte decimale separandole con una virgola; la rappresentazione in virgola mobile porta tutto sotto la virgola e codifica la parte decimale, moltiplicandola poi per un esponente anch&#39;esso codificato. Viene utilizzata maggiormente la codifica in virgola mobile perche&#39; utilizza spazi fissi riservati a segno, esponente e mantissa ( 1 per il segno, 8 per l&#39;esponente e 23 per la mantissa). </answer_text><num_votes>1</num_votes></answer><answer id="A2881"><answer_text>Nella rappresentazione in virgola fissa, non si fa altro che convertire in binario la parte intera e decimale, poi si uniscono i due, in virgola mobile si usa la notazione scientifica, ovvero si fa la conversione del numero con mantissa ed esponente.
La più vantaggiosa è la virgola mobile perchè utilizzo meglio la memoria.</answer_text><num_votes>0</num_votes></answer><answer id="A2838"><answer_text>Un numero in virgola mobile permette di rappresentare un ampio insieme numerico all&#39;interno di un determinato numero di cifre (appunto per questo è piu vantaggiosa), grazie ad una rappresentazione scientifica normalizzata con l&#39;utilizzo del sistema binario (dunque il fattore di scala è una potenza di 2), cosa che la virgola fissa non concede.</answer_text><num_votes>1</num_votes></answer><answer id="A2792"><answer_text>Con la virgola fissa vengono diversificati i bit che indicano la parte intera da quelli che indicano la parte decimale.Si stabilisce dunque che la virgola sia in una posizione fissa.
Con la virgola mobile una parte dei bit vengono riservati per rappresentare le cifre significative del numero indipendentemente dalla posizione della virgola ed alcuni vengono riservati per stabilire dove va posizionata la virgola. La virgola mobile utilizza lo standard IEEE-754 grazie al quale è possibile rappresentare valori nulli e infiniti o NaN, rendendo la rappresentazione più esaustiva ma più complicata</answer_text><num_votes>0</num_votes></answer><answer id="A2880"><answer_text>Nella rappresentazione in virgola fissa vengono divisi a priori i bit designati a rappresentare la parte intera da quelli per la parte frazionaria.
Nella rappresentazione in virgola mobile, invece, oltre ai bit riservati alle cifre significative del numero (mantissa) ne vengono deputati altri per l&#39;indicazione di dove porre la virgola.
La modalità più vantaggiosa è la seconda, dal momento che in tal modo può essere ponderato lo spazio per la parte intera e quello per la parte frazionaria a seconda delle esigenze, non avendo determinazioni a priori.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2883"><question_text>come posso passare un array per riferimento ad una funzione ? quale è l&#39;intestazione corretta?</question_text><answer id="A2887"><answer_text>Quando un array viene passato a una funzione come parametro formale, l&#39;indirizzo di base dell&#39;array viene passato &#34;per valore&#34; alla funzione. Di fatto si realizza quindi un passaggio di parametro &#34;per indirizzo&#34; il cui effetto finale apparente è che l&#39;array sia passato &#34;per riferimento&#34;. Il parametro formale dichiarato nella testata della funzione viene trattato come puntatore. Supponendo che TipoArray sia definito come:
typedef    double  Tipoarray[MaxNumElem]
un&#39;intestazione corretta è per esempio:
double     sum(double      *a, int     n)    dove n è la dimensione dell&#39;array passato.</answer_text><num_votes>5</num_votes></answer><answer id="A2817"><answer_text>Per passare un array per riferimento ad una funzione, ovvero fare in modo che ogni modifica della funzione al parametro venga visualizzata anche fuori della funzione, basta precedere il nome del parametro con il simbolo &#38;. Quando si passa un array in realtà si passa l&#39;indirizzo del primo elemento dell&#39;array. Il parametro formale viene trattato come un puntatore al primo elemento. Gli elementi dell&#39;array non vengono copiati nel parametro formale.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2814"><question_text>Integral e Floating sono i due grandi insiemi nei quali vengono suddivisi i tipi di dato nel linguaggio C.
Quali sono le caratteristiche di questi due insiemi?
Quali tipi di dato fanno parte del primo insieme e quali tipi sono contenuti nel secondo? </question_text><answer id="A2826"><answer_text>I tipi predefiniti in C vengono raggruppati in due insiemi, che identificano caratteristiche comuni:
-integral, raggruppa i tipi rappresentati in memoria come interi, e che quindi rappresentano un numero discreto di valori compresi nell&#39;insieme dei numeri naturali (fanno dunque parte di questo gruppo i tipi predefiniti int e char, con i loro qualificatori di tipo: unsigned-signed, short-long);
-floating, invece raggruppa i tipi rappresentati in memoria da numeri reali, e che quindi prevedono un numero molto grande di valori tra un numero ed un altro, ne fanno parte: float e (long) double.</answer_text><num_votes>4</num_votes></answer><answer id="A2902"><answer_text>Caratteristiche integral:rappresentano un numero discreto di valori,vi è una corrispondenza biunivoca tra qualsiasi tipo integral e sottoinsieme dei numeri naturali
Caratteristiche floating:concettualmente,il dominio R è un insieme denso:dati due elementi x1 ed x2 del dominio distanziati tra loro di un epsilon piccolo a piacere,esiste sempre un?infinità di valori di R contenuti nell?intervallo[x1,x2].
Tipi integral:
char
signed char
unsigned char
signed short int
signed int
signed long int
unsigned short int
unsigned int
unsigned long int
Floating:
float
double
long double</answer_text><num_votes>0</num_votes></answer><answer id="A2822"><answer_text>Gli integral sono utilizzati per rappresentare i numeri interi e solitamente occupano uno spazio di 2 o 4 byte in memoria. I floating o numeri in virgola mobile sono utilizzati per rappresentare i numeri razionali e solitamente occupano 4 o 8 byte.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2794"><question_text>La codifica ASCII non comprende le lettere accentate. Cosa è necessario fare per utilizzare una codifica differente dalla ASCII, se possibile? Qual&#39;è la codifica necessaria per visualizzare ed utilizzare lettere accentate?  </question_text><answer id="A2886"><answer_text>La codifica necessaria per scrivere lettere accentate è l&#39;ASCII a 8 bit, o extended ASCII.Questa codifica è ormai standard in molti pc.</answer_text><num_votes>1</num_votes></answer><answer id="A2889"><answer_text>Le lettere accentate come la &#39;è&#39;, nella codifica ascii hanno un codice superiore a 127, quindi fanno
parte della tabella ascii estesa, che al contrario di quella standard
(caratteri da 0 a 127 compresi), spesso variano.Una semplice risoluzione del problema è la sostituzione delle lettere accentate con vocali &#34;apostrofate&#34; come &#34; e&#39; &#34; al posto di &#34;é&#34;.</answer_text><num_votes>2</num_votes></answer><answer id="A2872"><answer_text>Avendo a disposizione solo 128 caratteri vengono esclusi moltissimi simboli tra cui le lettere accentate. Infatti tempo fà, nelle pagine web, per inserire caratteri non compresi nella codifica ASCII era necessario usare le così dette ENTITÀ HTML, cioé caratteri preceduti da&#39;&#38;&#39;. questo era molto scomodo nel momento che si doveva scrivere qualcosa in lingue diverse dall&#39;inglese. Infatti parte di queste entità divennero inutili con l&#39;estensione della codifica ASCII. Venne definito l&#39;ASCII ESTESO che usa 256 numeri (8bit per carattere, usando l&#39;ottavo bit dell&#39;ASCII senza lasciarlo inutilizzato; c</answer_text><num_votes>1</num_votes></answer><answer id="A2922"><answer_text>È possibile modificare la codifica dei caratteri, per farlo non vi sono istruzioni univoche ma dipendono dal browser che viene utilizzato
La codifica ASCII è la più diffusa ed è consigliabile risolvere il problema delle lettere accentate utilizzando gli apici, tuttavia se si volesse cambiare totalmente codifica la miglior sostituta potrebbe essere la UTF-8.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2914"><question_text>Cosa si intende per tipo di dato astratto e perché si differenzia dagli altri?</question_text><answer id="A2777"><answer_text>I tipi di dati astratti sono di vario tipo e in generale determinano, come interpretare un insieme di bit in memoria,
quanta memoria riservare a una variabile in funzione del suo tipo e permettono di trovare &#34;errori tipo&#34; in fase di compilazione. Esistono 4 tipi di tipo:
-semplice (int, float, char);
-strutturati (array, matrici);
-predefiniti nel linguaggio di programmazione usato;
-definiti dal programmatore attraverso azioni di typedef o strcut (per il linguaggio c).</answer_text><num_votes>1</num_votes></answer><answer id="A2782"><answer_text>Un tipo di dato astratto (ADT) è una particolare informazione, rappresentata nel calcolatore, di cui è noto il modo di interpretarla e manipolarla. Da ciò si evince che lo stesso valore rappresentato in un calcolatore può essere interpretato in maniera differente a seconda del tipo di dato che gli viene associato. Ad es. un carattere ASCII, un integer o un floating, che a livello di memoria sono rapprentati mediante una sequenza di bit uguali, ma rappresentano informazioni completamente differenti. Non è sufficientemente chiaro per rispondere, cosa si intende per altri tipi!</answer_text><num_votes>2</num_votes></answer><answer id="A2770"><answer_text>Linguaggi di programmazione di alto livello trattano tipi di dato astratti cioè un insieme di valori e operazioni che mediante codifica non corrispondono ai dati trattati concretamente dalla macchina.  Per un programmatore è fondamentale l&#39;utilizzo di tipi di dato astratti perché è possibile trattare l&#39;informazione a prescindere dal modo concreto con il quale essa è rappresentata all&#39;interno della macchina.</answer_text><num_votes>0</num_votes></answer><answer id="A2831"><answer_text>Un tipo di dato astratto (ADT) è un tipo di dato che segue un modello matematico che include le operazioni definite in esso. Si differenzia dagli altri tipi di dato perchè ha un&#39;allocazione dinamica in memoria, e quindi un&#39;efficienza maggiore nella memorizzazione (vengono riservati spazi in memoria solo ai dati effettivamente utilizzati).</answer_text><num_votes>0</num_votes></answer><answer id="A2766"><answer_text>La principale differenza sta nel fatto che un tipo di dato astratto è riconosciuto dall&#39;utente ma non dal compilatore;
infatti quando lo si &#34;costruisce&#34; bisogna associarli (con typedef) un tipo dato riconosciuto dal compilatore.
ES: typedef int intero;
Diciamo al compilatore che intero(riconosciuto dall&#39;utente) è un &#34;sinonimo&#34; di int(riconosciuto dal compilatore).</answer_text><num_votes>1</num_votes></answer></question><question id="Q2819"><question_text>cosa significa fare il complemento a n (n numero naturale) di un certo numero e come si fa?</question_text><answer id="A2772"><answer_text>Il complemento ad 1 e a 2 (non ne esistono altri) vengono utilizzati per rappresentare in codice binario i numeri negativi. Il complemento a 1 si ottiene sommando al numero positivo in binario una maschera di soli &#34;1&#34;, ottenendo così il corrispondente numero negativo. Questo metodo crea però il problema del doppio zero: questo infatti verrebbe identificato in due modi diversi. Con il complemento a 2 si somma un ulteriore &#34;1&#34; al numero binario ottenuto col complemento a 1, eliminando così il problema. (Si parla di somme in binario)
Esempio: 0(dec)=0000 0(dec)=1111(compl.1) 0(dec)=0000(compl.2)</answer_text><num_votes>1</num_votes></answer><answer id="A2824"><answer_text>In informatica si utilizzano fondamentalmente il complemento a 1 e a 2 come metodi per rappresentare dati interi relativi
Il complemento a uno si esegue invertendo tutti i bit della parola:
00001001=9; 11110110=-9
Questo metodo è imperfetto in quanto prevede due rappresentazioni del numero 0
Il complemento a 2 si esegue praticando il complemento a uno ed aggiungendo 1 a operazione completata
00001001=9; 11110111=-9
Questo metodo è il più usato in quanto semplifica notevolmente le operazioni di somma e differenza usando il primo bit come indicatore del segno</answer_text><num_votes>1</num_votes></answer><answer id="A2910"><answer_text>Il complemento è utilizzato per rappresentare i numeri con segno e solitamente viene utilizzato sui numeri binari.Il complemento a n di un numero si fa invertendo tutti i bit del numero stesso (in altre parole sostituendo gli 0 con gli uni e viceversa) e sommandogli n-1.In particolare nel complemento a 1 inverti solo i bit senza sommargli niente, nel complemento a 2 inverti i bit e sommi uno nel complemento a 3 inverti i bit e sommi 2 ecc.Solitamente i più utilizzati sono il complemento a 1 e a 2. 
(5 in compl a 2)
5-&#62;0000 0101-&#62;compl a 1-&#62;1111 1010-&#62;compl a 2-&#62;1111 1011 (-5 in compl a 2)
 </answer_text><num_votes>3</num_votes></answer></question><question id="Q2899"><question_text>Quali sono le differenze tra la codifica in virgola mobile e la codifica in virgola fissa?</question_text><answer id="A2899"><answer_text>La codifica in virgola fissa rappresenta un numero (ad esempio) a 8 bit con 4 bit riservati alla parte intera e altri 4 bit per la parte frazionaria.
La codifica in virgola mobile invece rappresenta un numero (ad esempio) di 32 bit con la notazione +-m*2^e. Il primo bit più significativo indica il segno (+ o -), i successivi 8 codificano l&#39;esponente &#34;e&#34; in complemento a due e i restanti 23 rappresentano la mantissa (m). In sostanza la mantissa rappresenta tutte le cifre del numero mentre l&#39;esponente indica la posizione della virgola. </answer_text><num_votes>3</num_votes></answer><answer id="A2804"><answer_text>Sui numeri a virgola mobile è possibile rappresentare un ampio insieme di valori, maggiore a quello della virgola fissa a parità di memoria. Tuttavia i numeri a virgola fissa sono utilizzati dove serve maggior precisione; Questo perché con la virgola mobile si riscontrano problemi di arrotondamenti, assorbimento di valori (esempio 10^15 + 1 = 10^15) e impossibilità di rappresentazione. Ad esempio il valore 0.1 è impossibile da avere con i numeri a virgola mobile in maniera esatta e non arrotondata. In alcuni settori quale quello finanziario si devono evitare il più possibile questi errori. </answer_text><num_votes>1</num_votes></answer><answer id="A2800"><answer_text>Nella codifica a virgola fissa i bit disponibili vengono divisi per rappresentare la parte intera e quella frazionaria, ovvero la virgola ha la posizione fissa. Viceversa nella codifica a virgola mobile una larga parte dei bit viene usata per rappresentare le cifre significative, mentre i rimanenti vengono usati per stabilire la posizione della virgola. Pag.6 Cap 4.5</answer_text><num_votes>0</num_votes></answer><answer id="A2923"><answer_text>Nella codifica a virgola fissa, i bit vengono divisi in maniera costante tra la parte intera e la parte frazionaria mentre nelle codifiche a parte mobile i bit vengono frazionati tra quelli rappresentanti le cifre significative e quelli volti a stabilire la posizione che avrà la virgola.</answer_text><num_votes>0</num_votes></answer><answer id="A2780"><answer_text>Nella codifica a virgola fissa il numero viene diviso in due parti, la parte intera e la parte decimale, quindi se abbiamo 8 bit a disposizione, i primi 4 rappresentano la parte intera mentre gli altri la parte decimale. Es. (0101.0011)BIN-&#62;(5.1875)DEC
Con la conversione a virgola mobile (floating point) il numero occupa 32 bit, suddivisi in una maniera specifica.
il bit a sinistra (MSB) rappresenta il segno, gli atri 8 l&#39;esponente e gli altri 23 la mantissa.
codificando il numero in decimale otteniamo che il numero è dato dalla formula: x=±m*2^e con m&#60;1.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2816"><question_text>Perchè gli interi positivi al calcolatore non possono avere un numero molto grande(tendente a infinito)? Qual è il valore massimo? Come viene espresso?</question_text><answer id="A2863"><answer_text>Gli interi gestibili da un calcolatore non possono assumere numeri molto molto grandi (tendenti ad infinito) perché la memoria e le risorse a disposizione del calcolatore sono finite. Queste due cose limitano i valori che i calcolatori possono maneggiare. In C/C++ un intero positivo (detto unsigned int) può assumere come valore massimo 4.294.967.295. Questo valore è ottenuto facendo ((2^32)-1): 2^32 perché la codifica è a 32 bit mentre si fa meno uno perché va tolto lo 0 (questo perché vogliamo ottenere il valore massimo e non il numero di combinazioni possibili).</answer_text><num_votes>4</num_votes></answer><answer id="A2834"><answer_text>i calcolatori non possono avere un numero grande tendente ad infiito, perchè hanno una grandezza predefinita(massima). il valore massimo intero di un calcolatore è:
con segno da &#38;#8722;2.147.483.648 a +2.147.483.647
Senza segno: da 0 a +4.294.967.295
queste informazioni si possono anche trovare nella libreria stdlib.h</answer_text><num_votes>0</num_votes></answer></question><question id="Q2800"><question_text>Come si converte un numero in base ottale a un numero in base esadecimale? Fai un esempio.</question_text><answer id="A2852"><answer_text>Per convertire un num da base8 a b16 si può procedere utilizzando la b2 cm perno di passaggio
Una cifra nel sistema ottale (0..7) espressa in sistema binario al max sarà composta da 3 cifre (0..111)
Per ogni cifra in b8 andrò quindi a riservare 3 posti in b2
3 b6 -&#62;011 b2
es
  3    4     1   b8
011 100 001  b2 
341 b8 -&#62;011100001 b2
Ora il num in b16 sarà dato raggruppando 4 a4  partendo da dx le cifre del num binario e esprimendone il valor (tra 0-15) con il corrispondente simbolo in base esadec: 1110 b2 -&#62;14 b10 -&#62; e b16
1110 0001 b2
  e       1   b16
341 in b8 = a e1 in b16
</answer_text><num_votes>1</num_votes></answer><answer id="A2759"><answer_text>Un numero ott viene convertito in un numero esa attraverso due passaggi:conversione del numero in base ott in un numero in base dec e conversione del numero dec ottenuto in un numero in base esa. Ad esempio il numero 2370 in base ott diventa 1272 in base dec, che diventa 4F8 in base esa. Il passaggio da ott a dec si ottiene moltiplicando, dall&#39;ultima alla prima cifra, la cifra in questione per 8^n, con n posizione della cifra partendo dalla cifra più a destra;il passaggio da dec a esa si ottiene dividendo il numero dec per 16 e leggendo i resti dall&#39;ultimo al primo ottenendo il numero esa.</answer_text><num_votes>0</num_votes></answer><answer id="A2912"><answer_text>Un modo può essere trasformando il numero da base 8 a base 2 e poi riconvertirlo a base 16. Per esempio: 64752 -&#62; 110 100 111 101 010  Raggruppo i bit ottenuti a 4 a 4, a partire da destra (aggiungo uno zero a sinistra) e ottengo:  0110 1001 1110 1010 -&#62; 6 9 E A</answer_text><num_votes>0</num_votes></answer><answer id="A2898"><answer_text>Per convertire un numero da base ottale a base esadecimale sono possibili due soluzioni (si potrebbe anche utilizzare una trasformazione diretta utilizzando però basi non decimali e quindi di difficile applicazione):
1. trasformazione da base ottale a base decimale e successivamente a base esadecimale
 es: 203(8)-&#62; (2*8^2+0*8^1+3*8^0) =131(10) -&#62; 83(16)
2. trasformazione da base ottale a base binaria  e successivamente a base esadecimale. Questa è inoltre la procedura più usata nei calcolatori.
 es: 208(8)-&#62;10000011(2) -&#62; 83(16)</answer_text><num_votes>4</num_votes></answer></question><question id="Q2806"><question_text>qual&#39;è l&#39;algoritmo di conversione da un numero binario a uno decimale?</question_text><answer id="A2853"><answer_text>L&#39;algoritmo di conversione da un numero binario a uno decimale è descritta da una sequenza d&#39;istruzioni logiche costituite da questi 6 passaggi : 1) Porre a zero le variabili di conto N=0 e n=0. 2)Posizionarsi alla destra del numero. 3)Leggere il carattere seguente a sinistra. 4)Se il carattere è vuoto, fermarsi ( le cifre sono finite ). 5)Sommare ad N il valore 2n moltiplicato per la cifra alla posizione n ed incrementare n di 1. 6)Tornare al passo 3 e ripetere le istruzioni successive.</answer_text><num_votes>0</num_votes></answer><answer id="A2758"><answer_text>Per convertire un numero binario in un numero decimale basta seguire questo algoritmo:
Il numero binario puo&#39; essere visto come un array, dove ogni cifra (1 o 0) corrisponde ad una cella di un array. Ora e&#39; necessario moltiplicare ogni cifra del numero binario (quindi ogni cella dell&#39;array), per 2^n, dove n e&#39; la posizione della cifra nell&#39;array (ricordandosi che la prima cella dell&#39;array corrisponde ad n=0). Una volta fatto ciò non resta che sommare i risultati di tali moltiplicazioni tra loro, la somma darà il numero binario convertito in base decimale.</answer_text><num_votes>2</num_votes></answer><answer id="A2839"><answer_text>Dato un numero binario restituire la rappresentazione in base decimale di tale numero.
Per trovare l&#39;algoritmo risolutivo del problema è necessario procedere con una serie moltiplicazioni per due (2) elevato ad un valore che dipende dalla posizione del bit nell?array, sommando tra loro i diversi contributi legati ai bit dell?array binario, poi stampare il risultato di tale somma. 
Riporto di seguito un esempio di risoluzione:

int n=8;
int bin[8]={1,0,0,0,0,0,1,1};
int i, dec=0;
for (i=0;i&#60;n;i++){
     dec = dec + NumBin[n-1-i] * exp(log(2)*i));
}</answer_text><num_votes>2</num_votes></answer></question><question id="Q2826"><question_text>che cos&#39;è l&#39;overflow? quando si manifesta?</question_text><answer id="A2866"><answer_text>E&#39; un errore dovuto alla memorizzazione di dati in uno spazio insufficiente a contenerli. Ciò causa la memorizzazione sbagliata dei dati. Per esempio se si usa una codifica a 6 bit, dove il bit più significativo indica il segno, e si fa la somma tra 011010 e 011111, risulta 111001 dove il primo 1 viene letto come segno anziché come 1*2^5, quindi il risultato è un numero diverso in modulo e anche in segno. </answer_text><num_votes>1</num_votes></answer><answer id="A2823"><answer_text>La traduzione esatta è &#34;traboccamento&#34; e si manifesta quando, effettuando delle operazioni aritmetiche, il risultato è troppo grande per essere memorizzato e supera lo spazio che il programmatore aveva messo a disposizione per il risultato stesso.</answer_text><num_votes>2</num_votes></answer><answer id="A2810"><answer_text>L&#39;overflow si verifica quando il risultato di un&#39;operazione supera il numero massimo rappresentabile dal calcolatore. Ad esempio se ho un dato a di 8 bit che vale 255 (11111111) , facendo a+1 il risultato non potrà essere 256 (100000000) perché servono 9 bit per rappresentarlo. In quel caso solitamente il calcolatore tiene gli ultimi 8 bit quindi 255+1 = 0</answer_text><num_votes>1</num_votes></answer><answer id="A2776"><answer_text>l&#39;overflow si manifesta quando cerchiamo di occupare più spazio di quello disponibile nell&#39;allocazione di memoria in cui stiamo scrivendo i nostri dati. Si manifesta soprattutto nella gestione degli array poichè, per quanto visto fin&#39;ora, la grandezza degli array è statica una volta dichiarata; ciò presuppone che il programmatore conosca esattamente quale sarà la funzione di quell&#39;array. In caso contrario, potremmo trovarci di fronte ad un array troppo piccolo andando cosi incontro all&#39;errore di overflow</answer_text><num_votes>0</num_votes></answer></question><question id="Q2873"><question_text>Spiegare cos&#39;è la codifica in virgola mobile e come funziona.</question_text><answer id="A2869"><answer_text>La codifica a &#34;virgola mobile&#34;  una tecnica per rappresentare i numeri che hanno una parte frazionaria.
Nella codifica a virgola mobile si dividono i bit utilizzati in due parti: la maggioranza dei bit sono riservati per rappresentare le cifre significative del numero ed alcuni bit servono per stabilire dove va posizionata la virgola.
Lo standard per presentare numeri frazionari in virgola mobile in 32 bit è il seguente:
-il primo bit codifica il segno
-i sucessivi 8 codificano l&#39;esponente e in CA2
-gli ultimi 23 codificano la mantissa m (senza segno).</answer_text><num_votes>1</num_votes></answer><answer id="A2924"><answer_text>La rappresentazione in virgola mobile utilizza la notazione esponenziale per la codifica dei numeri reali. Ad esempio nello standard IEEE 754-1985 con rappresentazione su 32 bit, ciascun numero reale viene rappresentato con un bit per il segno, 8 bit per la caratteristica e 23 bit per la mantissa. La caratteristica è il numero usato come esponente mentre la mantissa è un numero compreso tra 0 e 1. Con questa codifica è possibile rappresentare anche caratteri speciali come il risultato di operazioni non ammesse come la divisione per zero, e i valori più infinito e meno infinito.</answer_text><num_votes>3</num_votes></answer><answer id="A2791"><answer_text>La codifica in virgola mobile è un modo di rappresentare i numeri frazionari la cui caratteristica è quella di riservare parte dei bit per rappresentare le cifre significative (m) e un altra parte per stabilire la posizione della virgola. Lo standard per codificare un numero in virgola mobile in 32 bit è il seguente: il primo bit per il segno, i successivi 8 per l&#39;esponente &#34;e&#34; in CA2, che servirà per spostare la virgola, e i successivi 23 bit per la mantissa &#34;m&#34; senza segno e con valore inferiore a 1. Il numero verrà codificato come +-m*2^e.</answer_text><num_votes>1</num_votes></answer><answer id="A2896"><answer_text>La codifica in virgola mobile è un modo di rappresentare in modo opportuno i numeri frazionari (con la virgola appunto). In pratica, dei bit necessari per rappresentare tale numero, una grande parte viene dedicata alle cifre significative (MANTISSA), un solo bit posto all&#39;inizio determina se il numero è positivo o negativo (SEGNO), e una piccola serie di bit stabilisce la posizione della virgola nel numero (ESPONENTE). Ci sono 2 metodi di risoluzione:
- l&#39;ESPONENTE determina gli spostamenti della virgola
- l&#39;ESPONENTE deve essere elevato al numero 2 e il tutto moltiplicato alla mantissa.
</answer_text><num_votes>0</num_votes></answer><answer id="A2874"><answer_text>La codifica in virgola mobile è utile nel rappresentare cifre molto grandi o molto piccole per evitare uno spreco inutile di celle di memoria. Dal punto di vista sintattico la rappresentazione in virgola mobile consiste in due parti: la mantissa e l&#39;esponente in base 10, separati dal carattere &#34;E&#34;.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2812"><question_text>Per quale ragione la codifica a virgola mobile è preferibile alla codifica a virgola fissa?</question_text><answer id="A2797"><answer_text>E&#39; sicuramente più vantaggiosa la rappresentazione a virgola mobile la quale permette di esprimere numeri molto grandi con poche cifre e con precisione numeri molti piccoli. Nella rappresentazione a virgola mobile si utilizzerà una notazione esponenziale a 32 bit dove il 1 bit indicherà il segno, 8 bit l&#39;esponente, detto caratteristica, che indicherà la posizione della virgola e infine 23 bit la mantissa che rappresenta le cifre più rappresentative del numero.</answer_text><num_votes>1</num_votes></answer><answer id="A2883"><answer_text>La codifica a virgola mobile viene solitamente preferita rispetto a quella a virgola fissa in quanto quest&#39;ultima
limita il numero di cifre intere e decimali. Ne consegue quindi una precisione decimale davvero ridotta (anche
quando il numero intero è molto piccolo). Nella codifica a virgola mobile, invece, se il numero ha una parte intera
piccola e molte cifre decimali, queste ultime possono occupare i bit che nella codifica in virgola fissa sarebbero 
occupati dalla parte intera (che sarebbe preceduta da zeri, senza quindi essere utilizzata &#34;convenientemente&#34;). </answer_text><num_votes>3</num_votes></answer><answer id="A2815"><answer_text>Un modo di rappresentare un valore di tipo reale è la normale rappresentazione decimale, detta in virgola fissa. Questa rappresentazione diventa dispendiosa, in termini di capacità di memoria e di rappresentazione grafica per valori molto grandi o molto piccoli. è preferibile la codifica a virgola mobile poiché permette di rappresentare con poche cifre numeri molto grandi oppure di rappresentare con precisione numeri molto piccoli, attraverso mantissa ed esponente.</answer_text><num_votes>0</num_votes></answer><answer id="A2774"><answer_text>Perchè con la codifica a virgola mobile è possibile codificare un range molto più elevato di valori (molto piccoli e/o grandi) andando a lavorare non su un numero limitato di bit per la parte intera e per la parte decimale (virgola fissa), ma lavorando su segno, mantissa (ossia le cifre significative del numero) ed esponente, che dice in quale posizione spostare la virgola.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2831"><question_text>Descrivere l&#39;utilità e il funzionamento della codifica complemento a 2 (CA2).</question_text><answer id="A2907"><answer_text>il complemento a due è un sistema di conversione molto utilizzato in abito elettronico, infatti ha il vantaggio di eliminare la risonanza dello zero ( elimina gli zeri multipli nelle diverse rappresentazioni di un numero binario). , La codifica in complemento a due è infine largamente utilizzata in elettronica poichè molti circuiti sommatori utilizzano questa conversione per operare in modo più rapido ( ad esempio l&#39;ALU)</answer_text><num_votes>0</num_votes></answer><answer id="A2846"><answer_text>È il metodo più diffuso per la rappresentazione dei numeri con segno in informatica. La sua enorme diffusione è data dal fatto che i circuiti di addizione e sottrazione non devono esaminare il segno di un numero rappresentato con questo sistema per determinare quale delle due operazioni sia necessaria, permettendo tecnologie più semplici e maggiore precisione. Il bit iniziale del numero ha peso negativo (1) o positivo (0). Prendendo il complementare e aggiungendo 1 al numero binario risultante si può così ottenere il valore assoluto di un numero binario negativo.</answer_text><num_votes>1</num_votes></answer><answer id="A2914"><answer_text>Il complemento a 2 è il complemento più utilizzato e più semplice per rappresentare numeri binari sia positivi che negativi. Questo è possibile poichè l&#39;informazione del segno stesso è inclusa nei bit del numero e per questo motivo basta solo l&#39;operatore &#34;addizione&#34; per effettuare sia le operazioni di addizione che quelle di sottrazione. Per ottenere un numero rappresentato in CA2, basta leggere il numero da destra verso sinistra e invertire tutte le cifre a partire dal primo bit uguale a 1 (escluso).</answer_text><num_votes>3</num_votes></answer></question><question id="Q2955"><question_text>quali operazioni si possono applicare alle variabili costruite mediante struct (non ai singoli campi)?</question_text><answer id="A2904"><answer_text>Operazioni applicabili a variabili di tipo struct:
1. accesso ai singoli campi della variabile mediante dot notation;
2. definizione di un puntatore all&#39;intera variabile struct;
3. definizione di un puntatore ad un campo della variabile struct.</answer_text><num_votes>1</num_votes></answer><answer id="A2917"><answer_text>Le variabili costruite mediante struct possono contenere informazioni eterogenee (di tipo diverso: numerico, stringa...) di conseguenza è possibile operare su di essere in vario modo tenendo conto per l&#39;appunto la differenza del tipo informazione. Il modo in cui vengono definite queste variabili non può essere modificato all&#39;interno del main, queste variabili rimangono le stesse all&#39;interno di tutto il programma. I campi all&#39;interno della struct possono essere richiamati mediante il &#34;.&#34;(es: agenda.evento) e su queste possono essere svolte le operazioni di inizializzazione, stampa e così via...</answer_text><num_votes>1</num_votes></answer><answer id="A2825"><answer_text>La domanda non ha senso.</answer_text><num_votes>0</num_votes></answer><answer id="A2813"><answer_text>Le operazioni che si possono applicare alle strutture sono la copia, l&#39;assegnazione come unico oggetto, la manipolazione tramite l&#39;accesso ai suoi campi, l&#39;inizializzazione tramite una lista di valori costanti, l&#39;indirizzamento tramite l&#39;operatore &#38;, il passaggio di strutture dalle funzioni e il ritorno da esse. Non possono invece, le funzioni, essere confrontate.</answer_text><num_votes>1</num_votes></answer><answer id="A2818"><answer_text>Struct e&#39; un tipo di dato definito dal programmatore, e&#39; detto user-defined type ed assolve la funzione di raggruppare informazioni eterogenee tra loro. Le operazioni che possono essere compiute sulle variabili di tipo &#34;struct&#34; sono: l&#39;assegnazione di una variabile ad un&#39;altra mediante la copia del contenuto (se e solo se sono dello stesso tipo); l&#39;accesso ai vari campi attraverso la dot notation; l&#39;indicazione dell&#39;indirizzo di una variabile attraverso &#34;&#38;&#34;; l&#39;impossibilita&#39; di effettuare il confronto tra due variabili di tipo struttura e la definizione di una variabile come un puntatore.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2813"><question_text>Immagina di avere bisogno di convertire un numero in base 22.
Scrivi la conversione del numero 1589 (scritto in base 10), e come fare a convertirlo.</question_text><answer id="A2819"><answer_text>Per convertire qualsiasi numero dalla base decimale ad un altra basa bisogna dividere il numero dato per la base in cui lo dobbiamo convertire e scrivere i resti.
Una volta ottenuti i resti si scrive il numero nella base desiderata partendo dall&#39;ultimo resto ottenuto al primo.
Prendendo in esame la conversione di 1589 in base 22 si divide il numero per 22 e si ottengono i resti (5,6,3).
Quindi invertendo la posizione dei resti, quindi la prima cifra corrisponde all&#39;ultimo resto, si ottiene il numero in base 22: (365)in base 22. </answer_text><num_votes>1</num_votes></answer><answer id="A2799"><answer_text>1589/22=72 con resto 5
72/22=3 con resto  6
3/22= 0 con resto 3

1589 in base 10 e quivale ad 365 in base 22
</answer_text><num_votes>0</num_votes></answer><answer id="A2841"><answer_text>si deve dividere per 22 1589:
1589:22= 72   resto 5
72:22= 3      resto 6
3:22= 0       resto 0

si considerano i resti dal basso verso l&#39;alto quindi 1589, convertito in base 22 è 065</answer_text><num_votes>0</num_votes></answer><answer id="A2768"><answer_text>Il risultato della conversione è 365 in base 22. 
Per convertire un numero intero da decimale ad un&#39;altra base bisogna dividere tale numero per la base conservando il resto e dividendo ancora per la base fino ad avere il risultato nullo. I resti ottenuti a partire dall&#39;ultimo sono proprio le cifre che rappresentano nella nuova base il numero decimale di partenza.
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2928"><question_text>Come mai per rappresentare numeri interi si adottano le rappresentazioni in complemento e non si utilizzano scritture in cui semplicemente si utilizza il primo bit per il segno e i successivi per il numero?</question_text><answer id="A2903"><answer_text>Le rappresentazioni in complemento sostituiscono quelle di rappresentazione con segno esplicito perché, pur essendo meno intuitive hanno dei vantaggi: non vi è una doppia codifica per il valore zero (infatti avrebbe significato diverso a seconda che si trovi nella prima o nelle altre posizioni) e non è richiesta una circuiteria specifica per il trattamento del segno infatti nella codifica a complemento l?operazione sottrazione viene fatta eseguendo un?addizione.</answer_text><num_votes>1</num_votes></answer><answer id="A2925"><answer_text>Non hanno una doppia codifica per il valore &#34;zero&#34; e non richiedono una circuiteria specifica per il trattamento del segno</answer_text><num_votes>1</num_votes></answer><answer id="A2867"><answer_text>La rappresentazione in complemento è il metodo più diffuso per la rappresentazione dei numeri con segno in informatica. Il suo aspetto più importante è dato dal fatto che i circuiti di addizione e sottrazione non devono esaminare il segno di un numero rappresentato per determinare quale delle due operazioni sia necessaria si utilizza un solo circuito, il sommatore, sia per l&#39;addizione che per la sottrazione. Inoltre consente di avere un&#39;unica rappresentazione dello zero(quando tutti i bit sono zero) e di operare addizione e sottrazione sempre avendo il primo bit a indicare il segno.</answer_text><num_votes>2</num_votes></answer><answer id="A2789"><answer_text>Si utilizza il complemento perché elimina il problema della doppia rappresentazione dello 0 e della necessità di una circuiteria specifica per la gestione del segno e una semplificazione dei calcoli.Il più utilizzato è il complemento a 2, dove per la rappresentazione dei numeri si invertono i valori di ogni bit e a questo &#34;risultato&#34; Si aggiunge 1, eliminando poi eventuali resti.Esiste anche il complemento a 1, simile al precedente, ma semplicemente si invertono tutti i bit senza l&#39;aggiunta di uno.In questo metodo però troviamo ancora il problema della doppia rappresentazione dello 0. </answer_text><num_votes>1</num_votes></answer></question><question id="Q2830"><question_text>Quando si progetta un programma che deve funzionare su diverse macchine, perché occorre verificare quanti byte vengono dedicati alla variabile di tipo intero?</question_text><answer id="A2842"><answer_text>Occorre sapere in che modo viene codificata una variabile di tipo int perché, a seconda dell&#39;architettura e del sistema operativo della destinazione, il valore massimo assegnato alla variabile potrebbe cambiare e potrebbe essere necessario effettuare modifiche e adattamenti.</answer_text><num_votes>0</num_votes></answer><answer id="A2794"><answer_text>È necessario verificare quanti byte vengono dedicati ad una variabile di tipo intero per avere una cognizione del &#39;range&#39; dei valori disponibili e poiché le operazioni su sitemi a 64 e 32 bit avvengono in maniera diversa.</answer_text><num_votes>0</num_votes></answer><answer id="A2888"><answer_text>Siccome a seconda dell&#39;architettura della macchina (hardware) è possibile avere un diverso numero di bits, al giorno d&#39;oggi si utilizzano pc con architettura a 64 bits quindi significa che i numeri che posso &#34;fisicamente&#34; rappresentare sono compresi tra 0 e 2*10^64-1 (senza segno!!), mentre per una macchina a 32 bits i valori variano tra 0 e 2*10^32-1 (senza segno). Con entrambe le architetture (64 e 32 bits) è possibile fare le stesse cose (a discapito della velocità), ad esempio tramite soluzioni software posso rappresentare numero più grandi di 2*10^32-1 anche su un architettura a 32 bits.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2855"><question_text>A cosa serve il costrutto &#34;Typedef&#34; e dove si colloca nel programma?</question_text><answer id="A2757"><answer_text>La funzione typedef serve per definire nuovi tipi di dato per esempio:
typedef char carattere;
associa il tipo char a carattere quindi poi potrò scrivere sempre:
carattere lettera;
carattere lettera2;
che sarà equivalente a scrivere:
char lettera;
char lettera2;
col typedef &#34;char&#34; viene sostituito completamente dalla parola &#34;carattere&#34; , serve e si usa soprattutto nei programmi complessi a fare meno confusione.
Si scrive nella prima riga sotto il main quando si definiscono le variabili da usare per il programma.
</answer_text><num_votes>1</num_votes></answer><answer id="A2756"><answer_text>Il costrutto typedef e&#39; utilizzato per dare un &#34;nome&#34; a un tipo di dato del C. Ci sono dei casi particolari in cui questo costrutto risulta molto utile: 
- programmi in cui vi sono dei tipi dipendenti dalla macchina
- programmi in cui occorre utilizzare molte struct e parametri puntatori
Nel programma viene collocato tra la dichiarazione delle costanti e tra la dichiarazione delle variabili.</answer_text><num_votes>1</num_votes></answer><answer id="A2828"><answer_text>Il costrutto &#34;typedef&#34; viene utilizzato ogni qual volta che si vuole definire un nuovo tipo utilizzando però il nome di un tipo già esistente nel programma. Esso risulta utile sopratutto quando il programma utilizza diverse &#34;struct&#34; e puntatori.
&#34;typedef&#34; viene collocato all&#39;inizio del programma, prima del main ().
Struttura: typedef tipoesistente nuovotipo;</answer_text><num_votes>1</num_votes></answer></question><question id="Q2921"><question_text>Cosa accade se eseguo un&#39;operazione fra un operando di tipo int e uno di tipo float?</question_text><answer id="A2900"><answer_text>Se si opera un tipo di dato Int, che per i suoi 2 Byte di memoria rappresenta un Intero,
con un dato Float di 4 Byte, che rappresenta un numero Razionale, o meno propriamente un numero reale,
il linguaggio C non avverte alcun errore, ma esegue un assegnamento, cioè una conversione automatica del tipo.
L&#39;assegnamento converte il tipo a dx dell&#39;uguale nel tipo a sx (a[int] = c[float] c-&#62;a).
Ciò può causare troncamenti, quindi perdita di informazioni, e trasformazioni indesiderate.
Una conversione implicita  trasforma il tipo inferiore nel superiore, secondo la regola per cui int&#60;float.</answer_text><num_votes>1</num_votes></answer><answer id="A2761"><answer_text>Se vengono eseguite operazioni tra elementi di tipi eterogenei (come int e float), la variabile di tipo inferiore deve essere convertita temporaneamente nel tipo superiore secondo la seguente gerarchia:
int&#60;long&#60;unsigned&#60;unsigned long&#60;float&#60;double&#60;long double
Nel caso di operazione tra int e float la variabile int viene convertita temporaneamente in float.
Il risultato dell&#39;operazione sarà del tipo superiore, in questo caso float.</answer_text><num_votes>1</num_votes></answer><answer id="A2840"><answer_text>Dipende di che tipo è la variabile che tiene il risultato dell&#39;operazione.
Nel caso della sommatoria fra una variabile float e una variabile int: con la variabile del risultato di tipo int, avrò per risultato un intero; altrimenti con la variabile di tipo float avrò come risultato un numero con la virgola.</answer_text><num_votes>0</num_votes></answer><answer id="A2873"><answer_text>Un operando è float: il tipo int verrebbe trasformato in float e l&#39;operazione risulterebbe float.

In generale nella valutazione gli operandi riferiti ad uno stesso operatore vengono convertiti a un tipo comune seguendo queste regole in ordine:
Se 1 degli operandi e&#39; long double l&#39;altro viene convertito in un long double
Se 1 e&#39; double l&#39;altro viene convertito in double
Se 1 e&#39; float l&#39;altro viene convertito in float
Altrimenti su entrambi viene eseguita la trasformazione a interi in una sequenza che in questo caso non ci interessa e non riuscirei a scrivere per la limitaz caratteri</answer_text><num_votes>1</num_votes></answer></question><question id="Q2803"><question_text>Come è possibile definire un nuovo tipo di dati? Descrivine la procedura</question_text><answer id="A2868"><answer_text>Definire un tipo dato può essere utile nel caso in cui avessimo molte variabili definite con lo stesso tipo: così come int inizializza una variabile intera, si possono inizializzare variabili che contengono al loro interno una struct. Ad esempio, se voglio definire un tipo dati di una struct contenente tre variabili di tipo intero dovrò scrivere prima del main:

typedef struct { int peso; int altezza; int eta} Identikit;

poi nel main dovremo inizializzare a:

Indentikit a;

In questo modo, la variabile a sarà un tipo dato di identikit e sarà gestita come una struct di 3 variabili.</answer_text><num_votes>0</num_votes></answer><answer id="A2901"><answer_text>Nel C possiamo ridefinire tipi già esistenti o definire nuovi tipi (user-defined types) attraverso il comando typedef. Se si vuole ridefinire un tipo già esistente si deve digitare l&#39;istruzione typedef seguita dal tipo di dato e dal nuovo nome che si vuole assegnare. Se si vuole invece definire un nuovo tipo dopo typedef segue il tipo di dato complesso (struct, bit-field, union, enumeration), il nome del nuovo tipo (facoltativo) e le parentesi graffe. Nel caso di struct all&#39;interno delle parentesi si possono trovare variabili di tipo diverso, nel caso di enumeration una sequenza di numeri.</answer_text><num_votes>1</num_votes></answer><answer id="A2862"><answer_text>La funzione che permette di generare un nuovo tipo di dati avvalendosi di quelli standard come (int, char, float) è chiamata &#34;typedef&#34;. Questa funzione consente al programmatore di definire a piacere i nomi dei propri dati come per esempio i tipi di dato built-in e quelli strutturali. Un semplice esempio di tipo di dato potrebbe essere questo:
typedef int numero;
numero var;</answer_text><num_votes>0</num_votes></answer><answer id="A2908"><answer_text>Per definire un nuovo tipo di dato è necessario creare una struttura quindi scriveremo
typedef struct{
	//qui metteremo nel variabili della struttura per esempio
	int a;
	char c;
}nomestruttura;
Infine per usare la struttura è necessario associare il &#34;nomestruttura&#34; ad una variabile.
Ecco l&#39;ultimo passaggio:
nomestruttura b;
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2833"><question_text>Indicare e descrivere brevemente i principali tipi predefiniti di dati in C/C++. Infine spiegare
in che modo il programmatore può creare nuovi tipi di dato.
</question_text><answer id="A2765"><answer_text>I tipi predefiniti in C/C++ sono int,char,float,void,enum. 
Alcuni di essi possono esseri modificati attraverso delle parole chiave ad esempio long,short,double, che ne cambiano i valori contenuti.
Il programmatore può creare nuovi tipi di dato attraverso la parola chiave typedef che permette all&#39;utente di definire dei nuovi identificatori di tipi di dati 
che potranno essere usati dall&#39;utente all&#39;interno del programma.</answer_text><num_votes>1</num_votes></answer><answer id="A2856"><answer_text>I tipi predefiniti del linguaggio C sono: &#34;int&#34; (numeri interi), &#34;float&#34; e &#34;double&#34; (numeri razionali), &#34;char&#34; (caratteri ASCII).
I tipi definibili dall&#39;utente sono invece: &#34;struct&#34; (strutture che raggruppano diversi tipi di variabili), &#34;typedef&#34; (definizione di nuovi nomi per tipi esistenti), &#34;enum&#34;(liste di simboli che la variabile può assumere), &#34;union&#34; (permette di definire la stessa porzione di memoria con tipi diversi), &#34;bit-field&#34; (variazione delle strutture che permette di accedere ai singoli bit di una parola in memoria).
I tipi sopra elencati devono essere definiti prima del &#34;main&#34;</answer_text><num_votes>3</num_votes></answer><answer id="A2811"><answer_text>I principali tipi di dato sono: int (per i numeri interi), float (per i numeri reali), double (per i numeri reali con doppia precisione) e char (per i caratteri).
Oltre ai tipi base ci sono anche i tipi &#34;user-defined&#34;, definiti dal programmatore. I tipi user-defined più utilizzati sono struct e typedef. Il tipo struct definisce una variabile che riuniscono informazioni eterogenee, ovvero, all&#39;inerno della struttura, ci possono essere variabili di tipo diverso.
Con typedef si definiscono dei sinonimi per i tipi già esistenti.</answer_text><num_votes>0</num_votes></answer><answer id="A2809"><answer_text>I tipi base di dato sono: 
-&#38;#8239;int (interi), 
-&#38;#8239;float (reali), 
-&#38;#8239;double (reali in doppia precisione)&#38;#8207; ,
-&#38;#8239;char (caratteri).

E&#39; possibile definire sinonimi per tipi di dato esistenti attraverso il costrutto typedef.</answer_text><num_votes>0</num_votes></answer><answer id="A2783"><answer_text>I tipi di dati in C sono:
-Tipo semplice: elementi che nell?insieme sono considerati entità non scomponibili in parti più elementari
-Tipo strutturato: ciascun elemento nell?insieme è un aggregato di elementi a loro volta semplici o strutturati
-Tipi definiti dall&#39;utente: un nuovo tipo può essere definito dando un nuovo nome a un tipo già esistente
-Tipi predefiniti built in(interi, reali float) che sono già definite nel linguaggio
Il linguaggio di programmazione permette all&#39;utente di creare nuovi tipi di dato mediante l&#39;utilizzo delle seguenti strutture: struct,enum,typedef,ecc
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2920"><question_text>Che tipologie di dato possono essere inserite nelle strutture? Quanti dati possono essere contenuti all&#39; interno di una struttura? E&#39; possibile avere strutture di strutture? </question_text><answer id="A2913"><answer_text>In una struttura possono essere contenuti tipi di dati numerici, come int e float, caratteri e anche array.
Una struttura può anche contenere al suo interno un&#39;altra struttura.</answer_text><num_votes>0</num_votes></answer><answer id="A2784"><answer_text>Possono essere inserite nelle strutture i tipi base quali int, float, double e chat. È possibile avere strutture di strutture utilizzando tipi strutturati quali il struct, typedef, enumeration</answer_text><num_votes>1</num_votes></answer><answer id="A2778"><answer_text>Quando si parla di strutture in C ci si riferisce a costruzioni definite dal programmatore che posso contenere N tipi di dati diversi di tutte le tipologie, anche in modo eterogeneo (tipi predefiniti, array, dati enum, ecc). Da notare è che tali costrutti possono essere utilizzati trammite il typedef per definire in modo comodo e veloce tipi di dati nuovi diversi da quelli predefiniti; questo permette anche di costruire &#34;strutture di strutture&#34; in quanto una volta definito un nuovo tipo di dato eterogeneo esso può essere anche utilizato come campo all&#39;interno di una struttura piu grande.</answer_text><num_votes>1</num_votes></answer><answer id="A2864"><answer_text>Una struttura è un particolare tipo user-defined che permette di raggruppare variabili eterogenee (integer, char, ecc).
Le strutture possono contenere quanti dati si vogliono, ovviamente evitando di cadere in overflow.
Inoltre è possibile definire strutture di strutture. Ciò permette di organizzare e definire strutture ordinate di alcune informazioni (come possono essere le voci di una agenda) che hanno bisogno di più voci per essere rappresentate.
Ai vari campi delle strutture si accede tramite la dot-notation.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2825"><question_text>Che differenza c&#39;è tra il costrutto typedef e struct?</question_text><answer id="A2893"><answer_text>Typedef è la &#34;parola chiave&#34; che serve per dichiarare un tipo. Mentre il costrutto &#34;struct&#34; permette di definire strutture aggregando informazioni di vario tipo. In poche parole lo &#34;struct&#34; è un tipo, dunque per essere definito dovrà essere preceduto da &#34;typedef&#34;. </answer_text><num_votes>0</num_votes></answer><answer id="A2850"><answer_text>La differenza consta nel fatto che struct è un costruttore di tipo e definisce una struttura, mentre typedef è un operatore sintattico che ridefinisce o crea un nuovo identificatore per tipi esistenti o variabili user-defined (come le strutture stesse). Sia typedef che struct sono due modi per definire dei tipi definiti dall&#39;utente e spesso typedef e struct sono usati insieme per dare un nome ad una nuova struttura.</answer_text><num_votes>1</num_votes></answer><answer id="A2788"><answer_text>I due costrutti svolgono una funzione simile, ma hanno delle differenze:
-se dichiaro uno struct potrò assegnargli solo una variabile, cosa che dovrò fare subito dopo la dichiarazione
della struttura.
-se dichiaro un typedef (costruttore di tipo) potrò dichiarare quante variabili vorrò e anche in seguito rispetto
alla dichiarazione di tipo, cosa non possibile con una semplice struttura.

typedef struct {
int nmatricola;
char nome[20];
} studente;

In questo modo si potranno creare anche array del nuovo tipo:

studente studenti[100];
</answer_text><num_votes>1</num_votes></answer><answer id="A2882"><answer_text>Le strutture del C sostanzialmente permettono l&#39;aggregazione, non necessariamente ordinata o omogenea, di più variabili (anche, quindi, di tipo diverso).
La funzione &#34;typedef&#34;, invece, viene utilizzata per definire nuovi tipi di dato.
Infine l&#39;uso di &#34;typedef&#34; può anche essere combinato con &#34;struct&#34; e ciò permette di creare tipi di dato molto complessi.
</answer_text><num_votes>0</num_votes></answer><answer id="A2806"><answer_text>le due cose hanno lo stesso effetto, la differenza sta solo nella scrittura del programma
Infatti nello struct quando vuoi creare una variabile di tipo &#39;data&#39; devi scrivere struct data varData;
mentre con il typedef devi scrivere data varData;</answer_text><num_votes>0</num_votes></answer></question><question id="Q2822"><question_text>Perchè è importante definire un numero EPSILON piccolo a piacere quando bisogna confrontare valori di tipo float?</question_text><answer id="A2827"><answer_text>Ricordiamo che i tipi float usati in C (che siano quantificati col long ò con double) rappresentano CONCETTUALMENTE l&#39;insieme dei numeri reali ma IN REALTA&#39; non sono altro che un sottoinsieme di R a causa di una precisione limitata del calcolatore. Dunque per definire al meglio un qualsiasi tipo in virgola mobile è consigliato citare un vincolo di precisione tramite una costante float sufficientemente vicina a zero, appunto EPSILON che mi assicuri un margine accettabile di errore nelle operazioni di confronto tra valori:
&#34;(x==y) --&#62; (x&#60;=y+EPS) &#38;&#38; (x&#62;=y-EPS)&#34; 
dove, ad es: #define EPS 0.00001</answer_text><num_votes>4</num_votes></answer><answer id="A2801"><answer_text>perché il calcolatore non è infinitamente preciso.
talvolta il numero 0 viene considerato 0,0000034. E quindi per sicurezza si mette un epsilon che ci mette al riparo da questa evenienza</answer_text><num_votes>0</num_votes></answer><answer id="A2926"><answer_text>Perché due valori float, a causa degli errori minimi del calcolatore nel leggere certi valori, non possono mai essere uguali. Viene così definito un numero EPSILON molto piccolo che rapresenta un margine di errore, grazie al quali si possono confrontare valori di tipo float con la dovuta approssimazione, garantita appunto dal valore EPSILON.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2887"><question_text>Quali sono le differenze tra il costruttore di tipo &#34;array&#34; e quello &#34;struct&#34;?</question_text><answer id="A2921"><answer_text>Il costruttore array definisce un insieme di elementi dello stesso tipo, ordinati e accessibili tramite un indice di tipo int.
Lo struct invece definisce un insieme di elementi di tipi diversi,che possono essere built-in o user-defined, accessibili più facilmente dal programmatore tramite la  cosiddetta &#34;dot notation&#34;
</answer_text><num_votes>3</num_votes></answer><answer id="A2890"><answer_text>L&#39;array è un contenitore omogeneo, che contiene dati tutti dello stesso tipo, e l&#39;accesso ad ogni suo elemento avviene attraverso un indice (ed un ciclo for). 
Lo struct invece è eterogeneo, quindi può contenere dati di tipo diverso, e ai suoi campi si accede attraverso la dot notation. 
Un&#39;altra differenza è che un array non può essere restituito da una funzione, invece una struct si</answer_text><num_votes>0</num_votes></answer><answer id="A2760"><answer_text>L&#39;array non si presta alla rappresentazione di oggetti astratti che contengono variabili di tipo diverso, invece lo struct permette di definire variabili strutturate che aggregano informazioni eterogenee, quindi in contrasto all&#39;array.</answer_text><num_votes>0</num_votes></answer><answer id="A2753"><answer_text>Prendiamo per esempio il tipo di dato &#34;impiegato&#34; il quale dovrebbe essere caratterizzato da:nome, cognome, codice fiscale, indirizzo, numero di telefono, stipendio e via di seguito. L&#39;array non può essere il costruttore di tipo adeguato al dato &#34;impiegato&#34; poichè non si presta ad aggregare tutte queste informazioni. Infatti, esso è costituito da elementi con valori di tipo omogeneo. Il costruttore struct, invece, permette di definire una struttura di dati aggregando elementi anche di tipi diversi ed i vari elementi si dicono campi della struttura.</answer_text><num_votes>0</num_votes></answer><answer id="A2854"><answer_text>I costr.di tipo consentono di definire dei tipi di dato strutturati ovvero dati costituiti dall&#39;aggregazione di diversi componenti.Utilizzando l&#39; array si definiscono una sequenza di celle di memoria consecutive e omogenee che contengono dati tra loro uniformi (stesso tipo) a cui e&#39; possibile accedervi attraverso un indice. es.int lista [10] typedef implicito.Struct permette di aggregare informazioni eterogenee e quindi una struttura che contiene tipi di dati diversi tra loro.Si accedere a ogni singolo elemento con la dot notation.Di solito si dichiara con la forma esplicita typedef struct.  </answer_text><num_votes>1</num_votes></answer></question><question id="Q2886"><question_text>A che scopo è utile associare un nome al tipo definito da un&#39;enumerazione? Fornisci anche un esempio</question_text><answer id="A2877"><answer_text>è utile per non dover ripetere l?elencazione dei valori ogni volta che si definisce una variabile.

esempio: 
typedef enum {lun, mar, mer, gio, ven, 
sab, dom} GiornoSettimana; 
? ? 
GiornoSettimana giorno;</answer_text><num_votes>0</num_votes></answer><answer id="A2871"><answer_text>Può essere utile associare un nome ad un tipo definito da enumerazione  per non dover ripetere l&#39;elencazione ogni volta che una variabile di quel tipo viene definita.
Esempio:
typedef enum{giallo, verde, rosso, blu, viola, rosa}Coloriarcobaleno;

Coloriarcobaleno colore;

colore = giallo;
// per stampare il valore di colore ( in questo caso quello di giallo)
printf(&#34;%d&#34;,colore);
</answer_text><num_votes>1</num_votes></answer><answer id="A2860"><answer_text>È utile associare un nome al tipo definito da un&#39;enumerazione per non dover ripetere ogni volta l&#39;elencazione dei valori.
Ad esempio:
typedef enum {lun, mar, mer, gio, ven, sab, dom} giornoImpegno;
giornoImpegno giornoInizio;
giornoImpegno giornoFine;</answer_text><num_votes>0</num_votes></answer><answer id="A2779"><answer_text>È utile associare un nome al tipo definito da un&#39;enumerazione per non dover ripetere l&#39;elencazione dei valori ogni volta che si definisce una variabile, nel senso che non diventerà necessario richiamare tutto la stringa dell&#39;insieme ma solo il nome del tipo definito. Esempio:

enum{nome1,nome2,nome3,nome4} studente

Per non dover richiamare tutta la parte enum, si procede in questo modo:

typedef enum{nome1,nome2,nome3,nome4} StudenteDaInterrogare;
StudenteDaInterrogare studente;</answer_text><num_votes>2</num_votes></answer></question><question id="Q2885"><question_text>Specificare quante rappresentazioni in complemento vi sono e quali sono. Inoltre spiegare il funzionamento della rappresentazione in complemento a due ed elencare i motivi per cui la utilizziamo.</question_text><answer id="A2915"><answer_text>Vi sono due rappresentazioni: una in complemento a uno e l&#39;altra in complemento a due.
Il complemento a uno consiste nell&#39;invertire gli zero con gli uno e viceversa; il complemento a due funziona similmente al complemento a uno con l&#39;unica differenza che alla fine del calcolo aggiungo uno. </answer_text><num_votes>0</num_votes></answer><answer id="A2805"><answer_text>Vi sono due rappresentazioni a complemento: la rappresentazione in complemento a uno e a due. La più utilizzata è quella in complemento a due che rappresenta tutti i numeri da -2^(N-1) a +2^(N-1)-1 dove N sta per il numero di bit che utilizziamo. Il MSB (most significant bit) rappresenta il segno di un numero, se esso è 0 si procede con la normale decodifica,se invece vale 1 si deve sottrarre 2^(N-1) al numero decodificato; inoltre per cambiare segno ad un numero basta invertire le cifre e sommargli 1. Si usa perché è molto accessibile anche a sistemi semplici in quanto usa un solo circuito.</answer_text><num_votes>2</num_votes></answer><answer id="A2878"><answer_text>Le rappresentazioni in complemento ad uno e a due sono le più utilizzate ed hanno il vantaggio di non avere una doppia codifica per il trattamento del segno e di non richiedere una circuiteria specifica per il trattamento del segno.
Nella rappresentazione in complemento a due il primo bit rappresenta il segno e con N bit si codificano i valori da -2^(N-1) a 2^(N-1)-1. La codifica avviene normalmente se il primo bit è 0, mentre si decodifica e poi si sottrae 2^(N-1). Inoltre per invertire un numero binario si invertono le singole cifre e poi si aggiunge uno.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2792"><question_text>Descrivi l&#39;algoritmo necessario per implementare la conversione la conversione da binario ad ottale.</question_text><answer id="A2816"><answer_text>Poiché 8=2^3, ogni cifra totale corrisponde a 3 cifre binarie:
000=0
001=1
010=2
011=3
100=4
101=5
110=6
111=7
Per convertire un numero dal Sistema Binario a quello Ottale si procede in questo modo:
si considera in numero binario e partendo da destra si divide in gruppi di 3 cifre binarie. Se dopo l&#39;operazione avanzano  cifre si aggiungono tanti zeri quanti bastano a completare un gruppo da tre. Ogni gruppo va poi convertito nel corrispettivo numero ottale, come indicato sopra.
Esempio: conversione del numero binario (1101) in base ottale
(1101)=(1|101)=(001|101)=15 in base ottale.</answer_text><num_votes>2</num_votes></answer><answer id="A2879"><answer_text>La conversione da binario ad ottale la si può fare in due semplici passaggi convertendo da binario a decimale e poi da decimale a binario.  Un metodo non visto a lezione ma molto più pratico è il seguente.
basandosi sulla tabella di conversione
0 000
1 001
2 010
3 011
4 100
5 101
6 110
7 111
La conversione la si fa molto semplicemente isolando 3 a 3 i numeri del binario, convertirli tramite la tabella e poi rimettere tutto insieme. esempio
10101011.1111-&#62;(10)(101)(011).(111)(11)-&#62;(010)(101)(011).(111)(110)-&#62;(2)(5)(3).(7)(6)-&#62;253.76</answer_text><num_votes>1</num_votes></answer><answer id="A2769"><answer_text>Per convertire un numero dal formato binario a quello ottale occorre:
 1. prendere il numero binario e suddividerlo, partendo dall&#39;LSB, in gruppi di 3 cifre
 2. far corrispondere ad ogni gruppo di 3 cifre binarie l&#39;equivalente valore in formato
    decimale
 3. comporre il numero ottale affiancando le cifre ottenute convertendo ogni gruppo di
     bit, rispettando l&#39;ordine del numero binario

Esempio:   (110101001)bin     =&#62;     (110)bin   (101)bin   (001)bin

			                                (6)dec      (5)dec      (1)dec     =&#62;     (651)ott
</answer_text><num_votes>1</num_votes></answer><answer id="A2885"><answer_text>Essendo 8 multiplo di 2 (2^3) la conversione risulta molto semplice: ogni 3 cifre binarie si otterrà un&#39;unica cifra ottale. Il numero da convertire va separato in gruppi di tre cifre partendo da destra (senza preoccuparsi se le cifre non sono un multiplo di tre) ognuna delle quali viene divisa per 8. Il numero ottale si ottiene dalla lettura in sequenza dei resti ottenuti dalla divisione. Facciamo un esempio per chiarire: il numero binario 1001010111 va suddiviso in questo modo: &#34;00&#34;1-001-010-111; dalla divisione di ogni triade per 8 si ottengono i resti 1-1-2-7. Il numero convertito è 1127.</answer_text><num_votes>3</num_votes></answer><answer id="A2884"><answer_text>Essendo 8 multiplo di 2 (2^3) la conversione risulta molto semplice: ogni 3 cifre binarie si otterrà un&#39;unica cifra ottale. Il numero da convertire va separato in gruppi di tre cifre partendo da destra (senza preoccuparsi se le cifre non sono un multiplo di tre) ognuna delle quali viene divisa per 8. Il numero ottale si ottiene dalla lettura in sequenza dei resti ottenuti dalla divisione. Facciamo un esempio per chiarire: il numero binario 1001010111 va suddiviso in questo modo: &#34;00&#34;1-001-010-111; dalla divisione di ogni triade per 8 si ottengono i resti 1-1-2-7. Il numero convertito è 1127.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2817"><question_text>Per quale motivo la dichiarazione del tipo di variabile è un requisito fondamentale per il compilatore?</question_text><answer id="A2803"><answer_text>Dichiarare il tipo di variabile è fondamentale in fase di programmazione per far capire al compilatore come esso debba trattare la variabile stessa. Il tipo specifica infatti aspetti di enorme importanza che caratterizzano la variabile a cui esso fa riferimento, informando il compilatore su:
1)Quali valori la variabile può assumere;
2)L&#39;insieme di operazioni che possono essere effettuate con questi ultimi;
3)La quantità di memoria che deve esserle riservata per tale variabile: 
   char=1 byte
   int e short=2 byte
   long e float=4 byte
   double= 8 byte.</answer_text><num_votes>4</num_votes></answer><answer id="A2795"><answer_text>la dichiarazione di tipo di variabile è un requisito fondamentale in quanto definisce l&#39;insieme di valori che la variabile può assumere, e le operazioni che ad essa possono essere applicate </answer_text><num_votes>0</num_votes></answer><answer id="A2891"><answer_text>Dichiarando una variabile si alloca uno spazio di memoria che il programma potrà utilizzare per un determinato scopo, inserendo un certo tipo di dati (specificato nella dichiarazione). La quantità di memoria da allocare dipende dal tipo di variabile dichiarata. 
Non dichiarare una variabile viene riconosciuto come errore, in quanto il programma non saprebbe che spazio utilizzare in seguito.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2922"><question_text>Cosa si ottiene in output eseguendo operazioni aritmetiche (+,-,*,/) su due dati di tipo char ?</question_text><answer id="A2920"><answer_text>Il risultato sarà un valore di tipo int risultante dall&#39;operazione desiderata , per esempi A-a=|40| che nella tabella ascii è il valore che separa i due caratteri , negli altri casi sarà la risultante delle operazioni. </answer_text><num_votes>0</num_votes></answer><answer id="A2786"><answer_text>I caratteri seguono le stesse regole operazionali degli interi. Dato che i tipi char sono codificati con ASCII 7 bit, se facciamo char c,t; e poi li sommiamo, succede che si sommano i bit che codificano i due tipi char e il risultato è un numero intero che ha subito conversione da binario a decimale e verrà stampato a video tramite un printf. </answer_text><num_votes>0</num_votes></answer><answer id="A2919"><answer_text>Il risultato sarà un valore di tipo int risultante dall&#39;operazione desiderata , per esempi A-a=|40| che nella tabella ascii è il valore che separa i due caratteri , negli altri casi sarà la risultante delle operazioni. </answer_text><num_votes>0</num_votes></answer><answer id="A2773"><answer_text>le operazione aritmetiche su variabili di tipo char sono identiche a quelle di tipo int. Sommando, ad esempio, un carattere (riconducibile ad un numero sulla tabella del codice ASCII) ad un altro carattere (altro numero della tabella) si otterrà un carattere (corrispondente al numero sulla tabella ASCII) ottenuto dalla somma dei due caratteri precendenti.</answer_text><num_votes>1</num_votes></answer><answer id="A2775"><answer_text>Il compilatore svolge l&#39;operazione sul codice ascii dei corrispettivi caratteri, percui alla fine dara&#39; comunque un&#39;altro carattere corrispondente al codice ascii del risultato dell&#39;operazione svolta e non un errore come si potrebbe immaginare. </answer_text><num_votes>2</num_votes></answer></question><question id="Q2793"><question_text>Per quale motivo è fortemente sconsigliato l&#39;utilizzo dell&#39;operatore == tra due variabili di tipo float o double?</question_text><answer id="A2802"><answer_text>L&#39;utilizzo di tale operatore è sconsigliato per la presenza dei floating point. Ovvero essendo i numeri rappresentati attraverso un codice binario e una funzione esponenziale, ed essendo il numero di bit finito, rispetto ai numeri reali che possono avere infiniti numeri dopo la virgola, questo fa si che due numeri reali &#34;uguali&#34; presenti una differenza anche nell&#39;ultimo digit che fa si che l&#39;operatore == restituisca una corrispondenza non vera.</answer_text><num_votes>1</num_votes></answer><answer id="A2755"><answer_text>E&#39; fortemente sconsigliato poiché, in verifiche del tipo (x==y), il risultato è &#34;vero&#34; solo se tutte le cifre decimali sono uguali e questo è improbabile. 
E&#39; consigliabile scrivere invece: ( ( x &#62;= (y-d)) &#38;&#38; (x&#60;= (y+d) ) dove d è un piccolo margine di incertezza.</answer_text><num_votes>3</num_votes></answer><answer id="A2894"><answer_text>In quanto l&#39;operatore di uguaglianza (==) relaziona due variabili che possono differire di molto in quanto una variabile float contiene un numero sia reale sia con virgola mentre la variabile double identifica un numero reale con virgole ma a differenza di float può contenere numeri più complessi e lunghi  </answer_text><num_votes>0</num_votes></answer><answer id="A2812"><answer_text>Il simbolo &#34;==&#34; è un&#39;operatore relazionale di uguaglianza; ritorna 1 (vero) se le 2 espressioni ritornano valori uguali e ritorna 0 (falso) in caso contrario. Se lo usiamo tra variabili float (32 bit) e variabili double (64 bit) difficilmente restituirà un valore credibile poiché una variabile di tipo double contiene più numeri. </answer_text><num_votes>0</num_votes></answer><answer id="A2892"><answer_text>In quanto l&#39;operatore di uguaglianza (==) relaziona due variabili che possono differire di molto in quanto una variabile float contiene un numero sia reale sia con virgola mentre la variabile double identifica un numero reale con virgole ma a differenza di float può contenere numeri più complessi e lunghi  </answer_text><num_votes>0</num_votes></answer></question><question id="Q2870"><question_text>In che modo il C riesce a confrontare e ordinare i caratteri?</question_text><answer id="A3434"><answer_text>Il calcolatore è in grado di rappresentare i caratteri alfabetici, numerici ed i simboli speciali di punteggiatura
Ad ogni diverso carattere viene assegnato, convenzionalmente, un codice numerico corrispondente
Il programma in C lavora sempre con i codici numerici.
Inoltre le lettere maiuscole sono tutte consecutive, ed in ordine alfabetico come pure le lettere minuscole sono tutte consecutive, ed in ordine alfabetico (le lettere maiuscole vengono ?prima? delle minuscole), anche le cifre numeriche sono tutte consecutive, in ordine dallo 0 al 9.
Quindi il confronto avviene tra numeri.
</answer_text><num_votes>0</num_votes></answer><answer id="A2905"><answer_text>I tipi char di solito vengono rappresentato mediante un byte, sufficiente per rappresentare i 256 caratteri della codifica ASCII.L&#39;ASCII è un sistema di codifica dei caratteri a 7 bit, comunemente utilizzato nei calcolatori. Il codice ASCII dei caratteri in realtà in  memoria viene espresso con numero intero da -128 a +127 e sono definite le operazioni di assegnamento quelle aritmetiche e quelle relazionali.Pertanto, fra i caratteri è automaticamente definito un ordinamento,per esempio sarà lecito scrivere &#39;A&#39;&#60;&#39;R&#39;.</answer_text><num_votes>2</num_votes></answer><answer id="A2844"><answer_text>I caratteri di una stringa del linguaggio C possono essere semplicemente confrontati e ordinati. Si prenda per esempio in considerazione l&#39;esercizio (svolto in laboratorio) di confrontare due stringhe e decidere quale delle due precede l&#39;altra in ordine alfabetico.  Basta utilizzare una variabile contatore che conti il numero di caratteri utilizzati ed un&#39;altra per valutare i caratteri.</answer_text><num_votes>0</num_votes></answer><answer id="A2911"><answer_text>Ogni carattere è rappresentato da un rispettivo numero intero (codice ASCII). Per confrontare due caratteri è necessario confrontare i loro relativi codici ASCII. Per esempio il carattere &#39;0&#39; è identificato dal codice 48, mentre il carattere &#39;1&#39; è identificato dal codice 49. Confrontandoli possiamo quindi dire che 0&#60;1.
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2820"><question_text>CHe cosa ci permette di fare il costruttore struct??</question_text><answer id="A2787"><answer_text>Ci permette di definire delle variabili create dall&#39;utente che aggregano informazioni di vario tipo.</answer_text><num_votes>0</num_votes></answer><answer id="A2909"><answer_text>Il tipo struct ci permette di creare un array di strutture di dati non omogenei, cioè un array che può contenere sia variabili di tipo char, sia variabili di tipo int o float, sia stringhe di caratteri, ad esempio.</answer_text><num_votes>1</num_votes></answer><answer id="A2843"><answer_text>Il costruttore struct permette di definire variabili strutturate che aggregano informazioni eterogenee, cosa non concessa negli Array.
Cioè nel costruttore Struct possiamo inserire più variabili di diverso tipo.
Non vediamo più le variabili singolarmente, ma si parla di entità più complesse, caratterizzate da diversi campi. 
(es l&#39;entità Persone(nome,cognome,età)).</answer_text><num_votes>3</num_votes></answer></question><question id="Q2903"><question_text>Qual&#39;è il procedimento da seguire per convertire un numero decimale in esadecimale?</question_text><answer id="A2876"><answer_text>Si divide il numero per 16 e si considera il risultato ed il resto, successivamente si divide per il risultato precedentemente trovato per 16 (sempre considerando il resto), si procede così finché il risultato della divisone è zero (con il resto o senza). Infine si considerano i resti trovati in ordine inverso: questo è il numero di partenza in base esadecimale. ES: (35)base10-&#62; 35/16= 2 (resto 3), 2/16 = 0 (resto 2), quindi (35)base10 -&#62; (23)base16 ovvero il numero cercato sono la sequenza dei resti al contrario.</answer_text><num_votes>0</num_votes></answer><answer id="A2763"><answer_text>Nel sistema esadecimale le cifre vanno da 0 a 9 alle quali si aggiungono le prime sei lettere dell&#39;alfabeto(A,B,C,D,E,F).
I valori delle lettere sono: A=10,B=11,C=12,D=13,E=14,F=15.Per convertire un numero decimale in un numero esadecimale è necessario dividere il numero dato e i suoi successivi quozienti per 16 e in seguito prendere i resti in ordine contrario ricordando che dal 10 al 15 il valore va sostituito con le lettere. 
Esempio: N° 26
26/16=1 resto=10(A)         1/16=0 resto=1
26 decimale= 1A esadecimale</answer_text><num_votes>3</num_votes></answer><answer id="A2918"><answer_text>Per una conversione da b10 a b16 si verifica se il numero b10 è maggiore di 16, se così è allora si divide per 16 e se ne prende il resto e si moltiplica per 16 ottenendo un numero tra 0 a 9 o delle lettere da A a G,dove A=10,B=11, C=12,D=13,E=14,F=15, G=16.Di seguito con il numero intero rimasto dalla divisione si effettua lo stesso procedimenti sono a che non si ha un numero inferiore/uguale a 16 a cui si assegna il rispettivo termine: Es: (4321)b10 = -&#62; 4321/16 = 270 + resto1. 270/16 = 16 restoE. 16/16 = G. (4321)b10 = (GE1)b16. 
per verifica si nota che : (G * 16^2)+(E*16^1)+(1*16^0)=4321</answer_text><num_votes>0</num_votes></answer><answer id="A2858"><answer_text>Per fare la conversione si prende il numero binario e lo si divide per 16 fino a quando possibile.
Per scrivere il numero esadecimale si prendono i risultati della divisione e i numeri da 0 a 9 vanno scritti così come sono, per i risultati da 10 a 15 vanno scritti con le lettere dalla A alla F, per i risultati da 16 a 25 vanno scritti con i numeri da 10 a 19, poi si ripetono le lettere con il numero davanti.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2958"><question_text>Qual é la differenza tra codici ASCII a 7 bit e a 8 bit?</question_text><answer id="A2855"><answer_text>Il codice ASCII fornisce una tabella che elenca le corrispondenze tra caratteri e numeri. A differenza del codice ASCII standard a 7 bit, che mette a disposizione la possibilità di rappresentare 128 caratteri (2^7 caratteri) codificati attraverso 7 bit di informazione, che conterranno la cifra binaria associata al carattere corrispondente, il codice ASCII esteso a 8 bit mette a disposizione la possibilità di rappresentare 256 caratteri diversi (2^8 caratteri), in quanto i bit vengono considerati a gruppi di 8 e non più a gruppi di 7.</answer_text><num_votes>1</num_votes></answer><answer id="A2751"><answer_text>La codifica ASCII a 7 bit è stato il primo standard per la codifica dei caratteri e poteva rappresentare 128 caratteri (2^7). Di questi 128 alcuni rappresentano caratteri alfanumerici, altri sono detti caratteri non stampabili e rappresentano codici di controllo (ad esempio &#39;NULL&#39;). La codifica a 8 bit (extended ASCII) è stata sviluppata in seguito per poter codificare altri caratteri al di fuori dei 128 originali (ad esempio le lettere accentate o altri simboli di valuta).</answer_text><num_votes>2</num_votes></answer><answer id="A2875"><answer_text>La differenza tra un codice ASCII a 7 bit e a 8 bit consiste che il primo puo&#39; contenere al massimo 128 unita&#39; tra cui lettere maiuscoli e minuscoli, numeri (0 a 127), alcuni simboli, invece un codice ASCII a 8 bit contiene al massimo 256 unita&#39; in aggiunta all&#39;elenco precedente ci sono le lettere accentate e altri simboli che erano da quello a 7 bit.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2918"><question_text>Come avviene la conversione da ottale a decimale?</question_text><answer id="A2754"><answer_text>Per convertire un numero intero dal sistema ottale al sistema decimale devo riscriverlo come somma delle cifre del numero moltiplicate per le potenze decrescenti di 8. 
Ad esempio 576(base8)=(5*8^(2))+(7*8^(1))+(6*8^(0))=320+56+6=382(base10).
Se ho un numero non intero,per convertire la parte frazionaria, sommo le cifre della parte frazionaria del numero moltiplicate per le potenze crescenti negative di 8(per la parte intera procedo come descritto in precedenza).
Ad esempio 576,16(base8)=(5*8^(2))+(7*8^(1))+(6*8^(0))+(1*8^(-1))+(6*8^(-2))=320+56+6+1/8+3/32=382,21875(base10).</answer_text><num_votes>2</num_votes></answer><answer id="A2752"><answer_text>Per convertire un numero da ottale a decimale, dobbiamo scrivere il numero dato come la somma dei prodotti delle cifre del numero per le potenze decrescenti dell&#39;8.</answer_text><num_votes>1</num_votes></answer><answer id="A2750"><answer_text>La conversione ottale-decimale è la trasformazione di un numero su base otto ( sistema ottale ) in un numero su base dieci ( sistema decimale ). Essendo due sistemi numerici posizionali per convertire un numero ottale in un numero decimale è sufficiente moltiplicare ogni cifra del numero (d) per la potenza 8 corrispondente (n), e sommare tra di loro i risultati.</answer_text><num_votes>0</num_votes></answer><answer id="A2790"><answer_text>Per eseguire una conversione da ottale a decimale si devono eseguire una serie di moltiplicazioni per otto elevato ad un valore che dipende dalla posizione che il bit occupa nell&#39;array (ricordandosi che la posizione con il peso minore, ovvero quando l&#39;otto deve essere elevato alla zero, è relativa all&#39;ultima cella dell&#39;array) e, dopo aver eseguito le moltiplicazioni, si devono sommare tra loro i diversi contributi legati ai bit dell&#39;array binario. Il risultato ottenuto è ciò che cerchiamo, ovvero la forma decimale.</answer_text><num_votes>1</num_votes></answer><answer id="A2851"><answer_text>La conversione da ottale a decimale avviene nella sequente maniera: il primo valore (più a destra) della stringa di bit del numero ottale deve essere moltiplicato per il numero 8 elevato alla posizione del bit, di seguito anche quello del secondo bit ecc. Tutti questi valori vengono poi sommati per avere in uscita il valore decimale.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2868"><question_text>Qual è la differenza tra il tipo &#39;struct&#39; e &#39;typedef struct&#39;?</question_text><answer id="A2798"><answer_text>Struct definisce un tipo di dato(User-Defined) che può essere utilizzato per dichiarare delle variabili contestualmente alla definizione o in seguito.
Typedef struct va a definire degli alias anche per il tipo di dato struct.
Esempio:
typedef struct{
float x,y,z;
}COORD;
COORD è un tipo di dato,quindi può essere utilizzato come tipo di variabile.
Senza &#34;typedef&#34;,COORD sarebbe una variabile basata su una struttura contenente i dati x,y e z. </answer_text><num_votes>0</num_votes></answer><answer id="A2767"><answer_text>Innanzitutto è più corretto chiamare la ?struct? non tipo, ma costruttore di tipo, in quanto è un costrutto che permette di raggruppare variabili di tipo diverso. La differenza col ?typedef struct? è che il primo può dichiarare una sola variabile legata struttura (quindi se voglio più variabili fatte in quel modo devo creare altrettante struct), mentre il secondo costrutto permette di ridefinire la struct con un nome scelto dall?utente e dichiarare molteplici variabili legate alla struttura, ovunque nel codice, utilizzando il nome scelto come se fosse un tipo di dato predefinito.</answer_text><num_votes>0</num_votes></answer><answer id="A2836"><answer_text>Con &#34;struct&#34; si dichiarano variabili strutturate che raggruppano un insieme di variabili di tipo diverso, invece con &#34;typedef struct&#34; si definisce un nuovo nome per dichiarare variabili, in questo caso, di tipo struct.</answer_text><num_votes>1</num_votes></answer><answer id="A2807"><answer_text>typedef struct permette semplicemente di dichiarare una nuova variabile di tipo struct senza ripetere ogni volta &#34;struct&#34; stesso in fase di dichiarazione.</answer_text><num_votes>0</num_votes></answer><answer id="A2764"><answer_text>Le due espressioni esprimono la stessa cosa:
Con &#34;typedef struct&#34; si definisce &#34;struct&#34; come un tipo di dato, quindi una certa variabile x potrà essere dichiarata come: struct x;
Con &#34;struct&#34; intendiamo invece una struttura dati formata da elementi non omogenei.
Le differenza sta nel tipo di linguaggio usato:

typedef struct{
int x;
char y;
}nomevariabile;

struct nomevariabile{
int x;
char y;
}</answer_text><num_votes>1</num_votes></answer></question><question id="Q2953"><question_text>In cosa consiste una variabile di carattere enumerativo e per quali utilizzi risulta comoda?</question_text><answer id="A2848"><answer_text>Una variabile di tipo enumerativo può assumere solo valori (uno per volta) predeterminati al momento della dichiarazione. In particolare, questi valori sono di solito delle etichette, alle ciascuna delle quali viene automaticamente associato un numero progressivo a partire da 0. Questo tipo di variabile è molto utile quando operiamo con un numero finito di casi possibili, ad esempio valori booleani (Falso e Vero), giorni della settimana, mesi dell&#39;anno, e ogni caso di lista finita.</answer_text><num_votes>3</num_votes></answer><answer id="A2835"><answer_text>Una variabile di carattere enumerativo (Enum) descrive un nuovo tipo (come struct), che serve a dichiarare variabili i cui valori &#34;possibili&#34; sono &#34;ristretti&#34; e &#34;predeterminati&#34;(cioè i valori sono spercificati in un elenco). Inoltre l&#39;uso di enum è utile perchè permette di scrivere un codice più chiaro e più esplicativo.</answer_text><num_votes>0</num_votes></answer><answer id="A2906"><answer_text>Una variabile di carattere enumerativo durante l&#39;esecuzione del programma puo&#39; assumere un valore qualsiasi, che viene deciso dal programmatore, ma in realtà un valore numerico int che va da 0 al n-1 variabili scelte. 
</answer_text><num_votes>0</num_votes></answer></question><question id="Q2904"><question_text>Qual&#39;è il procedimento da seguire per definire un tipo di dato &#34;user-define&#34;?</question_text><answer id="A2927"><answer_text>Per definire un tipo di dato in C si utilizza la parola chiave typedef. Questa deve essere seguita dal tipo di dato e dall&#39;identificativo del 
nuovo tipo di dato. Per esempio
Typedef int intero. 
Per dichiarare una variabile nel nuovo tipo di dato si usa la sintassi nuovo_tipo_dato nome_variabile.Per esempio:
intero numero
Typedef viene spesso utilizzato per definire dei tipi di dato struct così è sufficiente, ogni qualvolta si intenda dichiarare una variabile 
di  tale tipo, utilizzare il nuovo tipo di dato senza riscrivere inteamente la struttura.</answer_text><num_votes>1</num_votes></answer><answer id="A2857"><answer_text>La dichiarazione dei tipi di dato user-defined avviene solitamente nella parte dichiarativa del programma, dopo le costanti e prima delle variabili. La parola chiave da utilizzare in questo caso è &#34;typedef&#34; seguito da: 1) tipo di dato che si vuole creare (ovvero la specifica di come è costruito a partire da tipi esistenti, siano built-in o user-defined a loro volta); 2) il nome del nuovo tipo; 3) il simbolo &#34;;&#34;. Ad esempio: &#34;typedef int anno;&#34;. Allo stesso modo attraverso &#34;typedef&#34; è possibile associare un nome ad un tipo definito mediante il costrutto &#34;struct&#34;, ad array e a puntatori.</answer_text><num_votes>1</num_votes></answer><answer id="A2865"><answer_text>Un possibile procedimento per definire un tipo di dato user define può essere la definizione mediante l&#39;operatore &#34;typedef&#34; di una struttura &#34;struct&#34; definita dal programmatore e assegnare a questo tipo di dato un nome scelto dal programmatore il quale all&#39;interno del programma servirà per definire le variabili di questo nuovo tipo &#34;struct&#34;.</answer_text><num_votes>0</num_votes></answer><answer id="A2762"><answer_text>È necessario inizializzare il tipo user-defined al di fuori del main.c e successivamente dichiararlo nello stesso.  Ad esempio nel caso di una struttura bisogna inizializzare la &#34;struct&#34; in ogni sua parte, con le singole variabili, e poi la si dichiara all&#39;interno del main.c .</answer_text><num_votes>0</num_votes></answer></question><question id="Q2952"><question_text>Data la stringa binaria 01010101, a quali numeri decimali corrsponde nelle tre ipotesi che sia codificata
in binario, modulo e segno o complemento a due?</question_text><answer id="A2833"><answer_text>Dato il numero binario 01010101, calcoliamo così il numero decimale a cui corrisponde:

1*2^6=64
0*2^5=0
1*2^4=16
0*2^3=0
1*2^2=4
0*2^1=0
1*2^0=1

sommando i vari risultati otteniamo il numero decimale 85.
Per quanto riguarda il segno basta vedere la prima cifra (da sinistra) se è 0 il numero sarà positivo se invece è 1 sarà negativo, in questo caso è positivo.
utilizzando il complemento a 2 otteniamo il numero binario 10101011 (bisogna invertire 0 con 1 viceversa, e sommare 1), e facendo i calcoli come prima otteniamo il numero decimale 171.</answer_text><num_votes>0</num_votes></answer><answer id="A2849"><answer_text>se codificata in binario modulo e segno corrisponde al numero 85 (positivo); idem per la codifica a complemento a 1 o 2. Essendo positivo infatti il procedimento di conversione non cambia.</answer_text><num_votes>0</num_votes></answer><answer id="A2832"><answer_text>Dato il numero binario 01010101, calcoliamo così il numero decimale a cui corrisponde:

1*2^6=64
0*2^5=0
1*2^4=16
0*2^3=0
1*2^2=4
0*2^1=0
1*2^0=1

sommando i vari risultati otteniamo il numero decimale 85.
Per quanto riguarda il segno basta vedere la prima cifra (da sinistra) se è 0 il numero sarà positivo se invece è 1 sarà negativo, in questo caso è positivo.
utilizzando il complemento a 2 otteniamo il numero binario 10101011 (bisogna invertire 0 con 1 viceversa, e sommare 1), e facendo i calcoli come prima otteniamo il numero decimale 171.</answer_text><num_votes>3</num_votes></answer><answer id="A2897"><answer_text>Se la stringa binaria è codificata in binario, il corrispondente numero decimale è = 1*(2^0)+0*(2^1)+1*(2^2)+0*(2^3)+1*(2^4)+0*(2^5)+1*(2^6)+0*(2^7) = 85, se è codificata in modulo e segno: il bit più significativo (0) indica che il numero è positivo e con la codifica appena usata = +85, se è codificata in complemento a 2: essendo il bit più significativo 0, si procede con la normale codifica perciò = +85. Come in questo caso le stringhe binarie con bit più significativo 0 corrispondono allo stesso numero decimale con ciascuna di queste tre diverse codifiche.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2889"><question_text>cosa posso inserire come tipi di campo all&#39;interno di una struttura?</question_text><answer id="A2895"><answer_text>I tipi di campo che si possono inserire all&#39;interno di una struttura sono i seguenti:
-tipo semplice (interi e caratteri);
-tipi strutturali (array,...);
-tipi predefiniti nel linguaggio;
-tipi implementati dal programmatore.</answer_text><num_votes>0</num_votes></answer><answer id="A2771"><answer_text>All&#39;interno di una struttura si possono definire variabili, dette campi, che aggregano informazioni eterogenee tra loro. Tali variabili possono essere di qualsiasi tipo (int, char, float o anche array). L&#39;accesso ai singoli campi della struttura avviene tramite la &#34;dot notation&#34; (ad esempio: nomeStruttura.campo1).</answer_text><num_votes>1</num_votes></answer><answer id="A2859"><answer_text>Posso utilizzare e manipolare valori sia di tipo numerico (int, double, float, long,...) che stringhe di caratteri (char, string). Inoltre posso inserire tipi composti come array di numeri o di caratteri.</answer_text><num_votes>1</num_votes></answer><answer id="A2796"><answer_text>Una struttura viene definita con il costrutto struct, oppure in alternativa si possono implementare dei costruttori di tipo con typedef struct, con cui è possibile creare insieme di variabile correlate che possono essere di tutti i tipi prevvisti dal linguaggio C di tipo alfanumerico e numerico, inoltre è possibile aggiungere con il comando &#39;typedef enum&#39; dei valori a particolari parole, per migliorare la leggibilità del programma.</answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L33" title="Strutture di Controllo, Puntatori" date="2013-10-25"><question id="Q3114"><question_text>Quali sono le istuzioni che consentono di fare delle strutture di controllo? E quali sono definite complete secondo il teorema di Boehm Jacopini?</question_text><answer id="A3050"><answer_text>Le strutture di controllo &#34;if-else&#34; e &#34;while&#34; sono definite complete in quanto permettono di codificare qualsiasi algoritmo.</answer_text><num_votes>0</num_votes></answer><answer id="A3039"><answer_text>Per creare delle strutture di controllo possiamo utilizzare 
*sequenze di istruzioni
*cicli: for e while
*selezioni: if, if-else, do-while, switch...
secondo il teorema BJ if-else e while sono complete, ossia sufficienti per codificare qualsiasi algoritmo.</answer_text><num_votes>3</num_votes></answer></question><question id="Q3056"><question_text>cosa dice il &#34;Teorema di Boehm-Jacopini &#34; ?
</question_text><answer id="A3087"><answer_text>Il teorema di Boehm-Jacopini afferma che qualunque algoritmo può essere implementato utilizzando tre sole strutture: la sequenza (è la normale elencazione di istruzioni), la selezione (if-else) ed il ciclo (iterazione col costrutto while), da applicare ricorsivamente alla composizione di istruzioni elementari. Queste strutture sono eqivalenti alle strutture di controllo del linguaggio assemblatore e anche alle strutture di controllo di qualsiasi altro linguaggio di programmazione.</answer_text><num_votes>0</num_votes></answer><answer id="A3037"><answer_text>Il teorema di Boehm-Jacopini enuncia che: &#34;Un algoritmo puo&#39; essere implementato utilizzando solamente tre strutture. Sequenza, selezione e ciclo.&#34; Dove la sequenza e&#39; l&#39;insieme delle istruzioni eseguite nell&#39;ordine deciso dal programmatore, la selezione e&#39; la scelta fra due percorsi (es. if, if-else) e il ciclo e&#39; un blocco di istruzioni da eseguire fino che una condizione lo permette (es. while, for). Con queste tre fasi e&#39; possibile creare algoritmi eseguibili da qualsiasi macchina.</answer_text><num_votes>1</num_votes></answer><answer id="A3066"><answer_text>Il teorema di Boehm-Jacopini (enunciato dagli omonimi informatici nel 1966) afferma che un linguaggio di programmazione che possiede le istruzioni di sequenza (di istruzioni), di selezione e i cicli, è completo.
Con queste tre sequenze di istruzioni è possibile codificare ogni programma eseguibile da un calcolatore, in quanto queste istruzioni sono equivalenti alle istruzioni del linguaggio assembler.
Il teorema ha soprattutto una importanza teorica, in quanto permette di comprendere quali sono le istruzioni elementari di ogni compilatore e permette di capire quali sono i linguaggi completi.</answer_text><num_votes>1</num_votes></answer><answer id="A3056"><answer_text>Il teorema di Böhm-Jacopini afferma che un qualsiasi algoritmo che può essere codificato può essere implementato utilizzando solo tre strutture:la sequenza la selezione e il ciclo che debbono essere applicate per comandi semplici.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3059"><question_text>Cosa verrà stampato a video ? Commenta la risposta.

typedef int TipoDato;
int main(int argc, char *argv[])
{   TipoDato *P,Dato;
    TipoDato **DP;    
    Dato = 1;    
    P = &#38;Dato;
    DP = &#38;P;     
    printf(&#34;%d\n&#34;,  P);
    printf(&#34;%d\n&#34;, *P);
    printf(&#34;%d\n&#34;,  DP);
    printf(&#34;%d\n&#34;, *DP);
    printf(&#34;%d\n&#34;,**DP);
   
    system(&#34;PAUSE&#34;);
    return EXIT_SUCCESS;
}</question_text><answer id="A2965"><answer_text>A video stampa 5 valori:
il primo valore rappresenta l&#39;indirizzo di Dato
il secondo valore rappresenta il valore di dato
il terzo valore rappresenta l &#39;indirizzo del puntatore che punta a dato
il quarto valore rappresenta l&#39;indirzzo di dato
l&#39;ultimo valore rappresenta il valore puntato al puntatore ossia il valore di dato =1</answer_text><num_votes>1</num_votes></answer><answer id="A3006"><answer_text>Nella 1a riga verrà stampato l&#39;indirizzo della variabile Dato, perché al puntatore P è stato assegnato l&#39;indirizzo di Dato con l&#39;operatore &#38;. Nella 2a riga verrà stampata la variabile puntata da P, ovvero Dato (1). Nella 3a riga verrà stampato l&#39;indirizzo di P, che sarà l&#39;indirizzo successivo a quello della prima riga (+4 bytes) se non è stato occupato prima da altri dati. Nella 4a riga verrà stampato di nuovo l&#39;indirizzo della prima riga perché è il valore puntato da DP (l&#39;indirizzo di Dato). Nell&#39;ultima verrà stampato di nuovo il valore di Dato (1) perché è il valore puntato da P.</answer_text><num_votes>0</num_votes></answer><answer id="A3084"><answer_text>Se eseguito con linguaggio C, il compilatore dà errore in quanto mancano:
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
Se viene corretto, il risultato è:

2686784
1
2686788
2686784
1

Il primo printf stampa ciò che è contenuto nella memoria riferito al TipoDato P, ossia l&#39;indirizzo a Dato.
Il secondo stampa ciò a cui punta P, cioè il contenuto di Dato.
Il terzo, mostra ciò che DP contiene: l&#39;inidirizzo a P.
Il quarto come il primo, visualizza il contenuto di P, cioè l&#39;indirizzo di Dato, essendo un puntatore ad un indirizzo e non a Dato.
L&#39;ultimo infine stampa il contenuto di Dato.</answer_text><num_votes>1</num_votes></answer><answer id="A2996"><answer_text>&#34;Indirizzo di Dato&#34;
1
&#34;Indirizzo di P&#34;
&#34;Indirizzo di Dato&#34;
1

E&#39; un chiaro esempio su come funzionano i puntatori, utili soprattutto nel lavorare con funzioni, procedure e nella gestione della memoria.</answer_text><num_votes>0</num_votes></answer><answer id="A2966"><answer_text>A video stampa 5 valori:
il primo valore rappresenta l&#39;indirizzo di Dato
il secondo valore rappresenta il valore di dato
il terzo valore rappresenta l &#39;indirizzo del puntatore che punta a dato
il quarto valore rappresenta l&#39;indirzzo di dato
l&#39;ultimo valore rappresenta il valore puntato al puntatore ossia il valore di dato =1</answer_text><num_votes>0</num_votes></answer><answer id="A3065"><answer_text>A video stampa 5 valori:
il primo valore rappresenta l&#39;indirizzo di Dato;
il secondo valore rappresenta il valore di Dato;
il terzo valore rappresenta l&#39;indirizzo del puntatore che punta a Dato;
il quarto valore rappresenta l&#39;indirizzo di Dato;
l&#39;ultimo valore rappresenta il valore puntato al puntatore ossia il valore di Dato.</answer_text><num_votes>2</num_votes></answer><answer id="A3031"><answer_text>Le seguenti righe di codice stampano tramite il primo printf il valore della variabile P che non contiene nulla, nel secondo invece viene stampato il valore della variabile a cui punta P, cioè Dato che vale 1.
Il terzo ed il quarto printf invece stampano rispettivamente la variabile DP, che non contiene nulla e la variabile alla quale punta DP, cioè P che anch&#39;esso non contiene nulla.
L&#39;ultimo printf, invece, stampa il doppio puntatore DP, ovvero la variabile a cui punta DP, cioè P, e la variabile a cui punta P, cioè Dato che vale 1.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3012"><question_text>Se nella compilazione del costrutto &#34;switch&#34; si omette il break alla fine di un caso, quali conseguenze verranno apportate al programma? Cio&#39; puo&#39; essere utile? Se si, in che caso?
     </question_text><answer id="A3047"><answer_text>Il &#34;break&#34; in un costrutto switch fa sì che si esca dell&#39;istruzione da un&#39;istruzione di switch. Se lo si omette vengono eseguite tutte le istruzioni nelle casistiche successive. Ciò può causare un&#39;esecuzione diversa da quella prevista dal programmatore, ma se consciamente usata può dare dei vantaggi come l&#39;estensione a più casistiche. </answer_text><num_votes>0</num_votes></answer><answer id="A3096"><answer_text>Il comando break come sappiamo consente di uscire dallo switch.Nel caso si ometta tale istruzione alla fine di un case vengono eseguite anche le istruzioni successive che fanno parte di altri case.Può essere utile nel caso in cui si voglia eseguire solo un case o tutte le istruzioni dopo di esso, a seconda del valore in ingresso allo switch.
Es: 
switch(a){
            case 0:printf(&#34;ciao\n&#34;);
            break;
            case 1:printf(&#34;ciao &#34;);
            case 2:printf(&#34;mario\n&#34;);
              }
Se a=0 viene eseguito il case 0, se a=1 i case 1 e 2, se a =2 esegue solo il case 2.</answer_text><num_votes>2</num_votes></answer><answer id="A3020"><answer_text>Se ometto il break alla fine di un caso verranno valutati anche i casi successivi. Il break serve appunto per uscire dalla struttura a cascata non appena la condizione desiderata è vera. Quindi è molto utile inserirlo per non cadere in errori.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3062"><question_text>int *a;       
*a=20; 
Questa scrittura è scorretta,perché? Come posso risolvere l&#39;errore?</question_text><answer id="A3021"><answer_text>Un puntatore punta ad un indirizzo di memoria quindi in questo caso sarebbe più appropriato usare una variabile invece di un puntatore oppure far puntare il puntatore (a) ad una variabile inizializzata con il valore 20.</answer_text><num_votes>0</num_votes></answer><answer id="A3085"><answer_text>Nella precedente scrittura quando il puntatore viene dichiarato nella prima riga con &#34;int *a;&#34; non sta puntando nulla. Per poter essere utilizzato un puntatore deve puntare a qualcosa. L&#39;errore commesso consiste quindi nel non aver assegnato un indirizzo di memoria al puntatore prima di usarlo. Infatti la scrittura:&#34;int *a; *a=20;&#34; genererà un errore (crash di programma). Una scrittura corretta è per esempio:
int *a;
int x;
a=&#38;x;
*a=20;</answer_text><num_votes>3</num_votes></answer><answer id="A3002"><answer_text>la scrittura è scorretta perchè il puntatore *a non sta puntando nessuna variabile, bensì un valore specifico, il che non è nella logica dei puntatori. per risolvere dovrei dichiarare un&#39;altra variabile es. b, assegnarle il valore b=20, ed infine farla puntare da a in questo modo a=&#38;b.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3039"><question_text>nell&#39; utilizzo dei puntatori cosa vuol dire incorrere nel rischio di aliasing?</question_text><answer id="A3100"><answer_text>Nel linguaggio di programmazione C l&#39;aliasing nei puntatori consiste nell&#39;utilizzo di puntatori differenti per referenziare una stessa variabile (quindi la stessa posizione di memoria). In questo caso si incorre nel rischio che il compilatore possa generare errori inattesi oppure errori run-time.</answer_text><num_votes>1</num_votes></answer><answer id="A3051"><answer_text>Per aliasing si intende il problema legato al fatto che uno stesso oggetto venga identificato in due modi diversi.
Per esempio:
*pi= 1
*qi= 2
pi=qi in questo caso *pi=2
ma assegnando un nuovo valore a *qi= 7 succede che automaticamente lo stesso valore venga assegnato anche a *pi
questo comporta che un assegnamento esplicito alla variabile puntata da qi determina un assegnamento nascosto alla variabile puntata da pi.

</answer_text><num_votes>4</num_votes></answer></question><question id="Q3053"><question_text>In quali casi risulta utile utilizzare in un algoritmo un ciclo?</question_text><answer id="A3091"><answer_text>In un algoritmo è preferibile utilizzare un ciclo quando una sequenza di operazioni deve essere ripetuta più volte.
I cicli for, while e do-while sono differenti:
- il ciclo FOR è utile quando il numero di iterazioni è noto a priori
- il ciclo WHILE è utile quando, il numero di iterazioni non è noto, ma è necessario ripetere un&#39;operazione finchè la condizione espressa in &#34;while(esp.)&#34; risulta falsa
- il ciclo DO-WHILE permette di ottenere lo stesso risultato del ciclo while, ma in modo più semplice, includendo l&#39;operazione, che veniva scritta prima del while, all&#39;interno del do-while.</answer_text><num_votes>3</num_votes></answer><answer id="A3027"><answer_text>Nella programmazione, l&#39;iterazione, chiamata ciclo o con il termine inglese &#34;loop&#34;, è una struttura di controllo, all&#39;interno di un algoritmo, che ordina all&#39;elaboratore di eseguire ripetutamente una sequenza di istruzioni, solitamente fino al verificarsi di particolari condizioni specificate. Ad esempio l&#39;inizializzazione degli elementi di un array. Le più importanti istruzioni di ciclo sono la &#34;for&#34;, la &#34;while&#34; e la &#34;do-while&#34;.
int i;
for (i = valIniz;  i &#60;= valFin; i++) { 
//istruzioni
} 

while (i &#60;= valFin) { 
//istruzioni
i++;
 }

do 
{//istruzioni
i++;}
while(i &#60;= valFin);</answer_text><num_votes>2</num_votes></answer></question><question id="Q3041"><question_text>Quali vantaggi/svantaggi comporta l&#39;allocazione dinamica della memoria? Come si effettua l&#39;allocazione dinamica della memoria in C?</question_text><answer id="A2989"><answer_text>Allocare dinamicamente la memoria in C vuol dire utilizzarla in modo flessibile: al posto di occuparne una quantità statica nello Stack, si allocherà la sola quantità necessaria -grazie anche a sizeof- nell&#39;Heap (più capiente del primo in quanto non definito a priori), rendendo quindi il linguaggio estremamente portabile. L&#39;unico svantaggio può essere attribuito all&#39;ardua gestione dei puntatori e non va dimenticata la responsabilità di liberare la memoria al termine dell&#39;utilizzo.Per allocare: p= malloc(sizeof(int)); con p puntatore (a int) e int tipo di dato desiderato. Per liberare: free(p);</answer_text><num_votes>0</num_votes></answer><answer id="A2984"><answer_text>I vantaggi sono notevoli, in primo luogo la flessibilità del programma, ed esempio dove non sono noti a priori i parametri del problema.
I principali svantaggi sono la produzione di garbage, un uso inefficiente della memoria, riferimenti fluttuanti.

L&#39;allocazione della memoria viene effettuata tramite la chiamata della funzione &#34;malloc(numero_bits_da_allocare)&#34;, questa funzione restituisce un puntatore anonimo (indirizzo) nello heap, con allocati i bits richiesti. Se non è possibile allocare i numero di bits richiesto, viene restituito un puntatore a NULL
(AD OGNI CHIAMATA VA VERIFICATO).</answer_text><num_votes>1</num_votes></answer><answer id="A3070"><answer_text>Il vantaggio fornito dall&#39;allocazione dinamica della memoria è la possibilità di allocare deallocare ed eventualmente anche ridimensionare memoria  in fase di runtime (e non di compilazione come per la memoria statica).
Lo svantaggio che presenta è che nel caso in cui il puntatore ad un&#39;area di memoria allocata dinamicamente venga fatto puntare ad un altra area di memoria, la parte di memoria dinamica non sarà più accessibile dal programma.
In C per allocare dinamicamante la memoria si usa un costrutto del tipo
P=malloc(sizeof(TipoDato))
Dove P è il puntatore al blocco di memoria allocata.</answer_text><num_votes>1</num_votes></answer><answer id="A3108"><answer_text>Con l&#39;allocazione dinamica si evita:
- lo spreco di memoria dovuto al sovradimensionamento degli array
- la sottostima nel dimensionamento degli array con conseguente overflow
- il rallentamento delle operazioni sugli array(ad esempio cancellazione di un elemento)
Gli svantaggi sono:
- maggiore complessità nella scrittura del codice
- rischio di produzione di garbage e riferimenti fluttuanti
In C/C++ l&#39;allocazione dinamica si effettua con:
&#39;malloc(sizeof(TipoDato))&#39; oppure &#39;new TipoDato&#39; che creano in memoria una variabile di tipo TipoDato ne restituiscono l&#39;indirizzo del primo byte.</answer_text><num_votes>4</num_votes></answer></question><question id="Q3002"><question_text>ALLOCAZIONE DINAMICA DELLA MEMORIA:

1) Quale zona della memoria può essere allocata dinamicamente? 
2) Dove avviene l&#39;allocazione statica?
3) In che modo è possibile allocare staticamente la memoria per una variabile?</question_text><answer id="A3093"><answer_text>1)L&#39;heap è la zona di memoria della macchina astratta che contiene le variabili create dinamicamente.
2)Lo &#34;stack&#34; è la zona,invece, che contiene solo le variabili dichiarate nelle varie funzioni e le variabili locali.
3)Sono possibili due tipi di allocazione, che avvengono quindi in una delle due zone precedentemente menzionate:
-l&#39;allocazione STATICA nello &#34;stack&#34;: esempio &#34;int a;&#34;
-l&#39;allocazione DINAMICA nell&#39;&#34;heap&#34;: esempio&#34;a=malloc(sizeof(int));&#34;.</answer_text><num_votes>0</num_votes></answer><answer id="A3109"><answer_text>1) Si può allocare nello heap, al run-time.
2) L&#39;allocazione statica avviene nel data segment, al compile-time. 
3) Ci sono due modi per allocare staticamente una variabile:
- definirla al di fuori da qualsiasi funzione, main() compresa;
- anteporre alla sua definizione la parola riservata static;</answer_text><num_votes>1</num_votes></answer></question><question id="Q3084"><question_text>Se noi sappiamo che p e q sono due variabili di tipo puntatore che puntano a due elementi di un array diversi tra loro, l&#39;istruzione p-q cosa restituisce?</question_text><answer id="A3035"><answer_text>Se p e q puntano a due diversi elementi di un array, p-q restituisce un valore intero pari al numero di elementi esistenti tra l&#39;elemento cui punta p e l&#39;elemento cui punta q, non la differenza tra il valore dei puntatori.</answer_text><num_votes>1</num_votes></answer><answer id="A2963"><answer_text>Restituisce la distanza tra i due elementi.</answer_text><num_votes>1</num_votes></answer><answer id="A3083"><answer_text>Se p e q puntano a due elementi diversi di un array, l&#39;istruzione p-q restituisce un valore intero pari al NUMERO DI ELEMENTI esistenti tra l&#39;elemento a cui punta il puntatore p e l&#39;elemto a cui punta q. 
L&#39;istruzione non restituisce la differenza tra il valore dei puntatori (cioè gli indirizzi).</answer_text><num_votes>4</num_votes></answer></question><question id="Q3123"><question_text>In quale memoria vengono memorizzati i puntatori e perché ?</question_text><answer id="A3102"><answer_text>I puntatori vengono salvati nella memoria STECK , perchè sono variabili come tutte le altre 
solo che queste sono destinate a contenere indirizzi di memoria .</answer_text><num_votes>0</num_votes></answer><answer id="A3005"><answer_text>I puntatori hanno un identificatore servono per leggere o scrivere su indirizzo di memoria, e vengono memorizzati nello &#39;Stack&#39;, una memoria statica gestita a pila. I puntatori vengono utilizzati anche per richiamare celle dalla &#39;Heap&#39;, una memoria dinamica con celle a cui non si assegna un identificatore, ma possono essere puntate dai puntatori dalla memoria stack. Questa gestione della memoria serve per non allocare troppe celle di memoria con variabili array, che vanno ad occupare un intera area di memoria, senza poi venire utilizzate.</answer_text><num_votes>5</num_votes></answer></question><question id="Q3013"><question_text>Qual&#39;è l&#39;utilità dei puntatori? Spiegare come si può accedere al contenuto di una variabile tramite un puntatore ad essa e come ottenere l&#39;indirizzo di memoria della suddetta variabile.</question_text><answer id="A3060"><answer_text>Un puntatore è utile nel caso di allocazione dinamica della memoria. 
La variabile puntatore contiene l&#39;indirizzo di memoria della variabile a cui punta.
Per ottenere l&#39;indirizzo di una variabile si usa l&#39;operatore &#38;. 
Esempio di assegnazione di indirizzo di variabile a puntatore px:
px = &#38;x;
Per accedere al contenuto della cella, il cui indirizzo è memorizzato nella variabile puntatore px, si fa precedere al puntatore l&#39;operatore * (*px).</answer_text><num_votes>4</num_votes></answer><answer id="A3048"><answer_text>I puntatori innanzitutto sono delle variabili che contengono in memoria l&#39;indirizzo di un&#39;altra variabile e possono essere di qualsiasi tipo. L&#39;utilizzo dei puntatori che è l&#39;unico modo per esprimere alcune operazioni produce anche un codice più compatto ed efficace. Con l&#39;utilizzo dell&#39;operatore * si ottiene il contenuto dell&#39;oggetto a cui punta il puntatore mentre per ottenere l&#39;indirizzo di memoria si utilizza l&#39;operatore &#38;</answer_text><num_votes>1</num_votes></answer></question><question id="Q3024"><question_text>Qualit tipi di operazioni è possibile fare nell&#39;ambito dei puntatori???</question_text><answer id="A3057"><answer_text>Si possono usare per modificare permanentemente le celle di un array e nel passaggio per indirizzo nell&#39;ambito delle funzioni. iIl valore assunto da un puntatore é un numero intero che rappresenta, in byte, un indirizzo di memoria ed alcuni programmi ammettono le operazioni di somma fra un puntatore e un valore intero (con risultato puntatore), oppure di sottrazione fra due puntatori (con risultato intero).</answer_text><num_votes>0</num_votes></answer><answer id="A3079"><answer_text>7 TIPI di Operazioni:

1)P=&#38;x;
   Assegna a P l&#39;indirizzo di x. &#39;&#38;&#39; indica un indirizzo.

2)*P=x;
   &#39;*&#39; è il simbolo unario di de-referenziazione (dereference);
   indica il contenuto della variabile puntata da P e gli assegna il valore x.

3)P=Q;
   Assegna al puntatore P il valore del puntatore Q.

4)NULL, un valore speciale che rende indefinito il valore di un puntatore.

5)Operatori di Confronto (==,&#60;,...)

6)Aritmetica dei Puntatori
   Somma e Sottrazione fra indirizzi.La sottrazione in uno stesso array dà un numero di elementi.

7)Allocazione Dinamica della Memoria.</answer_text><num_votes>4</num_votes></answer></question><question id="Q3064"><question_text>Quali sono gli errori che si possono fare durante l&#39;utilizzo dei puntatori creando così degli &#34;effetti collaterali&#34; (side effects)?</question_text><answer id="A3098"><answer_text>Utilizzando i puntatori è possibile incorrere in errori di ALIASING ovvero uno stesso oggetto può essere identificato in due modi diversi. Ad esempio con due puntatori int*A,*B se andiamo ad assegnare A = B l&#39;indirizzo del puntatore A conterrà lo stesso indirizzo di B e quindi punterà allo stesso intero di B. Così facendo si perderà l&#39;informazione a cui puntava inizialmente il puntatore A. Quindi :  *A=2; *B=1;  A = B ; perdo *A = ??????  diventa 
*A = 1;  Nel corso del programma se vado a cambiare il valore puntato da B andrò a cambiare  anche il valore puntato da A (saranno uguali). </answer_text><num_votes>1</num_votes></answer><answer id="A3103"><answer_text>Uno degli errori più comuni nell&#39;utilizzo dei puntatori è l&#39; &#34;aliasing&#34; ovvero l&#39;uso di più puntatori per un&#39;unica variabile, causato da un&#39;assegnamento improprio. per esempio: per x,y numeri interi e a e b puntatori a intero -&#62; *a =x; *b = y; a=b; allora avremo che a e b puntano alla stessa variabile (y) e perderemo l&#39;indirizzo di x (se modifico b, viene modificato a). x non sarà puntato da nessun puntatore a meno che non dichiariamo un altro puntatore a x. Aliasing comporta anche uno spreco di memoria in quanto usi 2 puntatori per arrivare alla stessa variabile.</answer_text><num_votes>2</num_votes></answer></question><question id="Q3019"><question_text>Perché quando passiamo ad una funzione una variabile per riferimento dobbiamo fare più attenzione nell&#39;implementazione del codice della suddetta funzione?elenca almeno un vantaggio e uno svantaggio rispetto al passaggio per valore.</question_text><answer id="A3107"><answer_text>Perché qualsiasi modifica effettuata alla variabile passata per riferimento modifica anche il valore della variabile originale (stessa locazione di memoria) quindi modifica la variabile di livello di visibilità (scope) esterno alla funzione.
***Vantaggi***
- Richiede meno memoria rispetto al passaggio per valore
- Il passaggio di parametri per riferimento consente di ritornare uno o più risultati al chiamante
***Svantaggio***
- Se modifico accidentalmente il valore della variabile passata per riferimento modifico le variabili dell&#39;intero programma e di conseguenza avere risultati errati.</answer_text><num_votes>4</num_votes></answer><answer id="A3061"><answer_text>Se il passaggio di parametri avviene per valore,la funzione riceve solo una copia del parametro che salva in una locazione di memoria(diversa da dove risiede il parametro &#34;originale&#34;)
Un vantaggio di questo metodo è che il valore della variabile nel programma chiamante non viene modificato.
Nel passaggio di parametri per riferimento,la funzione riceve l&#39;indirizzo del parametro.
Questo metodo richiede attenzione in quanto permette la modifica di variabili che sono ad un livello di visibilità esterno alla funzione.
Un vantaggio rispetto al passaggio per valore è il minor utilizzo di memoria.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2997"><question_text>Nella dichiarazione di un puntatore &#34;TipoDato *Puntatore&#34;, che cosa sono Tipodato,* e Puntatore? </question_text><answer id="A3122"><answer_text>Nella sintassi proposta:
- l&#39;operatore unario * indica che si sta dichiarando un puntatore, ovvero una variabile che memorizza un indirizzo di memoria corrispondente ad un&#39;altra variabile;
- Puntatore indica l&#39;identificatore della variabile di tipo puntatore dichiarata;
- TipoDato indica la tipologia del dato associata alla variabile puntata dal puntatore, ovvero corrispondente all&#39;indirizzo di memoria a cui il puntatore fa riferimento.</answer_text><num_votes>3</num_votes></answer><answer id="A2991"><answer_text>tipodato è il tipo (int,float,char ecc..) a cui puntatore punta, le variabili in memoria a cui punterà il puntatore devono essere dello stesso tipodato del puntatore. * è l&#39;operatore unario di dereferenziazione, esso permette al puntatore che ha nel right value l&#39;indirizzo della variabile a cui puntare, di dereferenziarlo a quella cella a cui corrisponde quell&#39;indirizzo (ed assegnarli un certo valore per esempio). Puntatore è una variabile di tipodato cui corrisponde, nel right value, un indirizzo di una variabile dello stesso tipo.</answer_text><num_votes>0</num_votes></answer><answer id="A3029"><answer_text>Un puntatore è una variabile il cui right value è un tipo dato che contiene un&#39;indirizzo ad una parte di memoria.
Con TipoDato indichiamo che il puntatore punta a una cella di memoria il cui valore è di TipoDato (es int).
Puntatore è il nome associato al puntatore, che viene deciso dal programmatore per poterlo utilizzare all&#39;interno del programma.
Il carattere * è un simbolo che dereferenzia il puntatore, indicando che vogliamo &#34;leggere&#34; il valore nel right value del puntatore.
Nel caso della dichiarazione scriviamo che il Puntatore è una variabile che punta ad una variabile di TipoDato</answer_text><num_votes>0</num_votes></answer></question><question id="Q3100"><question_text>In che cosa consiste typedef? Quale e&#39; il suo significato? Quando e&#39; utilizzato?</question_text><answer id="A3012"><answer_text>Typedef permette di creare un nuovo tipo attraverso altri tipi o costrutti, in particolare può essere built-in(es:int,char..) o strutturato(array e/o struct). Sono particolarmente utili con le struct, con gli enum e con le matrici, in quanto posso essere utilizzati per creare tipi o array più complesse(es:matrici tridimensionali) o per semplificare l&#39;uso di altri costrutti(es:con l&#39;enum permette di non elencare ogni volta gli elementi per ogni nuova variabile).</answer_text><num_votes>2</num_votes></answer><answer id="A3011"><answer_text>&#34;Typedef&#34; permette di assegnare un nuovo nome a dei tipi di dati già esistenti ed è principalmente utilizzato con le &#34;struct&#34;, per creare un tipo di dato con variabili eterogenee (Es. typedef struct{...}nuovonome;).</answer_text><num_votes>0</num_votes></answer><answer id="A3114"><answer_text>Typedef é una parola chiave dei linguaggi di programmazione C. Lo scopo della typedef è quello diassegnaredeinomi alternativi a dei tipi di dato esistenti, solitamente a quelli la cui dichiarazione standard è troppo ingombrante, magari confusionale, oppure per rendere il codice riutilizzabile più facilmente tra un&#39;implementazione e un&#39;altra.</answer_text><num_votes>0</num_votes></answer><answer id="A3043"><answer_text>Typedef è una parola chiave dei linguaggi di programmazione C e C++. Lo scopo della typedef è quello di assegnare dei nomi alternativi a dei tipi di dato esistenti, solitamente a quelli la cui dichiarazione standard è troppo ingombrante, magari confusionale, oppure per rendere il codice riutilizzabile più facilmente tra un&#39;implementazione e un&#39;altra.

</answer_text><num_votes>0</num_votes></answer><answer id="A3000"><answer_text>typedef, alla lettera: &#34;type definition&#34;, è un comando usato quando si ha bisogno di definire tipi di dato non presenti nativamente nel linguaggio C. Può essere usato anche solo per rinominare un tipo di dato con nomi più facili di quelli nativi (ad esempio, rinominare il tipo &#34;int &#34; in &#34;numeriInteri&#34;), ma la vera utilità sta nell&#39;usarlo insieme per nominare dei tipi array o matrici (non dovendo poi riscrivere le parentesi quadre ad ogni nuova variabile), enumerazioni, strutture complesse con all&#39;interno più tipi.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3103"><question_text>Quali vantaggi e quali svantaggi comporta l&#39;utilizzo di un puntatore per scorrere i caratteri di una stringa?</question_text><answer id="A3059"><answer_text>Per scorrere una stringa si utilizza sempre un puntatore, sia questa un array di char
(char a[100], a è un puntatore) o un puntatore a una stringa (char* s, s è un puntatore),
in ogni caso per scorrere le stringhe sono utili i puntatori poichè i vari caratteri alfanumerici
si troveranno a una distanza ben definita l&#39;uno dall&#39;altro (dimensione char=1byte), ovvero
8 bit di distanza, quindi ci basterà conoscere solo il primo puntatore per individuare tutti
i caratteri successivi della stringa.</answer_text><num_votes>1</num_votes></answer><answer id="A3015"><answer_text>Utilizzando un puntatore per scorrere i caratteri di una stringa si va ad agire sul contenuto della cella dell&#39;array di caratteri puntata in quel momento; è necessario quindi copiare il puntatore al primo elemento della stringa altrimenti scorrendola, il puntatore punterebbe alle aree di memoria successive e non si potrebbe più accedere a tali aree di memoria.</answer_text><num_votes>0</num_votes></answer><answer id="A3080"><answer_text>quando inizializzo ad esempio una struttura attraverso l inizializzazione classica il programma attua le modifiche alla copia della struttura data al programma nel main, se è inizializzata attraverso un puntatore il programma effettua delle modifiche all&#39;interno della struttura stessa. </answer_text><num_votes>0</num_votes></answer><answer id="A2998"><answer_text>Il vantaggio principale consiste nel non dover copiare il contenuto della stringa prima di scrorrerlo perchè il puntatore punta all&#39;indirizzo del dato (in questo caso i caratteri della stringa) e non al valore del dato. Questa proprietà è poco apprezzabile in piccoli programmi, ma diventa doverosa se si vogliono scorrere i caratteri di una stringa molto grande.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3111"><question_text>Le scritture *P=x; x=*P; x*=P; sono equivalenti? Nel caso in cui risultassero differenti, descriverne le caratteristiche.</question_text><answer id="A3099"><answer_text>Le scritture non sono equivalenti. La scrittura *P=x indica che il puntatore (*P) punta all&#39;indirizzo uguale a x, mentre x=*P associa ad x l&#39;indirizzo puntato da *P.
La terza scrittura invece risulta essere una moltiplicazione: x*=P equivale a x=x*P.
 
es. *P=x; x=23    -&#62; l&#39;indirizzo puntato è 23;
      x=*P; *P=4    -&#62; l&#39;indirizzo puntato risulta essere 4; 
      x=3; x*=4      -&#62; x=3*4=12;</answer_text><num_votes>0</num_votes></answer><answer id="A3054"><answer_text>Le tre scritture in questione non sono equivalenti, infatti svolgono ciascuna un&#39;operazione differente:
1)*P=x assegna alla cella di memoria puntata da P il valore della variabile x
2)x=*P assegna alla variabile x il valore contenuto nella cella di memoria puntata da P
3)x*=P equivale a scrivere x=x*P che assegna alla variabile x il valore del prodotto di sè stessa per il valore della variabile P.</answer_text><num_votes>2</num_votes></answer><answer id="A3064"><answer_text>Le tre scritture hanno significati completamente differenti. Il significato della prima scrittura (*P=x) è che P punta ad x. Quello della seconda è che x è uguale al valore puntato da P. Mentre la terza scrittura equivale a una moltiplicazione del genere x=x*P.</answer_text><num_votes>0</num_votes></answer><answer id="A3432"><answer_text>La scrittura *P=x indica che il puntatore P punta alla cella di memoria contenente la variabile x. La scrittura x=*P, invece, indica che alla variabile x si assegba il contenuto della cella di memoria puntata da P. La terza scrittura indica che la variabile x è pari a sé stessa moltiplicata P. </answer_text><num_votes>0</num_votes></answer><answer id="A2994"><answer_text>Le 3 istruzioni non sono equivalenti e portano a 3 risultati differenti.

&#34;*P=x&#34;: &#39;P&#39; punta al valore contenuto in &#39;x&#39; e perciò alla cella di memoria di indirizzo &#39;x&#39;.
Esempio: x=10; *P=x; =&#62; in &#39;P&#39; è contenuto &#34;10&#34; quindi &#39;P&#39; punta alla cella di indirizzo 10.

&#34;x=*P&#34;: ad &#39;x&#39; viene assegnato il valore contenuto nella cella puntata da &#39;P&#39;.
Esempio: *P=20; x=*P; =&#62; ad &#39;x&#39; viene assegnato &#34;20&#34;.

&#34;x*=P&#34;: l&#39;istruzione equivale a &#34;x=x*P&#34; perciò viene eseguita una moltiplicazione tra il valore di &#39;x&#39; ed il valore di &#39;P&#39;.
Esempio: x=20; P=10; =&#62; ad &#39;x&#39; viene assegnato 200.
</answer_text><num_votes>1</num_votes></answer></question><question id="Q3126"><question_text>cosa succede in memoria quando si utilizza un doppio puntatore?</question_text><answer id="A3119"><answer_text>Se viene definita una variabile del tipo char** p(la doppia de-referenziazione(**) indica che 
p è una variabile doppio puntatore), stiamo dicendo al compilatore che p punterà ad una cella di memoria il cui contenuto sarà a sua volta un indirizzo(in questo caso p sta puntando 
all&#39;indirizzo di un carattere). </answer_text><num_votes>1</num_votes></answer><answer id="A3067"><answer_text>Dichiarando un doppio puntatore per esmpio a int si crea una variabile che può contenere l&#39;indirizzo di una cella di memoria che può contenere l&#39;indirizzo di una cella di memoria che può contenere una variabile di tipo int. Quindi dereferenziandola una sola volta si ottiene ancora un indirizzo, mentre dereferenziandola due volte si ottiene un int.</answer_text><num_votes>1</num_votes></answer><answer id="A3049"><answer_text>Quando si dichiara un singolo puntatore, si riserva una parte della memoria al tipo di dato che viene richiamato dal puntatore. Molto semplicemente, in un doppio puntatore, il nuovo puntatore assegna un altro indirizzo al puntatore iniziale. </answer_text><num_votes>1</num_votes></answer></question><question id="Q3055"><question_text>Quali usi (nei puntatori e non) può avere il carattere &#39;*&#39;? </question_text><answer id="A3032"><answer_text>Il carattere &#39;*&#39; ha la funzione di operatore di dereferenzazione. Per esempio:
*a=16;
Questa riga di codice ci dice che nella cella il cui indirizzo è contenuto in &#39;a&#39; andiamo a mettere il valore 16.</answer_text><num_votes>1</num_votes></answer><answer id="A2980"><answer_text>Il carattere &#39;*&#39; può avere 3 usi:
1) simbolo di moltiplicazione: moltiplica fra di loro il right value di due variabili;
2) operatore di dereferenziazione (*a): accede al contenuto della cella di memoria avente come indirizzo il right value della variabile a;
3) dichiarazione di una variabile puntatore (int *a): dichiara una variabile nella cui cella di memoria verrà allocato un indirizzo ad un&#39;altra cella di memoria.</answer_text><num_votes>3</num_votes></answer></question><question id="Q3004"><question_text>In che cosa consiste l&#39;operazione di dereferenziazione?</question_text><answer id="A3055"><answer_text>La dereferenziazione (dereferencing) è l&#39;operazione che permette di poter modificare in modo dinamico, quindi anche da una funzione, una variabile.
L&#39;operazione consiste nell&#39;assegnare un valore alla variabile per riferimento, ovvero utilizzando il puntatore che individua quella variabile.
La scrittura comune nel caso di un dato strutturato è p-&#62;dato = valore.</answer_text><num_votes>1</num_votes></answer><answer id="A3062"><answer_text>L&#39;operazione di dereferenziazione è costituita da un operatore unitario ?*? che precede la variabile di tipo intero o tipo carattere. Per quest&#39;ultima, oltre ad avere la possibilità di inserire un testo di lunghezza diversa la quale dipende dal vettore bisogna ricordarsi che oltre al testo c&#39;è il NULL che ne indica il termine della stringa.</answer_text><num_votes>0</num_votes></answer><answer id="A3123"><answer_text>È l&#39;operazione fondamentale applicabile ai puntatori e consiste nel produrre come risultato l&#39;oggetto che viene puntato dal puntatore. Il simbolo che rappresenta questa operazione è &#34; * &#34;</answer_text><num_votes>3</num_votes></answer></question><question id="Q3040"><question_text>Come si effettua un&#39;operazione di assegnamento ad una variabile di tipo puntatore?</question_text><answer id="A3104"><answer_text>A una variabile di tipo puntatore si possono fare due tipi di assegnamento, si può fare in modo che il puntatore punti ad un certo valore (es. int *P;    *P=5;).
Oppure gli si può assegnare l&#39;indirizzo in memoria di un&#39;altra variabile (es. int *P, x;   P=&#38;x;) o di un altro puntatore (es. int *P, *Q;    P=Q;).</answer_text><num_votes>3</num_votes></answer><answer id="A2987"><answer_text>L&#39;operazione di assegnamento a variabile di tipo puntatore si fa utilizzando l&#39;operatore di deferenziazione (&#34;*&#34;) prima del nome della variabile, indicando il valore che assegnamo alla variabile deferenziata come si può vedere nel seguente esempio:
*x=5        </answer_text><num_votes>0</num_votes></answer><answer id="A3433"><answer_text>and then this tooooooooooo threeeeeeeeeeeeeeee</answer_text><num_votes>0</num_votes></answer><answer id="A2986"><answer_text>L&#39;operazione di assegnamento a variabile di tipo puntatore si fa utilizzando l&#39;operatore di deferenziazione (&#34;*&#34;) prima del nome della variabile, indicando il valore che assegnamo alla variabile deferenziata come si può vedere nel seguente esempio:
*x=5        </answer_text><num_votes>0</num_votes></answer></question><question id="Q3067"><question_text>Una funzione può restituire un array come risultato? Se no, perché? Se si, come?</question_text><answer id="A3081"><answer_text>La restituzione di un array da parte di una funzione può essere data da 4 metodi:
-returnString ritorna un&#39;istanza della classe string della libreria standard;
-returnArray ritorna il puntatore ad un array allocato dinamicamente nello heap(una volta che l&#39;array non serve più deve essere eliminato per evitare sprechi di memoria);
-setArray prende l&#39;indirizzo di un array nel quale andrà a scrivere i dati (array già predisposto per evitare sprechi di memoria);
-returnStruct ritorna il contenuto della struttura definita (richiede il trasferimento di tutti i caratteri al ritorno della funzione)</answer_text><num_votes>0</num_votes></answer><answer id="A2981"><answer_text>Non si può restituire un array di per sè stesso come tipo di ritorno di una funzione, ma si può passare come parametro (per rendere l&#39;array modificabile) o come variabile di ritorno un puntatore ad un array che consente poi nell&#39;ambiente dove è avvenuta l&#39;istanziazione della funzione in oggetto di gestirlo.</answer_text><num_votes>1</num_votes></answer><answer id="A2969"><answer_text>Una funzione non può restituire un array in quanto l&#39;invocazione provoca 
l&#39;allocazione di nuova memoria dove saranno copiati i parametri passati sulla quale
andrà ad agire.Passando un array alla funzione ne verrà creata una copia che sarà poi modificata.
Il problema sta nel ritornare l&#39;array come risultato della funzione:essa ritornerà il puntatore 
della zona di memoria dell&#39;array(copia)non l&#39;array modificato che si trova nell&#39;area di memoria
che sarà deallocata al termine della funzione perdendone il contenuto.
Per fare ciò si deve passare l&#39;array per riferimento(puntatore).</answer_text><num_votes>0</num_votes></answer><answer id="A3036"><answer_text>In C/C++ una funzione NON può restituire direttamente un array ma quello che possiamo fare è far restituire alla funzione il puntatore al primo elemento dell&#39;array
Quando vogliamo fare questo dobbiamo ricordarci due cose fondamentali:
-definire la funzione come un puntatore al tipo di dato che forma l&#39;array Es: int* funz(..){..}
-se alla fine della funzione si ritorna il puntatore definito all&#39;interno della funzione questa non funzionerà perché la memoria nella quale il puntatore è salvato viene deallocata alla fine della funzione (va quindi usata la funzione new e usata la memoria heap)
</answer_text><num_votes>2</num_votes></answer><answer id="A3076"><answer_text>Una funzione potrà restituire soltanto il puntatore ad un array che la funzione ha creato nell&#39;heap e sulla quale ha controllo di allocazione e deallocazione. Infatti non è possibile l&#39;assegnamento di array, e l&#39;area di memoria dello stack viene deallocata al termine della funzione stessa.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3044"><question_text>Come mai possiamo dire che la dicitura 
	p[3]
è equivalente a scrivere
	*(p+3) ?</question_text><answer id="A2968"><answer_text>Questa scrittura è possibile poichè nel C, la relazione tra puntatore e vettore è cosi&#39; stretta da consentirne la traduzione simultanea.
Ovvero, p[3] definisce un vettore p di ampiezza 3, mentre *(p+3) punta al 3° elemento del valore puntato da p.
</answer_text><num_votes>0</num_votes></answer><answer id="A3075"><answer_text>Con la dicitura p[3] il compilatore va all&#39;indirizzo di memoria indicato da p, più i byte necessari per la memorizzazione del tipo di dato da cui è composto l&#39;array moltiplicandoli per [3] (la posizione richiesta) e ne prende il valore (la deferenziazione è implicita nella dicitura). Nel secondo caso vengono usati gli operatori di precedenza &#34;()&#34; per indicare la posizione del dato dell&#39;array richiesto e con l&#39;operatore &#34;*&#34; viene effettuata la deferenziazione. Le diciture anche se diverse, effettuano la stessa operazione e quindi sono equivalenti.</answer_text><num_votes>1</num_votes></answer><answer id="A3013"><answer_text>Perché p è un array e &#34;punta&#34; al primo elemento dell&#39;array stesso... quindi con la seconda operazione aumento p di tre posizioni e lo faccio puntare alla terza posizione</answer_text><num_votes>0</num_votes></answer><answer id="A2988"><answer_text>E&#39; possibile accedere ad un array in modi differenti: scrivendo  p[3]  accediamo all&#39;elemento dell&#39;array in posizione 3 (cioè il quarto, contando anche lo 0!); scrivendo invece *(p+3) eseguiremo 2 operazioni:
1) partendo dalla posizione puntata da p (cioè la posizione 0 dell&#39;array), ci spostiamo in avanti di 3 indirizzi, facendo così riferimento alla cella dell&#39;array in posizione 3 (la quarta, come sopra).
2) con l?operatore di dereferenziazione ? * ? andremo a leggere il valore della cella di memoria che abbiamo appena individuato al punto 1.</answer_text><num_votes>2</num_votes></answer><answer id="A3014"><answer_text>Perché p è un array e &#34;punta&#34; al primo elemento dell&#39;array stesso... quindi con la seconda operazione aumento p di tre posizioni e lo faccio puntare alla terza posizione</answer_text><num_votes>0</num_votes></answer><answer id="A2999"><answer_text>*P indica la cella di memoria il cui indirizzo è contenuto in P.

p[3]: fa riferimento alla 3 cella dell&#39;array.
*p: punta a &#34;p&#34; e con +3, alla terza cella dell&#39;array.

La differenza sostanziale è che il primo risulta più semplice-compatto e più pratico da utilizzare. 
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2992"><question_text>Cosa significa dereferenziare un puntatore?</question_text><answer id="A2985"><answer_text>Deferenziare un puntatore significa accedere al contenuto della variabile a cui punta. L&#39;operatore di dereferenziazione è * (lo stesso simbolo usato per l&#39;inizializzazione dei puntatori)
esempio:
int a;
int *p; //inizializzo puntatore
p=&#38;a; // assegno a p l&#39;indirizzo di a
*p=10; // modifico il contenuto di a attraverso la dereferenziazione di p</answer_text><num_votes>1</num_votes></answer><answer id="A2979"><answer_text>Puntatore indica l&#39;indirizzo della variabile cui fa riferimento, la dichiarazione: 
typedef TipoDato  *TipoPuntatore
-TipoDato definisce quale tipo di variabile può essere referenziata  
-*TipoPuntatore è l&#39;indirizzo di un&#39;altra variabile, il cui tipo è TipoDato
L&#39;accesso ad una variabile di tipo puntatore avviene attraverso l&#39;operatore di dereferenziazioneindicato dal simbolo &#34;*&#34; posto prima dell&#39;identificatore del puntatore.</answer_text><num_votes>0</num_votes></answer><answer id="A3095"><answer_text>dereferenziare un puntatore significa andare a leggere il valore contenuto nella cella di memoria che si trova all&#39;indirizzo contenuto nel puntatore.Per farlo si utilizza l&#39;operatore di dereferenziazione &#34; * &#34;.</answer_text><num_votes>1</num_votes></answer><answer id="A3118"><answer_text>L&#39;operazione di de-referenziazione (o risoluzione del riferimento), è costituita da un operatore unario ( cioè con un solo operando ) ed applicata ad un puntatore precedentemente inizializzato permette di ottenere come risultato l&#39;oggetto a cui esso punta. In sostanza per dereferenziazione si intende l&#39;accesso alla cella di memoria puntata dal puntatore. Dereferenziare un puntatore non inizializzato è un errore. Esempio: int x=5; int *ptr=&#38;x;  (inizializzazione puntatore) int z=*ptr; (dereferenziazione puntatore)</answer_text><num_votes>1</num_votes></answer><answer id="A3007"><answer_text>Con il termine dereferenziare si vuole indicare il contenuto della cella 
di memoria puntata dal puntatore.












</answer_text><num_votes>0</num_votes></answer><answer id="A3069"><answer_text>Esempio: 
...
int *p;
*p=7;
...


p = puntatore
* = operatore di deferenziazione.

In breve referenziare un puntatore significa denotare/indicare il contenuto della cella di memoria avente come indirizzo di memoria &#39;p&#39;.
Svelare il contenuto di una cella puntata dal puntatore &#39;p&#39;</answer_text><num_votes>0</num_votes></answer></question><question id="Q3043"><question_text>A che cosa serve l&#39;operatore sizeof() e che tipo di dato restituisce?</question_text><answer id="A3040"><answer_text>L?operatore sizeof produce il numero di byte occupati da ciascun elemento di un array o da un array nel suo complesso. restituisce un integer</answer_text><num_votes>0</num_votes></answer><answer id="A3017"><answer_text>L&#39;operatore sizeof() restituisce un numero di tipo int, il dato che restituisce e&#39; il numero di byte occupati in memoria dal tipo di variabile inserito come argomento della funzione sizeof().</answer_text><num_votes>1</num_votes></answer><answer id="A3016"><answer_text>L&#39;operatore sizeof() restituisce un numero di tipo int, il dato che restituisce e&#39; il numero di byte occupati in memoria dal tipo di variabile inserito come argomento della funzione sizeof().</answer_text><num_votes>1</num_votes></answer></question><question id="Q3018"><question_text>Perchè quando si dichiara un puntatore bisogna indicare anche il tipo di dato puntato?</question_text><answer id="A2992"><answer_text>Rispondo con un esempio: il tipo double si rappresenta con 8 byte; definisco p come double *p, (p puntatore a double). 
Per l&#39;aritmetica dei puntatori, (p+3) è l&#39;indirizzo del terzo elemento della sequenza puntata da p.
Allora, dato che ogni reale occupa otto byte, il valore numerico di p+3 è il valore numerico di p più 3*8. 
Il valore di p cambierà, quindi, al cambiare del tipo di dato cui punta (per rappresentare un int, float, char o double non occorre la stessa quantità di memoria, varia da tipo di dato a tipo di dato). Da qui l&#39;importanza di indicare anche il tipo di dato puntato!</answer_text><num_votes>3</num_votes></answer><answer id="A3106"><answer_text>Perche&#39; nel caso io debba svolgere operazioni di assegnamento incomberei nell&#39;errore di incompatibilita&#39; tra tipi diversi di dato.
Percui avendo un intero (int a) e un puntatore ad intero (int *p) quando andro&#39; a fare l&#39;assegnamento (p=&#38;a) non incombero&#39; nell&#39;errore di incompatibilita&#39; tra tipi diversi di dato.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3034"><question_text>A cosa serve passare l&#39;indirizzo di una variabile anziché il valore della stessa ad una funzione?</question_text><answer id="A3078"><answer_text>Attraverso l&#39;uso dei puntatori è possibile passare l&#39;indirizzo di una variabile anzichè il valore della stessa per risparmiare memoria; 
infatti passando il riferimento della variabile (ovvero l&#39;indirizzo) la funzione accede in maniera più rapida alla memoria e può modificare i valori interessati.
é importante chiamare la funzione attraverso il suo indirizzo e non passando il valore della variabile poichè utilizzando quest?ultimo metodo può avvenire 
lo scambio di contenuto di due aree casuali della memoria, provocando danni possibilmente all?intero sistema e non solo al programma.</answer_text><num_votes>0</num_votes></answer><answer id="A3072"><answer_text>Passare l&#39;indirizzo di una variabile anzichè il valore della stessa può essere utile in quanto fornisce maggiore flessibilità e velocizza le operazioni con variabili molto grandi in memoria. Se per esempio supponiamo di avere una variabile che occupa molto spazio, invece che copiarla in più punti del programma con un conseguente spreco di tempo e memoria è molto più comodo utilizzare un puntatore che punta all&#39;indirizzo di memoria della variabile.</answer_text><num_votes>4</num_votes></answer></question><question id="Q3049"><question_text>Nel linguaggio C/C++ il simbolo [*] rappresenta tre cose distinte. Illustrare il suo utilizzo fornendo alcuni esempi di codice per ogni funzione svolta.</question_text><answer id="A3058"><answer_text>Nel linguaggio C/C++ il simbolo unario [*] puo&#39; essere utilizzato per tre istruzioni distinte:
-l&#39;operazione di moltiplicazione con numeri e/o con variabili (a = 2*3; oppure a = b*4);
-l&#39;operazione di dereferenziazione, cioe&#39; la creazione dei puntatori, indicatori degli indirizzi di variabili (puo&#39; essere esso stesso dichiarato come variabile attraverso typedef)(TipoDato *TipoPuntatore;);
-la scrittura di codice nel programma come, ad esempio, per inserire dei commenti su piu&#39; righe di codice attraverso &#34;/*&#34; commento &#34;*/&#34;.</answer_text><num_votes>2</num_votes></answer><answer id="A3003"><answer_text>L&#39;asterisco nel linguaggio c/c++ può essere il simbolo della moltiplicazione(1), può rappresentare un puntatore (2a) o un doppio puntatore (2b) oppure abbinato a &#34;/&#34; riduce una parte di codice e testo ad un semplice commento (3).
1. z = x*y-a
2a. int* nome 
2b. char** stringa
3. /* int a=7; printf (&#34;%d&#34;, a); */</answer_text><num_votes>1</num_votes></answer><answer id="A3033"><answer_text>Nel linguaggio C/C++ il simbolo[*] rappresenta:
- Per prima cosa l&#39;operatore unario de-deferenziazione del puntatore  o quello usato per dichiarare un puntatore. Il puntatore è una variabile che contiene l&#39;indirizzo di memoria di un&#39;altra variabile.
Esp: char* primo;
- Può essere usato come operatore aritmetico nelle moltiplicazioni.
Esp: z=x*y;
- Può essere usato insieme / per commentare su più righe nel programma.
Esp: /*calcolo la lunghezza di una stringa*/</answer_text><num_votes>1</num_votes></answer></question><question id="Q2999"><question_text>Cosa succede se si dimentica uno o più &#34;break&#34; in un costrutto &#34;switch&#34;?</question_text><answer id="A3034"><answer_text>il break è un comando che ci permette di uscire da un costrutto, infatti nel caso dello switch case nel caso vi fosse l&#39;entrata in un &#34;case&#34; contenente la seguente istruzione verrebbe concluso tutto il blocco della comparazione; inoltre è impostante dire che l&#39;istruzione break ci permette di uscire anche da costrutti diversi (ad esempio i cicli). non includere il break in uno o più &#34;case&#34; fa si che la comparazione continui con i case successivi; non è detto che ciò sia un male, però la progettazione del programma risulta decisamente più intricata. 
</answer_text><num_votes>1</num_votes></answer><answer id="A3071"><answer_text>Se di dimentica uno o più break in un costrutto switch, nel caso in cui sia verificato il caso di cui si dimentica il break verrà eseguita sia l&#39;istruzione dovuta a quel caso sia l&#39;istruzione del caso successivo. Se ad esempio il mio programma deve valutare il valore di una variabile intera (supponiamo di avere int a=1), nel caso in cui il mio blocco di istruzioni sia: 
switch(a){
case 0:printf(&#34;zero&#34;);break;
case 1:printf(&#34;uno&#34;);
case 2:printf(&#34;due&#34;);break;
default:printf(&#34;nessuno dei precedenti&#34;);
}
il programma eseguirà sia l&#39;istruzione del case 1, sia l&#39;istruzione del case 2.</answer_text><num_votes>3</num_votes></answer><answer id="A3018"><answer_text>L?istruzione break permette di uscire dal blocco switch, se tale istruzione viene 
dimenticata, vengono eseguite tutte le istruzioni che seguono il case desiderato (anche 
quelle dei case successivi).</answer_text><num_votes>1</num_votes></answer></question><question id="Q3042"><question_text>Che operazioni di deferenzazione sono necessarie per descrivere l&#39;indirizzamento di una matrice m[i][j]?
I gli array multidimensionali possono essere descritti come puntatori ad n-dimensioni?</question_text><answer id="A3110"><answer_text>Un array multidimensionale può essere descritto come un puntatore ad n-dimensioni in quanto ciascun elemento dell&#39;array altro non è che un array a sua volta; in questo modo risulta semplice poter rappresentare delle matrici come m[i][j], che è una matrice di i righe e j colonne.</answer_text><num_votes>1</num_votes></answer><answer id="A2974"><answer_text>Per descrivere l&#39;indirizzamento di una matrice è oppurtuno fare la seguente operazione deferenziazione: *(*(m+NC*i)+j) , dove m è la matrice e NC il numero di colonne. </answer_text><num_votes>1</num_votes></answer><answer id="A2973"><answer_text>Per descrivere l&#39;indirizzamento di una matrice è oppurtuno fare la seguente operazione deferenziazione: *(*(m+NC*i)+j) , dove m è la matrice e NC il numero di colonne. 
Si, gli array multidimensionali possono essere descritti come puntatori ad n-dimensioni. Utilizzando la formula citata sopra possso creare n-dimensioni. </answer_text><num_votes>1</num_votes></answer><answer id="A2972"><answer_text>Per descrivere l&#39;indirizzamento di una matrice è oppurtuno fare la seguente operazione deferenziazione: *(*(m+NC*i)+j) , dove m è la matrice e NC il numero di colonne. 
Si, gli array multidimensionali possono essere descritti come puntatori ad n-dimensioni. Utilizzando la formula citata sopra possso creare n-dimensioni. </answer_text><num_votes>0</num_votes></answer><answer id="A3116"><answer_text>Gli array sono rappresentati internamente dal compilatore come puntatori alla prima locazione di memoria allocata. E&#39; quindi possibile accedere all&#39;array anche con la sintassi dei puntatori:
a[i] &#38;#8594; *(a+i)
ma[i][j] &#38;#8594; **(ma+i**j+j)</answer_text><num_votes>1</num_votes></answer><answer id="A2975"><answer_text>Per descrivere l&#39;indirizzamento di una matrice è oppurtuno fare la seguente operazione deferenziazione: *(*(m+NC*i)+j) , dove m è la matrice e NC il numero di colonne. 
Si, gli array multidimensionali possono essere descritti come puntatori ad n-dimensioni. Utilizzando la formula citata sopra possso creare n-dimensioni. </answer_text><num_votes>1</num_votes></answer><answer id="A2983"><answer_text>Per descrivere l&#39;indirizzamento di una matrice è oppurtuno fare la seguente operazione deferenziazione: *(*(m+NC*i)+j) , dove m è la matrice e NC il numero di colonne. 
Si, gli array multidimensionali possono essere descritti come puntatori ad n-dimensioni. Utilizzando la formula citata sopra possso creare n-dimensioni.
</answer_text><num_votes>0</num_votes></answer></question><question id="Q3082"><question_text>Si potrebbe dire che una variabile di tipo array è un puntatore? E&#39; possibile accedere alle celle di memoria di un array o di una matrice utilizzando gli operatori di dereferenziazione invece che le parentesi quadre? Come?</question_text><answer id="A3009"><answer_text>si punta alla prima cella di memoria. si è possibile accedere utilizzando gli operatori di dereferenziazione: *.</answer_text><num_votes>0</num_votes></answer><answer id="A3008"><answer_text>Si, l&#39;array può essere definito anche come puntatore. La sua dichiarazione comporta infatti l&#39;allocazione della memoria per la variabile puntatore rappresentata dal nome dell&#39;array e per l&#39;area puntata. Questo puntatore è inizializzato con l&#39;indirizzo del primo elemento dell&#39;array. Ogni elemento dell&#39;array è quindi accessibile tramite operatori di dereferenziazione; per esempio le espressioni A[i] e *(A+i) producono lo stesso risultato. 
</answer_text><num_votes>1</num_votes></answer><answer id="A2977"><answer_text>Si,la variabile di tipo array è un puntatore, il nome dell&#39;array infatti è un puntatore che indirizza al primo elemento dell&#39;array. Sapendo questo è poi possibile accedere ai valori contenuti nelle singole celle di un dayto strutturato usando gli operatori di defernzazione e le operzioni sui puntatori; questo è possibile sapendo che le celle di un dato di questo tipo sono sempre tutte consecutive.(Esempio (a[i] coincide con *(a+i) o a ia[]) N.B. per le matrici la cosa diventa un pò più complessa perche il puntatore è doppio e si necessita di muoversi in entrambe le direzioni (righe e colonne).</answer_text><num_votes>5</num_votes></answer></question><question id="Q3091"><question_text>Può essere effettuato un&#39;assegnamento tra un puntatore e una variabile?</question_text><answer id="A3088"><answer_text>Il puntatore è una variabile che contiene l&#39;indirizzo di memoria di un&#39;altra variabile.

Per assegnare ad un puntatore l&#39;indirizzo di una variabile è necessario dichiararlo (per specificare a che tipo di dato dovrà puntare) ed eventualmente assegnargli una cella di memoria.

Attraverso l&#39;operatore di deferenziazione &#34;*&#34; è possibile accedere alla cella puntata per assegnargli un valore (ad esempio *P = x, in questo moto si assegna il valore di x alla cella a cui il puntatore fa riferimento.)

</answer_text><num_votes>1</num_votes></answer><answer id="A3022"><answer_text>Se per &#34;assegnamento tra un puntatore e una variabile&#34; si intende che il puntatore può assumere il valore della variabile allora si:
c=3
*a=&#38;c
secondo me era giusto anche il caso in cui la variabile assumeva il valore a cui puntava il puntatore</answer_text><num_votes>0</num_votes></answer><answer id="A3023"><answer_text>Se per assegnamento si intende che il puntatore può assumere il valore puntato dal puntatore allora si:
c=3
*a=&#38;c
</answer_text><num_votes>0</num_votes></answer><answer id="A2997"><answer_text>Sì, basta però ricordarsi che l&#39;operatore &#34; * &#34; ha priorità rispetto agli operatori matematici, ad esempio 
x=2 * *p  equivale a dire x= 2*(*p)
</answer_text><num_votes>0</num_votes></answer><answer id="A2995"><answer_text>l&#39;assegnamento tra un puntatore e una variabile può essere sicuramente fatto e spesso è anche molto conveniente per 2 motivi: per una questione di risparmio di memoria e per il fatto che attraverso l&#39;assegnamento con un puntatore si va a modificare direttamente nella cella originaria.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3073"><question_text>In quali casi è utile dichiarare la variabile contatore &#34;i&#34; direttamente all&#39;interno dell&#39;intestazione del costrutto &#34;for&#34;?
Esempio: 
for(int i=0; i&#60;10; i++){

//programma

}</question_text><answer id="A2990"><answer_text>E&#39; utile dichiarare un contatore &#34;i&#34; direttamente all&#39;interno di un ciclo for quando si ha un gran numero di righe di codice e non si vuole ritornare in cima al programma per dichiarare tale variabile int.
Questo funziona in quanto in questo modo si crea una variabile locale al for che viene deallocata appena il ciclo termina, e quindi si usa quando il contatore non serve successivamente, per utilità successive al ciclo.</answer_text><num_votes>4</num_votes></answer><answer id="A3113"><answer_text>Solitamente, per  comodità, si dichiara la variabile &#34;i&#34; all&#39;interno dell&#39;intestazione nei casi in cui quella variabile viene utilizzata solo all&#39;interno del ciclo e non al di fuori. In sè non cambia nulla se si dichiara prima (int i=0) e nell&#39;intestazione si scrive solo i=0.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3119"><question_text>che tipo di assegnamento è fattibile sui puntatori?</question_text><answer id="A3001"><answer_text>Il linguaggio C, grazie all&#39;aritmetica dei puntatori, permette lo svolgimento di un&#39;ampia gamma di operazioni (tra cui assegnamenti) su puntatori per una costruzione più efficiente e dinamica di programmi. Infatti oltre ad assegnare semplici valori, in una variabile puntatore [es: int *P] possiamo memorizzare sia l&#39;indirizzo di memoria precisa di una variabile [P=&#38;x] sia una zona di memoria allocata nello heap [P=new int]. Inoltre l&#39;uso di puntatori risulta indispensabile nell&#39;inizializzazione di array (all&#39;interno di funzioni) e nell&#39;accesso ai campi di una struttura(mediante la dot notation)</answer_text><num_votes>1</num_votes></answer><answer id="A3105"><answer_text>Sui puntatori è possibile effettuare diversi tipi di assegnamento, in particolare:
- assegnamento dell?indirizzo di una variabile tramite l&#39;operatore
unario &#38;;
- assegnamento del valore di un altro puntatore;
- assegnamento del valore speciale NULL;
- assegnamento di indirizzi di memoria a seguito di operazioni
di allocazione esplicita di memoria.</answer_text><num_votes>2</num_votes></answer></question><question id="Q3063"><question_text>Che senso ha il seguente codice/che vantaggi mi dà?
Typedef int *a;
Data la riga sopra se voglio dichiarare una variabile b puntatore a intero cosa devo scrivere (chiaramente utilizzando il codice sopra, non int *b)? posso omettere * scrivendo
a b;
?
Se poi voglio visualizzare il contenuto della cella a cui punta b come faccio?</question_text><answer id="A3082"><answer_text>Il seguente codice crea un tipo puntatore ad intero a. Non si può scrivere a b; e non si può omettere il simbolo di dereferenziazione. Posso visualizzare il contenuto di una cella di memoria tramite l&#39;utilizzo dell&#39;operatore sizeof.</answer_text><num_votes>0</num_votes></answer><answer id="A3097"><answer_text>il codice ha poco senso, un vantagio è non scrivere * ogni volta, però si ha un tipo di dato che non si capisce se dichiara puntatori o meno. sarebbe meglio definirlo p_a.

Definendo un nuovo tipo di dato a che sarà un puntatore ad interno si può omettere * e sarà sufficente scrivere a b; equivalente a scrivere int* b;

Per visualizzare il contenuto della cella a cui punta b è sufficente porre * davanti a b per trattarlo come &#34;puntato da b&#34;. In questo caso il puntato da b (*b) è di tipo intero e quindi in un printf() basterà usare %i per stamparlo.
printf(&#34;Puntato da b: %i&#34;, *b);</answer_text><num_votes>4</num_votes></answer><answer id="A2982"><answer_text>Eh non mi ricordo bene</answer_text><num_votes>0</num_votes></answer></question><question id="Q3106"><question_text>Cos&#39;è la &#34;dot notation&#34;? Come si utilizza?</question_text><answer id="A3120"><answer_text>La &#34;dot notation&#34; è uno schema sintattico tipico del linguaggio C e viene utilizzata attraverso l&#39;uso di un punto per accedere al contenuto di memoria denotato da un certo oggetto.</answer_text><num_votes>2</num_votes></answer><answer id="A3045"><answer_text>La dot notation si usa in C per accedere a singoli campi di una struttura: si scrive l&#39;identificatore della struttura seguito da un punto e dall&#39;identificatore del campo desiderato.</answer_text><num_votes>1</num_votes></answer><answer id="A3044"><answer_text>La dot notation si usa in C per accedere a singoli campi di una struttura: si scrive l&#39;identificatore della struttura seguito da un punto e dall&#39;identificatore del campo desiderato.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3105"><question_text>A cosa serve l&#39;operatore &#34;freccetta&#34; (-&#62;) nell&#39;ambito dei puntatori?</question_text><answer id="A3019"><answer_text>l operatore&#34; -&#62; &#34; serve per accedere ai campi di una struct tramite puntatore.
Si procede dereferenziando il puntatore con l operatore * seguito dal &#34; . &#34; es (*p).nome.
In C/C++ esiste una forma compatta per descrivere questa operazione ed è appunto
 l&#39;operatore &#34; -&#62; &#34;(freccetta).
Cioè le scritture (*p).nome e p-&#62;nome sono equivalenti.</answer_text><num_votes>1</num_votes></answer><answer id="A2970"><answer_text>Siccome la dot notation (.) ha la precedenza su (*), necessario per un puntatore, se si usano dati strutturati si avrebbe una scrittura estremamente pesante e complicata che sarebbe per esempio: (v*).prova, che, come si nota, richiederebbe l&#39;utilizzo di parentesi per sistemare le precedenze. Allora il compilatore c/c++ ci aiuta inserendo un unico operatore che sintetizza entrambe le operazioni (.) e (*). Questo operatore è appunto la freccetta (-&#62;), la quale non richiede l&#39;utilizzo di parentesi o particolari attenzioni.
</answer_text><num_votes>0</num_votes></answer><answer id="A3010"><answer_text>L&#39;operatore freccetta è stato introdotto per semplificare la scrittura all&#39;interno delle funzioni delle strutture passate per riferimento
Es:
typedef struct{
          int a;
}struttura;
//Senza operatore freccetta:
void funzione (struttura *s){
          (*s).a=3;
}
//Con operatore freccetta:
void funzione (struttura *s){
          s-&#62;a=3;
}
Le due funzioni sono equivalenti ma con l&#39;operatore freccetta il codice risulta più leggibile</answer_text><num_votes>0</num_votes></answer><answer id="A2967"><answer_text>E&#39; utile nel caso in cui dovessimo accedere tramite puntatore ad un elemento di una struct.
Infatti supponendo di dover accedere ad un ipotetico campo &#34;*persona.altezza&#34;, con la seguente scrittura il compilatore non sarebbe in grado di capire cosa dereferenziare.
Detto ciò esistono due tipi di notazione: &#34;(*persona).altezza&#34; oppure quella più utilizzata 
&#34;persona-&#62;altezza&#34;.Dunque il compilatore interpreterà &#34;persona&#34; come puntatore.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3051"><question_text>In C si possono eseguire operazioni di somma su un puntatore? Se sì, in che modo?</question_text><answer id="A3090"><answer_text>Ad un puntatore non può essere sommato un altro puntatore, ma ad esso può essere sommato un intero. Il risultato  della somma è l&#39;indirizzo dato dal puntatore incrementato del risultato della moltiplicazione tra l&#39;intero specificato e la dimensione del tipo base del puntatore espressa in byte. Per esempio, se p è un puntatore al tipo intero int (int *p) di valore 1000 (p=1000), essendo due byte la dimensione di un int, p+1 vale 1002, p+2 vale 1004, e in generale p+n vale 1000+n*2.</answer_text><num_votes>0</num_votes></answer><answer id="A3041"><answer_text>/*Le operazioni di somma in C sono possibili; è necessario che la somma dei due 
puntatori sia memorizzata in una varibiale, perchè in caso contrario verrebbero 
sommati gli indirizzi a cui puntano i puntatori. Qui sotto un esempio di come 
si poteva fare la somma di due pumntatori:
*/
#include &#60;stdio.h&#62;
#include &#60;stdlib.h&#62;
int main(int argc, const char * argv[]){
    int x=5;
    int* p_x = &#38; x;
    int y=6;
    int* p_y = &#38; y;
    int a = *p_x+*p_y;
    printf(&#34;%d \n&#34;,a);
    return 0;
}
//Versione per Mac</answer_text><num_votes>0</num_votes></answer><answer id="A2964"><answer_text>Si, siccome le variabili puntatore contengono un indirizzo che altro non è che un numero, io posso sommare un intero, questo viene usato dal sistema negli array, intatti se io voglio ottenere l&#39;elemento x: array[x], il sistema somma all&#39;indirizzo array x, cosi ottengo l&#39;indirizzo nella posizione di memoria ricercata</answer_text><num_votes>1</num_votes></answer></question><question id="Q3046"><question_text>In che cosa il costrutto &#34;switch&#34; è diverso dal costrutto &#34;if&#34;?</question_text><answer id="A3111"><answer_text>Nella maggior parte dei casi lo switch case - default fa lo stesso lavoro di if - else if - else a patto che si abbiano solo operatori di uguaglianza (==). In questi casi cambia solo la sintassi e, con (relativamente) poche linee di codici tra un caso e l&#39;altro, quella dello switch case risulta più pulita e più sintetica.</answer_text><num_votes>0</num_votes></answer><answer id="A3025"><answer_text>L&#39;if verifica se una condizione passata come parametro è &#34;vera&#34;, ed in tal caso effettua un&#39;azione; in caso contrario (&#34;else&#34;) ne effettua un&#39;altra (opzionale).
E&#39; possibile avvalersi, inoltre, di elseif, che implementa un nuovo blocco if all&#39;interno del precedente, per cui è possibile costruire if annidati. Il costrutto switch consente anch&#39;esso di valutare un&#39;espressione O UN VALORE passati come parametro e di intraprendere, in base al valore di tale espressione o del parametro, azioni differenti; a differenza dell&#39;if, comunque, è più &#34;ordinato&#34;.</answer_text><num_votes>0</num_votes></answer><answer id="A3028"><answer_text>Il costrutto &#34;switch&#34; a differenza di quello &#34;if&#34;, può valutare solamente una variabile da cui dipenderanno tutte le scelte fatte dal compilatore.
Inoltre ogni singolo valore della variabile può controllare solo una singola scelta, eccezion fatta per il comando default che controlla tutte le variabili che non sono state specificate in precedenza.
Se già conosco le variabili in gioco il costrutto &#34;switch&#34; potrebbe essere preferibile in quanto mi garantisce il controllo sulle singole variabili.
In tutti gli altri casi risulta migliore il costrutto &#34;if&#34; dato che controlla più variabili.</answer_text><num_votes>1</num_votes></answer><answer id="A2978"><answer_text>Il costrutto switch permette di confrontare solo variabili di tipo intero (o carattere) con più interi (o caratteri), consentendo un confronto a più casi; a differenza del costrutto if che consente di confrontare variabili di qualunque tipo, tuttavia con un solo caso di confronto.</answer_text><num_votes>0</num_votes></answer><answer id="A2976"><answer_text>Con il costrutto &#34;switch&#34; è possibile confrontare solo variabili di tipo intero (o caratteri) con altri interi (o caratteri), contemplando più casi; a differenza del costrutto &#34;if&#34; dove è possibile confrontare un qualunque tipo di dato, che tuttavia contempla un solo caso.</answer_text><num_votes>0</num_votes></answer><answer id="A3004"><answer_text>A differenza del if lo switch permette di valutare più condizioni diverse nello stesso ciclo.
Le condizioni dello switch possono però essere solo di uguaglianza, mentre con l&#39;if si possono avere anche di disuguaglianza, maggioranza o minoranza.
</answer_text><num_votes>0</num_votes></answer></question><question id="Q3124"><question_text>date le seguenti dichiarazioni:
1) char* stringa1=&#34;Questa è una stringa&#34;;
2) char stringa2[100];
3) char stringa3[]=&#34;Questa è una stringa&#34;; 
4) char* stringa4= new char[100].
Quali sono le principali differenze?</question_text><answer id="A3092"><answer_text>Il primo è un puntatore al primo elemento di una stringa, il secondo è un array di 100 caratteri, mentre il terzo è un array la cui lunghezza verrà definita dal compilatore. Sono tutte e tre strutture che risiedono nello &#34;stack&#34;
L&#39;ultimo è un puntatore ad un array allocato dinamicamente tramite la funzione new. Il puntatore è nello stack mentre la funzione risiede nell&#39; &#34;heap&#34;</answer_text><num_votes>1</num_votes></answer><answer id="A3038"><answer_text>Una delle principali differenze sta nelle gestione delle dichiarazioni: le prime tre vengono gestite in modo statico all&#39;interno dello stack, la quarta viene gestita in modo dinamico nell&#39;heap.
1 e 3 sono equivalenti, dichiarano entrambe un array di char la cui dimensione è ricavata dal calcolatore dalla frase con cui sono inizializzate e aggiungendo il carattere NULL.
Nella 2 si dichiara staticamente un array di char di 100 elementi, in questo caso nell&#39;inizializzazione si dovrà aggiungere manualmente il carattere NULL alla fine della stringa per evitare problemi nella gestione come stringa</answer_text><num_votes>1</num_votes></answer></question><question id="Q3047"><question_text>Quali sono i  vantaggi a creare una funzione che prende come input l&#39;indirizzo del dato rispetto ad una a cui gli si passa il dato stesso?
In che casi è meglio prediligere una? In che casi l&#39;altra?</question_text><answer id="A3117"><answer_text>Passando il dato non si fa altro che allocare una quantità di memoria delle stesse dimensioni di quella di partenza e copiarne l&#39;intero contenuto. Passando l&#39;indirizzo è invece possibile si evita questo passaggio e si va quindi a lavorare direttamente sulla variabile&#34;originale&#34; senza salvaguardarne il contenuto. Il secondo metodo richiede quindi meno memoria ma può essere pericoloso in alcuni casi in quanto si agisce direttamente sulle variabili originali.</answer_text><num_votes>0</num_votes></answer><answer id="A3121"><answer_text>nel creare un funzione è possibile passare in input a questa un puntatore, in modo da alleggerire il programma e diminuire la quantità di memoria occupata, poiché il puntatore non  contiene effettivamente dati, ma un indirizzo(più leggero). In alcuni casi tuttavia l&#39;utilizzo del puntatore rischia di complicare la funzione rendendola meno fruibile all&#39;utente, o creando dei possibili effetti collaterali dovuti ad un utilizzo non corretto del passaggio per indirizzo. </answer_text><num_votes>0</num_votes></answer><answer id="A3063"><answer_text>Il passaggio per valore consente di accedere ad una copia della variabile, di conseguenza
il valore effettivo di tale variabile non può essere modificato.
Invece il passaggio per indirizzo implica il passaggio del puntatore all&#39;area di memoria richiesta,
pertanto possiamo modificare il suo valore anche al di fuori della chiamata della funzione.
Si preferisce usare il secondo metodo quando il parametro di ingresso sono sturct o Array
perché vogliamo modificarne il contenuto, poiché tramite passaggio di valore si modifica solo la copia della variabile della funzione.</answer_text><num_votes>0</num_votes></answer><answer id="A3030"><answer_text>Una variabile di tipo puntatore è una variabile che punta all&#39;indirizzo in memoria. I vantaggi nell&#39;usare i puntatori in una funzione sono che prima di tutto si ha una allocazione dinamica della memoria il che consente di allocare una quantità di memoria arbitraria, secondariamente si passa la variabile non più facendo una copia di essa ma passandola per riferimento. Quindi con l&#39;uso dei puntatori in generale, ma soprattutto nelle funzioni, si risparmia memoria il che li rende molto utili quando abbiamo a che fare con funzioni o array molto grandi o nel caso delle liste.</answer_text><num_votes>0</num_votes></answer><answer id="A3115"><answer_text>Una funzione che prende come input l&#39;indirizzo del dato richiede meno memoria rispetto ad una a cui gli si passa il dato stesso e, soprattutto, consente di modificare il valore delle variabili che sono ad un livello di visibilità esterno alla funzione o al metodo. Inoltre, nel passaggio per indirizzo, in cui è necessario passare alla funzione un argomento di tipo puntatore, la variabile può restituire più di un valore. Questo approccio viene prediletto quando si devono passare strutture o array oppure quando si vuole modificare, dall&#39;interno di quella funzione, la variabile passata.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3072"><question_text>Cosa stamperà a video il seguente frammento di codice? Perchè?

void main()
{
  int *p, *q;
  int a[100];
  
  p = &#38;a[35];
  q = &#38;a[20];
  
  printf(&#34;%d \n&#34;,p-q);
  
  system(&#34;PAUSE&#34;);	
}
</question_text><answer id="A3086"><answer_text>Questo frammento di codice stamperà a video il numero &#34;15&#34;. Un array viene allocato in memoria su una serie di spazi adiacenti l&#39;uno all&#39;altro con indirizzo sequenziale. Se assegnamo a &#34;p&#34; l&#39;indirizzo del 35° elemento dell&#39;array e a &#34;q&#34; assegnamo l&#39;indirizzo del 20°, tramite la sottrazione &#34;p-q&#34; otterremo esattamente la distanza di posizione tra i due elementi dell&#39;array.</answer_text><num_votes>1</num_votes></answer><answer id="A3068"><answer_text>Questo frammento di codice stamperà a video &#34;15&#34;.
Questo perché alle due variabili puntatori p e q viene assegnato l&#39;indirizzo in memoria di due celle di un array, che distano tra 15 posizioni. Infatti, quando si dichiara la variabile &#34;a&#34;, che è un array di 100 interi, il programma alloca nello stack lo spazio necessario,cioè 100 celle consecutive ed omogenee di tipo &#34;int&#34;(4 byte ciascuna). Alle due variabili &#34;p&#34; e &#34;q&#34; vengono rispettivamente assegnate la posizione 36 e la posizione 21 dell&#39;array, che corrispondono a due posizioni nella memoria che distano tra loro 15 interi.</answer_text><num_votes>1</num_votes></answer><answer id="A2993"><answer_text>Verrà stampato il numero 15, perchè è il numero di puntatori di tipo int che ci sono tra a[35] e a[20].
Quindi 35-20 = 15. Se andassimo a stampare gli indirizzi di p e q vedremmo che ci sono 60 byte di
differenza. Dato che un puntatore a intero sono di 4 byte, abbiamo 60/4 = 15.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3075"><question_text>Spiegare la differenza tra ciclo &#34;while&#34;, &#34;do-while&#34; e &#34;for&#34;. In quali casi sono preferibili utilizzarli e perchè?</question_text><answer id="A3074"><answer_text>Tutti e tre i cicli vengono usati per la gestione delle iterazioni nel codice. Il ciclo while si rende necessario per ripetere blocchi di istruzioni finché una condizione da valutare è vera. Quando il numero di iterazioni è noto a priori è preferibile l&#39;uso del ciclo for, che permette in maniera più sintetica di racchiudere l&#39;assegnamento, l&#39;incremento dell&#39;indice e la condizione di valutazione. Il ciclo do-while ha invece il vantaggio di eseguire indipendentemente dalla condizione da valutare la serie di istruzione almeno una volta: risulta particolarmente utile per il controllo dell&#39;input.</answer_text><num_votes>1</num_votes></answer><answer id="A2971"><answer_text>Le differenze tra questi 3 costrutti non sono molte, dato che sono intercambiabili tra loro (fanno lo stesso lavoro). I cicli &#34;while&#34; e &#34;for&#34; sono praticamente identici, il &#34;for&#34; offre però una  scrittura più ordinata e di più facile lettura. 
Il ciclo &#34;do-while&#34; a differenza degli altri è preferito per gestire l&#39;input per il semplice fatto che le istruzioni contenute nel corpo del ciclo saranno sicuramente eseguite almeno una volta.</answer_text><num_votes>0</num_votes></answer><answer id="A3101"><answer_text>Il ciclo for è particolarmente utile quando il numero di iterazioni è noto a priori. Il ciclo while, invece, è utilizzato nel caso in cui il numero di iterazioni non è noto o se non si è sicuri che la condizione di ingresso al ciclo sia soddisfatta almeno una volta. Il do-while è analogo al while, ma si usa se si è sicuri che il ciclo venga eseguito almeno una volta.</answer_text><num_votes>0</num_votes></answer><answer id="A3089"><answer_text>Il ciclo while, verificata la condizione, esegue l&#39;istruzione fino a che la condizione è vera. Il ciclo do-while esegue l&#39;istruzione una volta senza verificare la condizione, poi si comporta esattamente come il ciclo while. Il ciclo for esegue l&#39;istruzione tante volte quante sono impostate nella condizione. Il ciclo do-while si utilizza nei casi in cui si richiede almeno un valore da tastiera, il ciclo for si utilizza quando si conosce a priori il numero di volte che sarà eseguita l&#39;istruzione. Il ciclo while si utilizza negli altri casi.  </answer_text><num_votes>2</num_votes></answer></question><question id="Q3071"><question_text>Spiegare la differenza tra puntatore e doppio puntatore e fare degli esempi pratici sul loro utilizzo e su operazioni che si possono applicare tra loro. </question_text><answer id="A3053"><answer_text>I puntatori sono fondamentalmente delle variabili l?unica differenza consiste nel fatto che essi non contengono una valore numerico ma un puntatore(ossia un indirizzo) alla locazione di memoria dove è memorizzato un certo valore,in altre parole un puntatore contiene l&#39;indirizzo di memoria di un&#39;altra variabile.Tale valore può essere intero,reale o carattere.Invece il doppio puntatore serve a puntare a un altro puntatore e quindi punta al suo indirizzo.
Un esempio di puntatore è int* x 
un esempio di doppio puntatore è int** x
il C consente di eseguire operazioni di somma e sottrazione</answer_text><num_votes>2</num_votes></answer><answer id="A3073"><answer_text>Non esistono differenza tra puntatori e doppi puntatori, ma in quanto un puntatore puù puntare a una qualsiasi variabile questa può essere un altro puntatore e quindi si crea il doppio puntatore.
I puntatori singoli vengono utilizzati per l&#39;assegnazione indiretta di valori ad una variabile e ciò un puntatore singolo è una variabile che contiene l&#39;indirizzo di una variabile semplice.
I doppi puntatori vengono utilizzati quando si usano funzioni contenenti delle stringhe in quanto permettono di richiamare le varie posizioni della stringa senza dover utilizzare le incrementazioni.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2996"><question_text>Se dichiaro una variabile intera int i=5; e una variabile puntatore int *pi; dove l&#39;indirizzo della variabile i vale 200030, cosa contiene pi dopo ciascuna delle seguenti istruzioni?

a) &#38;pi = ++(&#38;pi);
b) pi = &#38;(i+1);</question_text><answer id="A3042"><answer_text>Nel caso a) si dovrebbe incrementare di &#34;uno&#34; l&#39;indirizzo stesso della cella di memoria del  puntatore &#34;pi&#34;, sebbene sia improbabile e inutile la sua realizzazione.  
 
Invece nel caso b) al puntatore &#34;pi&#34; verrebbe assegnato il valore dell&#39;indirizzo di &#34;i&#34; incrementato sempre di uno, cioè 200034 dato che gli int occupano 4 bit ciascuno.
La struttura comunque andrebbe scritta  nel seguente modo: pi = &#38;i + 1; cioè senza
parentesi perchè altrimenti il puntatore cercherebbe l&#39;indirizzo di un dato chiamato (i+1).
   </answer_text><num_votes>0</num_votes></answer><answer id="A3026"><answer_text>Provando al compilatore entrambe le istruzioni, è possibile notare che:
a) in questo caso viene dato il seguente errore: &#34;lvalue required as increment operand&#34;. Questo significa che non è possibile incrementare l&#39;indirizzo di una variabile (in questo caso un puntatore ad un numero intero).
b)in questo secondo caso, vi è un altro tipo di errore : &#34;lvalue required as unary &#39;&#38;&#39; operand&#34;. Qui non ho la possibilità di assegnare il risultato di un operazione aritmetica ad un puntatore, poiché esso non è dotato di indirizzo, ma solamente di valore numerico. </answer_text><num_votes>3</num_votes></answer></question></lecture><lecture id="L29" title="Introduzione al C, Codifica Algoritmi in C" date="2013-10-04"><question id="Q2499"><question_text>per quanto riguardo l&#39;ordinamento degli array, quale è la differenza tra bubble sort e merge sort? Quale è la più efficiente?</question_text><answer id="A2406"><answer_text>Il bubble sort funziona in questo modo: ogni coppia di elementi adiacenti della lista viene comparata e se essi sono nell&#39;ordine sbagliato vengono invertiti. L&#39;algoritmo scorre poi tutta la lista finché non vengono più eseguiti scambi, situazione che indica che la lista è ordinata. Il merge sort funziona in questo modo: se la sequenza da ordinare ha lunghezza 0 o 1, è già ordinata. Altrimenti la sequenza viene divisa in due metà, ogni sottosequenza viene ordinata applicando l&#39;algoritmo e infine le due sottosequenze vengono fuse. Il bubble sort è più efficiente del merge sort. </answer_text><num_votes>1</num_votes></answer><answer id="A2529"><answer_text>L&#39;algoritmo bubble sort scambia di posizione gli elementi dell&#39;array adiacenti che non sono in ordine fino a quando non si trovano più elementi da ordinare. Nel merge sort invece l&#39;array (se contiene più di un elemento) viene suddiviso in due sub-array la cui lunghezza è metà di quello iniziale, questi vengono ordinati in modo ricorsivo (cioè semplificati di volta in volta) e successivamente si fondono (merge) in un unico array ordinato. Nel bubble sort l&#39;efficienza diminuisce all&#39;aumentare della quantità di dati da ordinare, al contrario il merge sort mantiene l&#39;efficienza costante.</answer_text><num_votes>3</num_votes></answer><answer id="A2362"><answer_text>Il bubble sort prevede il confronto di coppie di elementi adiacenti della lista, per cui se essi si trovano nell&#39;ordine sbagliato vengono invertiti. L&#39;algoritmo prosegue la fase di ordinamento fino a che tutti gli elementi sono stati esaminati.
Il merge sort lavora su due gruppi di elementi, ciascuno dei quali viene ordinato indipendentemente dall&#39;altro. Le due sottosequenze vengono poi combinate, individuando di volta in volta il minimo e ordinando la lista di conseguenza.
Il metodo più efficiente è il merge sort, in quanto rende necessario un minor numero di operazioni.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2474"><question_text>spiega la differenza tra usare:
while &#60;condizione&#62;
   &#60;istruzione&#62; 

e usare:
do 
&#60;istruzione&#62;
while &#60;condizione&#62;</question_text><answer id="A2380"><answer_text>Quando utilizzo il cilco while il compilatore può non eseguire mai le istruzioni contenute nel ciclo se la condizione non si verifica mai (è sempre falsa),
mentre quando utilizzo il ciclo do - while il compilatore esegue sempre, almeno una volta, le istruzioni contenute nel ciclo (finché la condizione diventa falsa).
Esempio:
Se la condizione è sempre falsa con il ciclo while le istruzioni non vengono mai eseguite, mentre con il ciclo do - while le istruzioni vengono eseguite una volta.</answer_text><num_votes>1</num_votes></answer><answer id="A2422"><answer_text>Il ciclo while prevede che prima si ponga la condizione(espressione booleana racchiusa fra parentesi tonde)e poi si specifichino le istruzioni fra parentesi graffe.Con questo ciclo fintantoche&#39;  la condizione e&#39; vera  viene eseguita l&#39;istruzione.Il costrutto  do-while invece fa seguire alla parola chiave do l&#39;istruzione tra parentesi graffe, il while e la condizione.Con questo costrutto l&#39;istruzione viene eseguita almeno una volta e ripetuta fino a quando la condizione diventa falsa.Entrambi i cicli portano allo stesso risultato ma il secondo permette una stesura piu&#39; ordinata del codice.</answer_text><num_votes>1</num_votes></answer><answer id="A2383"><answer_text>Nel primo caso viene immediatamente valutata la condizione, se questa è falsa 
le istruzioni contenute all&#39;interno del ciclo while non vengono eseguite.
Nel secondo caso le istruzioni vengono eseguite almeno una volta e poi 
viene valutata la condizione.
In entrambi i casi le istruzioni contenute all&#39;interno del ciclo vengono ripetute 
finchè la condizione rimane vera.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2429"><question_text>Gli operatori di assegnamento x++ e ++x svolgono la stessa funzione? Se assumo x=3, qual è la differenza tra la stampa &#34;printf(&#34;%d&#34;, x++)&#34; e la stampa &#34;printf(&#34;%d&#34;, ++x)&#34;?</question_text><answer id="A2387"><answer_text>La differenza tra i 2 operatori è che x++ prima valuta la variabile x e poi ne incrementa il valore, mentre l&#39;operatore ++x prima incrementa la variabile e poi la valuta. Nel nostro esempio con &#34;printf(&#34;%d&#34;, x++)&#34; verrà stampato il valore &#34;3&#34; e poi verrà incrementata la variabile mentre con &#34;printf(&#34;%d&#34;, ++x)&#34; verrà stampato il valore già incrementato &#34;4&#34;.</answer_text><num_votes>0</num_votes></answer><answer id="A2514"><answer_text>La differenza tra i due operatori di somma sta nel fatto che nello scrivere x++, il valore di x viene incrementato dopo l&#39;utilizzo della variabile x, mentre nella forma prefissa ++x, x viene incrementato e il valore di x viene denotato dopo l&#39;incremento. Nel primo modo di scrittura di printf, viene stampato il valore che assegno a x prima che x venga incrementato. Nel secondo caso ciò che viene stampato è il valore di x dopo che esso ha subito l&#39;incremento.</answer_text><num_votes>0</num_votes></answer><answer id="A2516"><answer_text>Si se sono scritte come istruzione cioe&#39; la riga deve terminare con il punto e virgola, perche&#39; entrambi incrementano x, altrimenti se fanno parte di un&#39;istruzione in ?x++? il valore di x prima dell&#39;incremento e in ?++x? il valore di x dopo l&#39;incremento.
Si c&#39;e&#39; differenza tra le due stampe: 
nell&#39;istruzione &#34;printf(&#34;%d&#34;, x++)&#34; il valore di x che viene stampato e&#39; ?3? perché x e&#39; prima dell&#39;incremento;
nell&#39;istruzione &#34;printf(&#34;%d&#34;, ++x)? il valore di x che viene stampato e&#39; ?4? perché x e&#39; dopo l&#39;incremento.</answer_text><num_votes>0</num_votes></answer><answer id="A2381"><answer_text>Gli operatori di incremento x++ e ++x,svolgono la stessa funzione,incrementano x di un&#39;unità.
Vi è una differenza tra le due scritture: x++ è definito post incremento, cioè, il compilatore esegue prima l&#39;istruzione dove è presente la variabile dopo di che la incrementa.
La scrittura ++x si definisce pre incremento, cioè, il compilatore prima incrementa la variabile e poi esegue l&#39;istruzione che la contiene.
Se assumo x=3,eseguo printf(&#34;%d&#34;,x++) visualizzo il valore 3(dopo quest&#39;istruzione x=4).
Quando eseguo printf(&#34;%d&#34;,++x) visualizzo il valore 4(variabile pre incrementata).</answer_text><num_votes>2</num_votes></answer></question><question id="Q2442"><question_text>Quali sono le operazioni applicabili a variabili di tipo puntatore?</question_text><answer id="A2413"><answer_text>Le operazioni applicabili sono:
-Assegnamento(tramite &#38;) per assegnare l&#39;indirizzo di una variabile.
 (Es:P=&#38;x, dove P è un puntatore di tipo intero).
-Dereferenziazione(tramite *).(Es:x=*P).
-Asegnamento del valore di un altro puntatore.(Es:P=Q)
-Confronto tra puntatori.(Es: P==Q)
-Operazioni aritmetiche(somma e sottrazione). (Es:P= a+1 è equivalente a P=a[1])</answer_text><num_votes>2</num_votes></answer><answer id="A2432"><answer_text>Impotrante operatore applicabile alle variabili di tipo punttore è *, necessario ad eseguire l&#39;operazione di dereferenziazione.
Fondamentale è anche &#38;, da applicarsi ad una variabile per prelevarne l&#39;indirizzo (magari per assegnarlo ad una variabile di tipo puntatore).
Si segnalano poi operatori:
++ -- ! size_of (altri operatori unari)
= += -= assegnamento, ovviamente necessario per moltissime operazioni
+,- molto utili nel correlare array e puntatori
==, !=, &#62;, &#60;, &#60;=, &#62;= di confronto
&#38;&#38; || logici Booleani
) [ ] . -&#62; Per la notazione suffissa
* / % Moltiplicativi
? : Condizionali</answer_text><num_votes>2</num_votes></answer><answer id="A2503"><answer_text>Le operazioni applicabili a i puntatori sono: la dereferenziazione cioè l&#39;assegnamento ad un puntatore del right-value di una variabile (esempio x=3, x=*p di conseguenza *p punta al valore 3); l&#39;assegnamento di un indirizzo, cioè ad un puntatore viene assegnato l&#39;indirizzo di una variabile cioè il left-value di essa (esempio p=&#38;x) quindi in p è salvato l&#39;indirizzo della cella di memoria occupata dalla variabile x; inoltre è possibile sommare o sottrarre quantità ad un puntatore il quale punterà all&#39;indirizzo di memoria successivo o precedente.  </answer_text><num_votes>0</num_votes></answer></question><question id="Q2436"><question_text>Qual e&#39; la differenza tra Compilazione ed Interpretazione di un programma? Quali sono i vantaggi e gli svantaggi? Infine, in quali casi e&#39; meglio adottare una soluzione rispetto all&#39;altra?</question_text><answer id="A2379"><answer_text>In un caso viene &#34;generato&#34; qualcosa che è &#34;direttamente&#34; usabile (eseguibile) dal processore; nel secondo caso c&#39;è di mezzo un altro programma (l&#39;interprete) che fa sì che il codice (tipicamente un testo... ma nel caso di una vm è un &#34;linguaggio macchina virtual&#34; che necessita comunque di un interprete) faccia effettivamente qualcosa.
</answer_text><num_votes>0</num_votes></answer><answer id="A2396"><answer_text>I linguaggi compilati vengono scritti in un editor che si occuperà di controllare la correttezza del codice per poi compilarlo, ogni istruzione viene trasformata nel corrispondente codice in linguaggio macchina che può essere eseguito dal processore.
I linguaggi interpretati vengono elaborati al volo e vengono eseguite le istruzioni così come descritte nel codice sorgente senza che vi sia un controllo degli errori. Il vantaggio dei linguaggi interpretati e la loro elevata portabilità e immediatezza, mentre la compilazione richiede un minore lavoro al processore e svolge il contro degli errori</answer_text><num_votes>2</num_votes></answer></question><question id="Q2439"><question_text>Che differenze ci sono tra un ciclo for e un ciclo while?</question_text><answer id="A2488"><answer_text>Un ciclo for e un ciclo while sono equivalenti e infatti un ciclo for può essere riscritto usando un ciclo while e viceversa.Sono però diversi strutturalmente.Infatti un ciclo for ha una struttura del tipo for(inizializzazione; condizione; incremento) {
  &#60;istruzione&#62;; }
mentre un ciclo while ha una struttura del tipo while( condizione ) {
  istruzione; }
</answer_text><num_votes>0</num_votes></answer><answer id="A2391"><answer_text>Nel ciclo for l&#39;inizializzazione di una variabile contatore, il test sulla condizione di ingresso nel ciclo e l&#39;incremento della variabile contatore vengono effettuate all&#39;inizio: for(inizializzazione;condizione;incremento){istruzioni}.
Nel ciclo while solo la condizione viene posta all&#39;inizio(while(condizione){istruzioni}), mentre la variabile da utilizzare come contatore deve essere scritta all&#39;interno del ciclo e anche l&#39;incremento della variabile stessa. Di solito il ciclo for viene utilizzato quando il numero delle ripetizioni è noto, mentre il ciclo while quando non lo si conosce.</answer_text><num_votes>1</num_votes></answer><answer id="A2408"><answer_text>A livello sintattico sono equivalenti. Ogni for può essere tradotto in while ed essi sono equivalenti a livello di linguaggio macchina.
Tuttavia il while è solitamente preferito quando la condizione da testare è una condizione logica non direttamente legata al numero di iterazioni da eseguire; viceversa il for è solitamente utilizzato quando si vuole iterare per un numero preciso di volte.
Questa, però, è solo una questione di comodità e non un obbligo.
Esempio di traduzione for -&#62; while
for(inizializzazione; test; step) {...} =
inizializzazione
while(test) { 
...
step
}</answer_text><num_votes>1</num_votes></answer></question><question id="Q2435"><question_text>Quali sono le cinque principali istruzioni nel linguaggio C? Elencale e descrivile brevemente.</question_text><answer id="A2364"><answer_text>Le principali istruzioni del C sono: istruzione di assegnamento che viene utilizzata per assegnare a una variabile il valore di un&#39;espressione; istruzioni di ingresso e uscita che consentono di leggere o scrivere il valore di una variabile dallo Standard Input o sullo Standard Output; istruzioni composte quali l&#39;istruzione condizionale che consente di eseguire due diverse sequenze di istruzioni sulla base del valore di verità di una condizione e l&#39;istruzione iterativa che permette la ripetizione dell&#39;esecuzione di una sequenza di istruzioni ogni volta che una certa condizione è verificata.</answer_text><num_votes>1</num_votes></answer><answer id="A2505"><answer_text>Istruzioni:
 - assegnamento, con cui si attribuisce ad una variabile un valore dello stesso tipo;
 - lettura, con cui si può ricevere un valore dallo standard input ed eventualmente assegnarlo ad una variabile;
 - scrittura, con cui si può stampare dei valori sullo standard output;
 - condizionale, che permette di eseguire diverse istruzioni a seconda del valore di una variabile o di un&#39;espressione (se vera si eseguono certe istruzioni, altre se falsa);
 - iterativa, che permette di ripetere più volte una serie di istruzioni.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2459"><question_text>che cosa vuol dire la scritta : &#34;#include &#60;stdio.h&#62;&#34;</question_text><answer id="A2450"><answer_text>&#34;stdio.h&#34;, che significa &#34;standard input-output header&#34;, è l&#39;header file della libreria standard del C che contiene definizioni di macro, costanti e dichiarazioni di funzioni e tipi usati per le varie operazioni di input/output. </answer_text><num_votes>0</num_votes></answer><answer id="A2478"><answer_text>Significa che si possono utilizzare all&#39;interno del programma le funzioni dichiarate nella libreria standard del C stdio.h, che sta per &#34;standard input-output header&#34;,che contiene definizioni di macro (insieme di comandi), costanti e dichiarazioni di funzioni e tipi usati per le varie operazioni di input/output.</answer_text><num_votes>2</num_votes></answer><answer id="A2377"><answer_text>Posta  prima della funzione &#34;main&#34;, impone al programma di usare delle librerie standard 
proprie del C, per l&#39;input e l&#39;output.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2448"><question_text>In che cosa consiste la procedura di programmazione top-down? Quali vantaggi porta e in che casi viene utilizzata?</question_text><answer id="A2366"><answer_text>E&#39; la tecnica che consiste nel definire la strategia di risoluzione di un problema generale attraverso livelli di dettaglio sempre più precisi, scomponendo il problema in sottoproblemi particolari. La procedura di programmazione top-down gode dei seguenti vantaggi: 1. Netta semplificazione del problema e del codice grazie alla possibilità di suddividere il lavoro tra più persone (ognuno ha il proprio task); 2. Facile manutenzione del codice; 3. Il problema è chiaro a tutti quando parte la programmazione. Viene usata quando si risolvono problemi sempre più complessi. </answer_text><num_votes>0</num_votes></answer><answer id="A2494"><answer_text>La programmazione top-down è uno stile di programmazione in cui un problema complesso, di un algoritmo o di un procedimento viene suddiviso in sottoproblemi più piccoli e più semplici da implementare nel linguaggio desiderato. I vantaggi della programmazione top-down sono:
-permette di concentrarsi sugli aspetti più significativi;
-rendere l&#39;algoritmo semplice e più leggibile;
-la risoluzione può essere modificata senza che si modifichi la struttura generale dell&#39;algoritmo   risolutivo;
-la risoluzione di sottoproblemi può essere riutilizzata in altri problemi.
</answer_text><num_votes>3</num_votes></answer><answer id="A2374"><answer_text>Top-down significa letteralmente &#34;dall&#39;alto verso il basso&#34; e rappresenta il modo di scrivere un programma. E&#39; utile per scomporre un grande &#34;problema&#34; in tanti problemini minori trattandoli uno alla volta. Scorrendo verso il basso, un compilatore leggerà il codice e darà come soluzione la somma di tutti i problemini scomposti secondo l&#39;abilità del programmatore.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2554"><question_text>Che cos&#39;è un &#34;tipo&#34; di dato?</question_text><answer id="A2461"><answer_text>Un tipo di dato è il formato che quel dato può assumere. In altre parole indica l&#39;insieme dei valori che una variabile o il risultato di un espressione possono assumere e le operazioni effettuabili su tali valori. Se, ad esempio, dichiariamo una variabile di tipo intero (int), i valori che questa variabile può assumere sono solamente i numeri interi. In altre parole se assegniamo a questa variabile un espressione il cui risultato da un numero con la virgola, il compilatore darà un messaggio di errore in quanto il tipo di dato della variabile è un intero. </answer_text><num_votes>3</num_votes></answer><answer id="A2370"><answer_text>In C un tipo di dato e&#39; un nome che caratterizza i valori che puo&#39; assumere una varianile. </answer_text><num_votes>0</num_votes></answer></question><question id="Q2573"><question_text>Ci sono differenze per cui sia meglio usare l&#39;istruzione switch piuttosto che una serie di if else nidificati?</question_text><answer id="A2447"><answer_text>In linea generale le due istruzioni hanno prestazioni simili. Tuttavia se le condizioni di una casistica hanno tutte la forma &#34;x==k&#34; l&#39;istruzione switch risulta più leggibile ed immediata. Un altro caso in cui è consigliato usare lo switch è quando la variabile di controllo fa parte di una funzione, in quando questa verrebbe richiamata soltanto una volta, mentre con l&#39;istruzione if-else verrebbe richiamata per ogni &#34;if/else-if/else&#34;. Infine mentre l&#39;istruzione switch esce(&#34;break&#34;) dal ciclo una volta eseguito un &#34;case&#34;, l&#39;if-else confronta e esegue tutte le condizioni.</answer_text><num_votes>0</num_votes></answer><answer id="A2392"><answer_text>A livello di risultato finale no, ma a livello di ottimizzazione del programma e pulizia del codice e&#39; preferibile utilizzare il costrutto switch, anche perche&#39; evita al compilatore di imbattersi in casistiche nelle quali si sarebbe trovato leggendo tutti gli if-else andando invece a leggere solo la casistica interessata.</answer_text><num_votes>1</num_votes></answer><answer id="A3438"><answer_text>Una serie di if-else nei quali vogliamo confrontare un singolo valore intero rispetto a diversi valori costanti alternativi può essere realizzata mediante il comando condizionale &#34;a più vie&#34; switch. L&#39;enunciato switch si può usare solo in circostanze limitate. I valori con i quali si può confrontare il selettore devono essere costanti di tipo intero, char o enumerativo: non si può usare lo switch ad esempio con un selettore di tipo double o String. Anche quando è lecito, non sono molti i casi in cui è opportuno che l&#39;istruzione switch sostituisca l&#39;istruzione if-else (esempio range valori int)</answer_text><num_votes>0</num_votes></answer><answer id="A2375"><answer_text>La differenza è solo stilistica: è più leggibile uno switch rispetto a molti if nidificati.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2509"><question_text>Cosa si intende, nel linguaggio di programmazione in c, per tipi fondamentali e tipi derivati?</question_text><answer id="A2436"><answer_text>Nel classificare i tipi di dato si distingue tra tipi fondamentali (o semplici) e tipi derivati (o strutturati). I tipi fondamentali servono per rappresentare informazioni semplici come i numeri interi, i caratteri; rientrano in questa categoria i tipi: char, int, float, double e questi stessi con l&#39;aggiunta di &#34;qualificatori di tipo&#34; come signed o unsigned, short o long. I tipi derivati servono invece a rappresentare informazioni complesse tramite la costruzione di strutture dati complesse a partire dai tipi semplici; rientrano in questa categoria: array, strutture e puntatori.</answer_text><num_votes>2</num_votes></answer><answer id="A2411"><answer_text>I tipi di dato sono le tipologie di variabili utilizzate in un programma.In C con &#39;tipi fondamentali&#39; (int, char, float..)si intendono quelle variabili che rappresentano informazioni semplici,mentre con &#39;tipi derivati&#39; (array,  struct, puntatori.. ) le variabili che rappresentano informazioni costituite dall&#39;aggregazione di diversi componenti.Infatti la differenza fondamentale tra questi due tipi di dati sta nel fatto che l&#39;informazione contenuta in una variabile semplice è logicamente indivisibile, mentre quella contenuta in una variabile strutturata può essere scomposta nelle sue componenti.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2478"><question_text>Che cosa si intende per &#34;macchina astratta C&#34;?</question_text><answer id="A2376"><answer_text>In informatica il termine macchina astratta indica un modello teorico di hardware o software, in grado di eseguire operazioni, memorizzarne il risultato e seguire il flusso dell&#39;algoritmo.
Attraverso l&#39;uso di macchine astratte è possibile calcolare la quantità di risorse necessari per eseguire una determinata operazione, senza dover costruire un sistema reale.
Il più famoso esempio di macchina astratta è la macchina di Turing. </answer_text><num_votes>3</num_votes></answer><answer id="A2404"><answer_text>E&#39; un insieme di strutture dati e algoritmi che permettono di eseguire programmi in c, e permettono di trasformare un input in un output</answer_text><num_votes>1</num_votes></answer></question><question id="Q2432"><question_text>Che cos&#39;è il linguaggio assembler e che funzione ha ? </question_text><answer id="A2469"><answer_text>Il linguaggio assembler e&#39; quello piu&#39; vicino al linguaggio macchina e ha lo scopo generale di consentire al programmatore di ignorare il formato binario del linguaggio macchina. Ogni codice operativo del linguaggio macchina viene sostituito, nel linguaggio assembler, da una sequenza di caratteri che lo rappresenta in forma mnemonica(simbolica).</answer_text><num_votes>1</num_votes></answer><answer id="A2515"><answer_text>Il linguaggio assembler è la rappresentazione simbolica (mnemonica) della codifica binaria usata dal calcolatore (linguaggio macchina, binario). Questo tipo di linguaggio utilizza simboli, registri, etichette e utilizza una codifica binaria (la quale è salvata in memoria) per inviare richieste alla CPU. 
L&#39;assembler è un programma che traduce il codice da linguaggio assembler a linguaggio
 macchina e la sua funzione è proprio quella di far comunicare linguaggi ad alto livello con la CPU.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2561"><question_text>Come posso definire una struttura all&#39;interno dell&#39;ambiente di programmazione C, che vantaggi comporta?</question_text><answer id="A2441"><answer_text>Il più semplice dato struttura è l&#39;arrey. Esso è un raccoglitore di tante variabili che si distinguono per il loro indice indicato tra parentesi. Una volta dichiarato il compilatore riserverà in memoria uno spazio sufficiente a memorizzare le variabili</answer_text><num_votes>0</num_votes></answer><answer id="A2372"><answer_text>Il costruttore di tipi struct in C permette di definire strutture aggregando elementi di tipi diversi; tali elementi si chiamano campi della struttura. Infatti, in questo caso, risulterebbe del tutto impossibile strutturare l&#39;informazione mediante il meccanismo dell&#39;array, poiché esso richiede che tutti i suoi elementi siano omogenei. I valori dei tipi costruiti mediante struct sono costituiti da una sequenza di altri valori, i valori dei campi, appartenenti ad altri tipi qualsiasi. Il fatto che struct sia un costruttore di tipi implica che esso può essere impiegato esattamente come un array. </answer_text><num_votes>3</num_votes></answer><answer id="A2423"><answer_text>Si può definire una struttura attraverso il tipo struct. In questo modo è possibile incapsulare gruppi di variabili correlate, raggruppando quelle che appartengono logicamente allo stesso oggetto. Il programma guadagna leggibilità, sfruttando una rappresentazione gerarchica dei dati. E&#39; utile quando si gestiscono informazioni (anche eterogenee) che caratterizzano però uno stesso dato. Così è anche possibile assegnare (o passare a/da una funzione) tutte le parti di un aggregato in un unico dato.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2445"><question_text>Cosa si intende per strong typing e loose typing nei linguaggi di programmazione?</question_text><answer id="A2489"><answer_text>In C per loose typing si intende che i tipi di dato delle variabili non devono necessariamente essere dichiarati. Invece per strong typing si intende che i tipi devono essere dichiarati(C++); la differenza risiede nelle scelte decisionali del progettista del linguaggio, che può volere più o meno flessibilità all&#39; interno di esso. Con il metodo loose typing il programmatore può commettere errori di tipo che potrebbero compromettere l&#39; esecuzione del programma, ma con lo strong typing siamo costretti a seguire delle regole rigide che, a volte, non permettono di risolvere velocemente un problema.</answer_text><num_votes>1</num_votes></answer><answer id="A2481"><answer_text>Per &#34;strong typing&#34; si intende un linguaggio di programmazione in cui i tipi delle variabili devono essere dichiarati e non possono cambiare, al contrario un linguaggio di programmazione &#34;loose typing&#34; permette di cambiare il tipo delle variabili. Per esempio in un linguaggio loose typing è possibile cambiare il tipo del risultato di una divisione tra integer, il quale sarebbe anch&#39;esso integer, in una variabile di tipo float semplicemente attraverso l&#39;operazione di &#34;cast a float&#34;. Questa operazione di &#34;casting&#34; non sarebbe invece possibile con un linguaggio strongly typed.</answer_text><num_votes>1</num_votes></answer><answer id="A2398"><answer_text>Strong typing vine utilizzato per C++ e in Java e significa che le variabili devono essere dichiarate e non possono cambiare.
Loose typing viene invece utilizzato per il linguaggio Javascript.
Questi termini vengono utilizzati per  criticare o esaltare un linguaggio rispetto ad altri, ma anche per classificarlo in base ala sicurezza.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2473"><question_text>Perché quando si usa la funzione scanf con le stringhe non serve mettere la &#38; per indicare l&#39;indirizzo della variabile in cui il risultato inserito da tastiera deve essere memorizzato?</question_text><answer id="A2462"><answer_text>Per le stringhe non è necessaria la &#38; perché esse funzionano già da puntatori e quindi non c&#39;è bisogno che si indichi quale deve essere l&#39;indirizzo di riferimento della variabile. Anzi mettendo il nome di questa si indica l&#39;indirizzo della prima cella e il compilatore sa già quali sono le celle che contengono gli elementi successivi dell&#39;array.</answer_text><num_votes>1</num_votes></answer><answer id="A2361"><answer_text>La stringa è un&#39;array di char.
Come noto un&#39;array è identificato con l&#39;indirizzo della cella di memoria del primo elemento dell&#39;array. Quindi la variabile s inizializzata array di char funziona alla stregua di un puntatore che punta una cella di memoria.
Si può avere conferma di questo andando a far inizializzare al compilatore un array char (ex char s[]=&#34;prova&#34; e poi facendo un print &#34;printf(&#34;%d&#34;,s)&#34; si può notare come il numero che il programma ci restituisce non sono i valori salvati nella stringa bensì l&#39;indirizzo della prima cella dell&#39;array (&#38;s[0]). </answer_text><num_votes>2</num_votes></answer><answer id="A2476"><answer_text>Quando si usa la funzione scanf, la variabile stringa deve essere indicata senza l?operatore indirizzo &#38;, in quanto, il nome di una stringa (ed in generale di un array) denota già un indirizzo (l?indirizzo del primo elemento). 
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2434"><question_text>Che cos&#39;è un tipo strutturato, a cosa serve e come viene dichiarato in C?</question_text><answer id="A2500"><answer_text>In C il programmatore ha la possibilita&#39; di usare il costrutto struct per definire una struttura di dati di diverso tipo. Il comando struct va inserito nella parte dichiarativa, cioe&#39; nella parte prima del main.
Inoltre data una variabile di tipo struct, l&#39;accesso ai campi, avviene mediante la &#34;dot notation&#34;, una &#34;chiave&#34; per accedere alle informazioni specifiche ed eterogenee di cui e&#39; composto.</answer_text><num_votes>1</num_votes></answer><answer id="A2531"><answer_text>Un tipo strutturato è un tipo che viene espressamente dichiarato da un programmatore, che può plasmarlo in base alle sue esigenze.
In C viene dichiarato in questo modo:

struct nome_struttura{
tipo1 nomecampo1;
tipo2 nomecampo2;
....
}nome_variabile;</answer_text><num_votes>1</num_votes></answer><answer id="A2382"><answer_text>Un tipo strutturato è un tipo di dato che contiene altri tipi di dato.
Serve per creare variabili che contengono vari campi legati a quella variabile, per esempio per memorizzare vari parametri di un oggetto.
Viene dichiarato tramite il comando 
TYPEDEF STRUCT {Campi} Nome;</answer_text><num_votes>1</num_votes></answer></question><question id="Q2521"><question_text>Quando è consigliabile utilizzare il ciclo while, e  quando il ciclo for?</question_text><answer id="A2427"><answer_text>Quando il numero di volte che il ciclo deve essere ripetuto è noto il ciclo for è più facile da scrivere, da modificare, da controllare. Quando invece il ciclo va ripetuto finché vale una certa condizione e ciò dipende da qualcosa di non prevedibile, quindi non si sa quante volte il ciclo sara eseguito, si usa comunemente il ciclo while.</answer_text><num_votes>2</num_votes></answer><answer id="A2454"><answer_text>Il ciclo for è indicato per le operazioni  di cui si conosce il numero di ripetizioni da eseguire. Il ciclo while è particolarmente utile quando si deve ripetere un&#39;operazione molteplici volte, ma non si conosce quante; inoltre è consigliato quando si deve modificare in esecuzione il numero di cicli da eseguire. Infine con un ciclo while è possibile creare un ciclo for, mentre l&#39;inverso non è possibile. </answer_text><num_votes>0</num_votes></answer><answer id="A2425"><answer_text>Il ciclo while viene utilizzato per ripetere l&#39;esecuzione di blocco di istruzioni ogni qual volta che la condizione risulta essere vera. Il ciclo for prevede l&#39;inizializzazione della variabile da cui dipenderà tutto il ciclo seguita dalla condizione e dall&#39;incremento (sempre della variabile).Vi è poi il blocco di istruzioni che devono essere eseguite tutte le volte che la condizione risulta essere vera. Il ciclo for è consigliato quando è già noto il numero di ripetizioni necessarie per il ciclo, mentre il while si usa quando le ripetizioni dipendono da un valore non noto.</answer_text><num_votes>0</num_votes></answer><answer id="A2499"><answer_text>Il ciclo while ripete una serie di comandi finchè una condizione iniziale risulta vera.
Utilizzando questo ciclo il programmatore non deve conoscere il numero di iterazioni totali,
nè tanto meno sapere se tale ciclo sarà eseguito anche solo una volta.

Il ciclo for invece ripete una serie di comandi per un numero precisato di volte e bisogna quindi già conoscere tutti questi dati.

Useremo il while per prevedere infiniti errori da parte di un utente 
che deve inserire valori rispettando determinate condizioni, 
mentre useremo il for per programmare qualcosa di preciso come un array.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2455"><question_text>E&#39; possibile implementare dei pezzi di codice in assembler in un sorgente scritto in C o C++?</question_text><answer id="A2467"><answer_text>Il linguaggio C è di medio livello e di astrazione superiore al linguaggio assembler.
Per questo motivo il codice C per essere compreso ed eseguito da un calcolatore ha bisogno di essere &#34;tradotto&#34; in un linguaggio di bassissimo livello (questo è il compito del compilatore).
Se implementassimo il codice C con del codice di astrazione inferiore (sintatticamente e semanticamente differente) questo non sarebbe decifrabile dal compilatore, che non riuscirebbe a renderlo eseguibile. 
Di conseguenza il codice &#34;misto&#34; che abbiamo scritto resterebbe inutilizzabile.</answer_text><num_votes>0</num_votes></answer><answer id="A2388"><answer_text>Si, è possibile implementare dei comandi in assembler all&#39;interno di un programma in C/C++.
Ciò può essere fatto utilizzando la funzione asm() (esempio: asm(&#34;codice assembler&#34;);).</answer_text><num_votes>3</num_votes></answer><answer id="A2369"><answer_text>Si, ed è possibile grazie all&#39;assembler inline che permette di compilare correttamente un codice assembly inserito in un sorgente scritto in C o C++.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2451"><question_text>in costrutto di if-else annidati del tipo:
if(c1)
    if(c2)
    else
il ramo di else a quale if deve essere attribuito?</question_text><answer id="A2353"><answer_text>In questo caso il costrutto else si riferisce a if(c2) poiché il compilatore lo attribuisce al if più vicino.</answer_text><num_votes>0</num_votes></answer><answer id="A2371"><answer_text>La parte else è annidato nella struttura if(c1), quindi si riferisce alla struttura if(c2).
Se la condizione di if(c2) non è verificata e nemmeno quella di else, per esclusione si verificherà la condizione di if(c1)</answer_text><num_votes>0</num_votes></answer><answer id="A2437"><answer_text>In un costrutto di if-else annidati, come nell&#39;esempio, l&#39;else si riferisce all&#39;if più vicino (in questo caso if(c2)), dal momento che non ci sono delle parentesi graffe che modificano l&#39;appartenenza dell&#39;else ad un altro if (per esempio if(c1)).</answer_text><num_votes>2</num_votes></answer><answer id="A2354"><answer_text>In questo caso il costrutto else si riferisce a if(c2) poiché il compilatore lo.attribuisce al if più vicino.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2427"><question_text>Per quale motivo l&#39;identificatore predefinito &#34;main&#34; viene dichiarato come numero intero &#34;int&#34;? A cosa serve la struttura (int argc, char *argv[]) che lo segue?</question_text><answer id="A2456"><answer_text>l&#39;indicatore predefinito &#34;main&#34; viene dichiarato come numero intero in quanto deve obbligatoriamente restituire un intero per segnalare le condizioni di errore.
nella struttura (int argc, char *argv[]), &#34;argc&#34; è il numero dei parametri del programma, mentre &#34;argv&#34; è l&#39;array che contiene questi programmi. </answer_text><num_votes>0</num_votes></answer><answer id="A2389"><answer_text>L&#39;identificatore main viene definito &#34;int&#34; poiche&#39; puo&#39; restituire un codice numerico di errore al sistema operativo.
argc e arggv sono gli argomenti della linea di comando.
int argc contiene il numero di stringhe inserite dall?utente a linea di comando e char *argv[] e&#39; l?array che contiene le stringhe inserite dall?utente a linea di comando (ogni elemento dell?array è un puntatore a carattere).</answer_text><num_votes>0</num_votes></answer><answer id="A2355"><answer_text>L&#39;identificatore main viene definito &#34;int&#34; poiche&#39; puo&#39; restituire un codice numerico di errore al sistema operativo.
argc e arggv sono gli argomenti della linea di comando.
int argc contiene il numero di stringhe inserite dall?utente a linea di comando e char *argv[] e&#39; l?array che contiene le stringhe inserite dall?utente a linea di comando (ogni elemento dell?array è un puntatore a carattere).</answer_text><num_votes>1</num_votes></answer><answer id="A2410"><answer_text>L&#39;identificatore main è di tipo int in quanto è una funzione che ritorna un valore intero,0 di default,il quale chiude l&#39;esecuzione del programma tramite il controllo da parte del  compilatore(se è 0 chiude il programma).
La struttura (int argc, char *argv[]) passa al programma i parametri inseriti in linea di comando al momento della richiesta di esecuzione al Sistema Operativo.
argc contiene il numero dei parametri sulla riga di comando,incluso il nome del programma.
argv e&#39; un array di puntatori a char. Ogni puntatore referenzia un parametro in forma di stringa.</answer_text><num_votes>0</num_votes></answer><answer id="A2367"><answer_text>La parola chiave iniziale int rappresenta il tipo del valore restituito dalla funzione. Nel caso speciale del main, esso viene interpretato come valore restituito dall&#39;intero programma al sistema operativo. Coerentemente con una convenzione universale circa i valori restituiti dai programmi al sistema, il main restituisce sempre un numero intero.
argc contiene il numero dei paramentri sulla riga di comando, incluso il nome del programma. Pertanto argc e&#39; sempre &#62;= 1.
argv e&#39; un array di puntatori a char. Ogni puntatore referenzia un singolo parametro della linea di comando sottoforma sempre.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2475"><question_text>Cos&#39;è un programma?</question_text><answer id="A2474"><answer_text>Un programma è una sequenza finita di istruzioni che risolvono un problema e operano su strutture dati di alto livello, al di sopra della memoria fisica. I programmi, inoltre, ricevono valori in ingresso, producono valori in uscita, sono chiari, non ambigui ed eseguibili e terminano in un numero finito di passi. Sono scritti con Linguaggi di Programmazione comprensibili a un calcolatore</answer_text><num_votes>1</num_votes></answer><answer id="A2435"><answer_text>Un programma informatico può essere definito come un algoritmo complesso posto in forma comprensibile al computer (scritto tramite un linguaggio di programmazione). &#34;Programma&#34; è quindi un insieme ordinato di istruzioni che sono espresse secondo specifiche regole note a priori e che tramite un esecutore(computer) elabora soluzioni per i problemi posti. In altri termini collabora con l&#39;hardware della macchina per poter restituire dei risultati partendo da dati in ingresso.</answer_text><num_votes>3</num_votes></answer><answer id="A2458"><answer_text>Un programma è formato da una serie di algoritmi che vengono elaborati dal calcolatore per svolgere determinate azioni richieste dall&#39;utente.
Per fare ciò bisogna riuscire a &#34;tradurre&#34; gli algoritmi in un linguaggio comprensibile al calcolatore e questa serie di comandi è il vero e proprio programma che invierà i vari dati da calcolare alla cpu.</answer_text><num_votes>0</num_votes></answer><answer id="A2424"><answer_text>Un programma è una sequenza finita di istruzioni che risolvono un problema, soddisfano certi criteri(come ricezione valori in ingresso e produzione valori in uscita;terminano dopo un certo numero di passi) e operano su strutture dati.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2546"><question_text>Che differenza c&#39;è tra il ciclo &#34;while&#34; e il ciclo &#34;do while&#34;?</question_text><answer id="A2495"><answer_text>I due cicli sono molto simili con la differenza che il ciclo &#34;do-while&#34; esegue sempre almeno una volta il corpo del ciclo(le istruzioni). Infatti, se una condizione è falsa, il ciclo &#34;while&#34; non eseguirà mai le istruzioni, il ciclo &#34;do-while&#34; invece le eseguirà una volta. 
Inoltre il ciclo &#34;do-while&#34; è più utile quando il numero di iterazioni è noto.

Ciclo while: 
contatore = valore_iniziale;
while (contatore &#60;= valore_finale) {
istruzioni
contatore++;
}

Ciclo do-while:
contatore = valore_iniziale;
do {
istruzioni
contatore++;
} while (contatore &#60;= valore_finale);</answer_text><num_votes>0</num_votes></answer><answer id="A2439"><answer_text>Il ciclo while esegue una serie di istruzioni finché la condizione da valutare è vera. In questo tipo di ciclo la condizione è valutata prima di eseguire la sequenza di istruzioni. 
Quando il numero di iterazioni è noto a priori è utile usare il ciclo do while. Il ciclo do while, che può essere utilizzato al posto del ciclo while, esegue anch&#39;esso una serie di istruzioni che si ripetono ad ogni iterazione. Contrariante al ciclo while, in questo ciclo la condizione è valutata alla fine di ogni iterazione. 
</answer_text><num_votes>2</num_votes></answer><answer id="A2517"><answer_text>Quando uso DOWHILE so che il blocco di istruzioni sarà eseguito almeno una volta, mentre utilizzando WHILE c&#39;è la possibilità di non dover eseguire mai il codice in blocco.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2447"><question_text>Quali differenze ci sono tra un Array, un Vettore e una Stringa nel linguaggio di programmazione C?</question_text><answer id="A2472"><answer_text>Un array è una struttura di dati omogenea di elementi dello stesso tipo.
Un vettore è un array monodimensionale (es. int vettore[10]). Esistono anche array multidimensionali come matrici (es. m[10][10]) e array tridimensionali (es. t[10][10][10]).
Stringa, invece, è un tipo di dato &#34;user define&#34; definito per memorizzare stringhe (sequenze di carratteri). In realtà Stinga è un array di char ed è definito così:
typedef char Stringa[20];</answer_text><num_votes>1</num_votes></answer><answer id="A2455"><answer_text>Un array è una sequenza di celle di memoria consecutive e omogenee di qualsiasi tipo, per esempio:
tipo nome[N];
In cui il tipo può essere char, int, float ecc...
Nome è il nome con cui indichiamo l&#39;array e N il numero di elementi nell&#39;array, ma dato che si considera anche lo 0-esimo il numero di elementi sarà: N+1.
Una stringa è una sequenza di caratteri immagazzinata in celle consecutive, per esempio:
printf(&#34;Ciao&#34;);
Ciao è una stringa di caratteri. Gli array di tipo char sono spesso denominati come stringhe.
Un vettore è un array di numeri (interi e float) e ha carattere geometrico.</answer_text><num_votes>0</num_votes></answer><answer id="A2468"><answer_text>Un vettore e array in C sono usati come termini interscambiabili; vettore è più tendente ad una &#34;interpretazione geometrica&#34; (dalla nozione di vettore n-dimensionale), ma in sostanza è sempre un array. Invece vettore e array in C sono usati come termini interscambiabili; vettore è più tendente ad una &#34;interpretazione geometrica&#34; (dalla nozione di vettore n-dimensionale), ma in sostanza è sempre un array. </answer_text><num_votes>0</num_votes></answer><answer id="A2533"><answer_text>Un array, o matrice, in C è una serie di elementi dello stesso tipo ed è collocato in locazioni di memoria contigui facilmente accessibili tramite un indice. Il vettore è sinonimo di array; talvolta viene differenziato concettualmente in C e sostanzialmente in altri linguaggi per alcune caratteristiche che gli array semplici non hanno, quale ad esempio la capacità di essere ampliato o contratto in base alle esigenze. Una stringa è a tutti gli effetti un array di caratteri e assumono nomi distinti per comodità.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2555"><question_text>A cosa servono i puntatori,in quali casi vengono usati?</question_text><answer id="A2451"><answer_text>Un puntatore è una variabile che contiene l&#39;indirizzo di memoria di un&#39;altra variabile. Nella programmazione in C essi sono l&#39;unico modo per eseguire alcune operazioni, inoltre, producono codici sorgente compatti ed efficaci. Vengono molto usati nel momento in cui ci sia richiesto di compilare dei vettori, delle strutture e delle funzioni.</answer_text><num_votes>1</num_votes></answer><answer id="A2428"><answer_text>Un puntatore è una variabile che memorizza un indirizzo di memoria, posso accedervi tramite l&#39;operatore di de-referenziazione (*).
I puntatori sono usati per :
1. La gestione di strutture dinamiche.
2.Passare le variabili ad una funzione per indirizzo permettendo di cambiare il valore della variabile contrariamente a quando si effettua un passaggio per valore
3.Possibilità di riservare nuova memoria durante l&#39;esecuzione di un programma
4.Facilitare la condivisione di dati tra differenti parti del programma
5.Fare riferimento ad una grande struttura dati in modo compatto.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2441"><question_text>Che cosa è un array? In quali casi risulta utile in suo impiego?</question_text><answer id="A2453"><answer_text>Un array è un tipo di dato strutturato, una sorta di raccoglitore in cui il programmatore include un insieme di variabili di  tipo comune.
Ogni variabile si distingue da un indice tramite il quale è possibile l&#39;accesso ad ogni elemento. La dichiarazione di tale struttura avviene mediante la specificazione
del tipo dei dati da includere, il nome dell&#39;array e il numero degli elementi, che corrisponderà al numero di celle nella memoria che il compilatore
riserverà. Da ricordare che se viene definito un array di n elementi,l&#39;indice di questi andranno da 0 a n-1.</answer_text><num_votes>0</num_votes></answer><answer id="A2530"><answer_text>Un array è un raccoglitore di variabili omogenee, memorizzate in celle di memoria consecutive. Dato quindi che ogni variabile occupa un posto diverso in memoria, viene applicato un indice ad ognuna, il quale indica la sua posizione (della variabile) all&#39;interno dell&#39;array.
Per accedere alla variabile desiderata --&#62; NomeArray[indice].
Un array è utile quando si vuole operare su più variabili dello stesso tipo, evitando di dichiarare volta per volta le variabili che ti servono.</answer_text><num_votes>2</num_votes></answer><answer id="A2496"><answer_text>Un array è il più semplice tipo di dato strutturato, consiste in una serie continua di celle consecutive ed omogenee. Quando si dichara, ad esempio, un array a[10], il compilatore identifica uno spazio di 10 celle (dalla posizione 0 alla 9) utilizzabili dal&#39;utente, mentre la numero 10 è riservata al sistema che vi inserise il codice &#39;\0&#39; per definire la fine.
Gli array possono essere utilizzati come &#34;contenitori&#34; per moltissime impieghi, ad esempio per organizare tutti i voti di uno studente, come fosse una cartella che contiene tutti i valori e che possono essere &#34;letti&#34; successivamente.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2523"><question_text>In cosa consiste la tecnica della valutazione &#34;pigra&#34; (lazy-evaluation) utilizzata in C/C++?</question_text><answer id="A2397"><answer_text>Durante la valutazione di condizioni se il programma (leggendo da sx verso dx) ritiene che la condizione appena letta risulta verificata conclude la valutazione senza considerare il resto poiché ritenuto superfluo.
Es:
x=5;
if(x&#60;10 || x=1){....}
In questo caso la prima condizione è vera quindi non occorre analizzare la seconda.</answer_text><num_votes>1</num_votes></answer><answer id="A2460"><answer_text>La Lazy-evalutation consiste nel posticipare la valutazione di una computazione fino a quando il risultato della computazione è realmente usato.
Questa tecnica aumenta le performance di un programma (non valutando i componenti non necessari alla computazione)e riduce la possibilità di incontrare errori nella valutazione condizionale di computazioni.</answer_text><num_votes>0</num_votes></answer><answer id="A2445"><answer_text>La valutazione pigra è una strategia di valutazione che ritarda la valutazione di un&#39;espressione fintantoché il suo valore non è richiesto e che evita di eseguire per più di una volta la stessa valutazione, diminuendo così il tempo di esecuzione.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2514"><question_text>Quali operazioni sono possibili su un intero array? è possibile ad esempio copiare o stampare un intero array piuttosto che tutti i suoi elementi in sequenza (attraverso un ciclo)?</question_text><answer id="A2508"><answer_text>Non sono previste operazioni su interi array; pertanto è necessario realizzarle a programma mediante cicli che permettano di iterare su tutti i singoli elementi degli array considerati. </answer_text><num_votes>2</num_votes></answer><answer id="A2493"><answer_text>Sugli elementi di un array di tipo &#34;int&#34; sono possibili tutte le normali operazioni aritmetiche. A ciascun elemento all?interno dell?array si accede tramite un indice ( intero &#62;= 0). Questo che segue è un ciclo per stampare un array di 5 righe con 5 colonne di numeri interi precedentemente inizializzati. Come è possibile vedere sono necessari due cicli per stampare un array in formato matrice, altrimenti è sufficiente un solo ciclo.


	
for (i=0; i&#60;5; i++) {

		for (k=0; k&#60;5; k++) {
		
		printf(&#34;%d &#34;,array[i][k]);
		}
		printf(&#34;\n&#34;);
}	</answer_text><num_votes>0</num_votes></answer><answer id="A2483"><answer_text>Nella programmazione C non è possibile fare operazioni (ad esempio printf o scanf) su un intero array. Per stampare il contenuto ci si deve servire del ciclo &#39;for&#39; che permette di scorrere i vari elementi che compongono l&#39;array. Ad esempio se volessi stampare il contenuto di v[10] (array di interi):
for(i=0,i&#60;10,i++){
     printf(&#34;%d&#34;,v[i]);
}
Se però si volesse stampare, ad esempio, solo il quarto valore dell&#39;array si scriverà:
printf(&#34;%d&#34;,v[3]);</answer_text><num_votes>2</num_votes></answer><answer id="A2466"><answer_text>Un array dev&#39;essere inizializzato con un ciclo FOR; lo stesso ciclo va eseguito per l&#39;assegnazione dei valori nelle fasi successive o per la stampa. Per estrarre un valore dall&#39;array si utilizzano le parentesi quadre e l&#39;indice. La struttura dell&#39;array può infine essere utilizzata per la definizione di una matrice.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2495"><question_text>Abbiamo visto tre metodi per dichiarare una struttura: struct nome{ ...., struct { ... e alla fine il nome prima del punto e virgola, poi l&#39;ultimo metodo col typedef struct{..., e infine il nome della struttura stessa. Spiegare le principali differenze su questi metodi e sopratutto i vantaggi e svantaggi di tali metodi.</question_text><answer id="A2426"><answer_text>Scrivendo struct x{..} x1; x è il nome della struttura, e x1 il nome della variabile. 
Se uso struct x{..}; sul main devo dichiarare una variabile in questo modo: 
struct x x1;     x1.campo=valore; 
se invece faccio questa dichiarazione struct {..}x1;  x1 è la mia variabile e posso inizializzare direttamente i campi della struct:
x1.campo=valore; 
Invece usando typedef struct{..}nome; per dichiarare una variabile basta semplicemente scrivere nel main  
nome s1,s2,s3,sn;  
s1.campo=valore;  
I vantaggi nell&#39;usare typedef sono relativi all&#39;ordine, leggebilità e comprensione del codice.</answer_text><num_votes>1</num_votes></answer><answer id="A2519"><answer_text>Con la sintassi &#34;struct nome0{..}&#34; non si dichiara una variabile di tipo struct ma solo una struttura di nome &#34;nome0&#34; (quindi successivamente va dichiarata una variabile scrivendo &#34;struct nome0 nome_variabile&#34;), con &#34;struct {..}nome1&#34; viene dichiarata una variabile di tipo struct che si chiama &#34;nome 1&#34; ma la struttura non ha un nome mentre con &#34;typedef struct {..}nome_tipodato&#34; si crea un nuovo tipo di variabile definita dell&#39;utente che si chiama &#34;nome_tipodato&#34;. Le prime due sono equivalenti mentre la terza ha il vantaggio che permette successivamente il riuso del tipo di dato &#34;nome_tipodato&#34;</answer_text><num_votes>2</num_votes></answer><answer id="A2490"><answer_text>struct consente di avere un gruppo di variabili,anche di tipo diverso,aggregate insieme con un unico nome il secondo è di tipo struct alla fine vengono dichiarate delle etichette per la struttura e servono come abbreviazione per le successive dichiarzioni(non il nome del costrutto)typedef struct invece permette di creare tipi di dato molto complessi,il suo scopo è quello di assegnare dei nomi alternativi a dei tipi di dato esistenti,solitamente a quelli la cui dichiarazione standard è troppo ingombrante
vantaggi:le variabili dichiarate nelle strutture si possono usare in tutto il main</answer_text><num_votes>0</num_votes></answer></question><question id="Q2525"><question_text>In quali casi le variabili vengono dichiarate globali (fuori dal metodo &#34;main&#34;) e locali (dentro al metodo &#34;main&#34;)?</question_text><answer id="A2498"><answer_text>Vengono definite globali quando ha senso che queste variabili possano venire utilizzate in ogni funzione al di fuori del main e nel main stesso. Mentre vengono definite locali quelle variabili il cui utilizzo è relativo solo all&#39;interno del main e possono essere viste solo da questo.</answer_text><num_votes>0</num_votes></answer><answer id="A2368"><answer_text>Le variabili globali sono utili quando più funzioni utilizzano gli stessi dati, ma hanno lo svantaggio che impiegano la memoria per tutta la durata del programma e non solo quando è necessaria.
L&#39;uso di una variabile globale dove potrebbe essere usata una locale rende le funzioni meno generali perché il loro funzionamento implica la conoscenza di un elemento esterno alla funzione.
Inoltre usando molte variabili globali si rischia di perdere il controllo e ciò può portare ad errori dovuti ad effetti collaterali indesiderati ed imprevisti.</answer_text><num_votes>4</num_votes></answer></question><question id="Q2443"><question_text>cosa si intende per &#34;pseudo-codice&#34;?</question_text><answer id="A2459"><answer_text>Per pseudo-codice si intende un linguaggio informale che si avvicina ad un linguaggio di programmazione, ma è molto più astratto in quanto serve esclusivamente all&#39;uomo per farsi un&#39;idea sulla scrittura di algoritmi.</answer_text><num_votes>1</num_votes></answer><answer id="A2465"><answer_text>Per &#34;pseudo-codice&#34; si intende un linguaggio di programmazione rappresentativo che serve per dare un idea del progetto che andra? scritto in linguaggio C vero e proprio.

</answer_text><num_votes>0</num_votes></answer><answer id="A2484"><answer_text>Per pseudocodice si intende un tipo di linguaggio utile per rappresentare un algoritmo, può affiancare o sostituire un diagramma a blocchi. Questo linguaggio si inserisce tra la descrizione in linguaggio naturale dell&#39;algoritmo e la stesura del programma con un linguaggio di alto livello. Non è compilabile o interpretabile dalla macchina, serve solo a rendere l&#39;idea della sequenza di istruzioni che il programma dovrà eseguire.</answer_text><num_votes>1</num_votes></answer><answer id="A2520"><answer_text>Si intende un linguaggio non direttamente eseguibile da un calcolatore, utile però per la descrizione di algoritmi.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2486"><question_text>Che cosa auccede se si omette il break all&#39;interno del costrutto switch? </question_text><answer id="A2475"><answer_text>Se si omette il &#34;break&#34; il controllo passa da un blocco &#34;case&#34; all?altro: nel momento in cui fosse già stata trovata la soluzione, in assenza di &#34;break&#34;, il compilatore andrà a verificare anche tutti gli altri &#34;case&#34;.
Sostanzialmente l&#39;utilizzo di &#34;break&#34; molte volte permette di evitare un dispendio inutile di risorse.</answer_text><num_votes>1</num_votes></answer><answer id="A2415"><answer_text>Succede che si avrà un&#39; esecuzione a cascata di tutti i case successivi a quello scelto e quindi è indispensabile metterlo per far si che salti le istruzioni contenute nei successivi case e vada direttamente all&#39;istruzione successiva allo switch.</answer_text><num_votes>0</num_votes></answer><answer id="A2414"><answer_text>Con il costrutto switch la macchina deve valutare l&#39;espressione dopo la parola switch. Se il suo valore appartiene a uno degli insiemi di costanti specificati mediante le clausole case, la macchina esegue la sequenza di istruzioni riportata dopo l&#39;insieme di costanti e quelle dei rami case successivi. Per evitare questo &#34;fenomeno a cascata&#34; e quindi per fare in modo che solo le istruzioni associate all&#39;insieme di valori costanti selezionato siano eseguite, si posiziona un&#39;istruzione break, che ha l&#39;effetto di far saltare le istruzioni dei successivi rami case. </answer_text><num_votes>1</num_votes></answer><answer id="A2405"><answer_text>Il break è una parte del costrutto switch il quale fa si che dopo aver trovato il caso/risultato adatto all&#39;espressione inserita, il ciclo termini senza continuare a controllare inutilmente i casi successivi. Ad esempio:
switch(espressione){
case val1: blocco istruzioni 1;
                break;
case val2: blocco istruzioni 2;
                break;
default:...
}
Se l&#39;espressione equivale a val1, dopo aver eseguito il blocco di istruzioni 1, il break termina il ciclo switch. Se questo non fosse presente, il ciclo andrebbe a controllare anche se l&#39;espressione equivale a val2.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2464"><question_text>Qual&#39;è la differenza tra una variabile semplice e una variabile strutturata?
In partcolare vorrei capire le loro essenziali differenze nel loro utilizzo.</question_text><answer id="A2532"><answer_text>Le variabili semplici contengono una sola informazione e per individuarle é sufficiente solo un nome. Le variabili strutturate richiedono una loro struttura interna che permetta una efficiente memorizzazione delle informazioni e altrettanta efficiente individuazione delle informazioni memorizzate. Oltre ad un semplice nome che individua l&#39;intero archivio,possono richiedere altri nomi o indici,in modo tale che ogni parte sia individuabile.</answer_text><num_votes>0</num_votes></answer><answer id="A2431"><answer_text>Una variabile semplice cioè di tipo built-in(es int, char ecc) ha a disposizione uno spazio
di memoria limitato dipendente dal tipo di dato (es int dispone di 16bit), in cui è possibile 
salvare un solo dato.Una variabile strutturata come l&#39;array permette di avere a disposizione più locazioni di memoria(stabilite nell&#39;indice) in cui salvare i dati(sempre un dato per cella di memoria).Si utilizza una variabile strutturata quando si devono valorizzare dati aventi comune attinenza(es nome-cognome di una persona), se si necessita solo di un valore è preferibile utilizzare una variabile built-in.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2563"><question_text>Da cosa si differenziano le codifiche ASCII e quella Unicode? Perché la seconda ha preso il sopravvento sulla prima in ambito web?</question_text><answer id="A2477"><answer_text>Ascii e&#39; il codice Standard Americano per lo Scambio di Informazioni che può essere standard (7 bit = 128 combinazioni) oppure esteso (8 bit = 256 combinazioni). Unicode è una codifica che ha permesso di rappresentare ogni simbolo esistente nelle varie lingue del mondo attraverso un codice di 2 byte (16 bit = 65535 combinazioni). Unicode ha preso il sopravvento in ambito web rispetto ad Ascii perche&#39; e&#39; possibile utilizzare molti piu&#39; caratteri e le diverse codifiche utilizzate fanno riferimento alla grande tabella di Unicode.</answer_text><num_votes>2</num_votes></answer><answer id="A2521"><answer_text>Praticamente il codice ASCII è un codice che può avere 7 o 8 bit (standard o esteso), quindi occupa relativamente poco spazio nlla memoria, tuttavia non è in grado di rappresentare tutti i carattereri esistente.
Il codice UNICODE, invece, può avere 16 o 32 bit, quindi ha molti simboli aggiuntivi e si prefigge il compito di coprire tutti i simboli (compresi gli ideogrammi) ma occupa, chiaramente, un maggior spazio in memoria.
Unicode sta prendendo il sopravvento in quanto è utilizzato nella rete internet, per esempio, per poter rappresentare anche le lingue con caratteri speciali.</answer_text><num_votes>2</num_votes></answer><answer id="A2464"><answer_text>sono codifiche che servono entrambe a rappresentare i caratteri. Ma mentre la codifica ASCII utilizza 8 bit ( quindi può rappresentare al massimo 256 fra caratteri, numeri e simboli ), quella unicode ne utilizza 16 ( ma è stata aggiornata per poterne utilizzare 21 ), potendo cosi codificare  fino a 65.536 caratteri. Quindi Unicode è utilizzata su internet perchè sul ewb bisogna necessariamente rappresentare i caratteri di diverse lingue.</answer_text><num_votes>1</num_votes></answer><answer id="A2457"><answer_text>La codifica ASCII si differenzia dall?Unicode per il fatto che gli ultimi 128 caratteri (dei 256 rappresentabili con 8 bit) si differenziano per lingue o applicazioni diverse, mentre l?Unicode mira ad includere tutti i caratteri in un unica codifica, seppur con più bit. Lo standard Unicode ha superato l&#39;ASCII come codifica per il web proprio per questa maggiore capacità espressiva e la comodità di una codifica standard per tutto. Resta il fatto che la parte 8 bit dell?Unicode (UTF-8) riprende migliorato lo schema ASCII.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2453"><question_text>Data questa porzione di codice:

int flag=1;
while(flag!=0){
   scanf(&#34;%d&#34;,&#38;flag);
}

dire perchè il seguente codice non è un algoritmo, cioè quale regola nella definizione di algoritmo viola.</question_text><answer id="A2525"><answer_text>Una delle regole principali perchè un algoritmo possa essere definito tale e&#39; che deve essere composto da &#34;una sequenza precisa e finita di operazioni&#34; che eseguano un determinato compito. Il codice proposto invece, fa eseguire un ciclo che si concludera&#39; solo quando l&#39;utente inserira&#39; il valore 0, il numero di operazioni non è quindi definito.
Inoltre questo codice non svolge nessun compito rilevante, assegna un valore ad una variabile e questo valore dovra&#39; essere per forza di cose 0 perchè il programma termini.</answer_text><num_votes>1</num_votes></answer><answer id="A2416"><answer_text>Un algoritmo è definito come una sequenza precisa di operazioni, comprensibili da un esecutore che definisce una sequenza FINITA di passi. Come si può notare la porzione di codice soprastante viola l&#39;ultima regola, infatti, al suo interno c&#39;è un ciclo while infinito il quale rende queste righe di codice una sequenza di istruzioni infinite.</answer_text><num_votes>0</num_votes></answer><answer id="A2449"><answer_text>Un algoritmo per essere definito tale deve essere composto da una sequenza precisa e finita di operazioni volte alla realizzazione di un compito. Il codice in esame propone invece un ciclo che si ripete fino a che l&#39;utente digita il numero &#34;0&#34;, pertanto il ciclo potenzialmente potrebbe essere infinito e quindi non composto da una serie &#34;finita&#34; di operazioni.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2571"><question_text>Cosa contraddistingue il livello di astrazione del linguaggio C?</question_text><answer id="A2417"><answer_text>Il livello di astrazione è medio-alto poiché il linguaggio si discosta alquanto dal linguaggio macchina, lasciando al sistema la gestione di molti aspetti come l&#39; allocazione e gestione di memoria, registri e indirizzi di memoria.</answer_text><num_votes>0</num_votes></answer><answer id="A2506"><answer_text>Il potere espressivo di un linguaggio si manifesta nei tipi di dato e nelle operazioni esprimibili, cioé l&#39;insieme di istruzioni previste per esprimere il controllo del flusso di esecuzione.Le caratteristiche principali del linguaggio C sono le seguenti:l&#39;elevato potere espressivo(tipi di dato primitivi e tipi di dato definibili dall&#39;utente),le caratteristiche di basso livello,lo stile di programmazione che incoraggia lo sviluppo di programmi per passi di raffinamento successivi e infine la sintassi definita formalmente.
</answer_text><num_votes>2</num_votes></answer><answer id="A2443"><answer_text>Anche se il c viene considerato un linguaggio di alto livello, ovvero più vicino al linguaggio umano, quindi più capibile, esso permette di programmare anche a &#34;basso livello&#34;, ad esempio usando i puntatori possiamo gestire la memoria a nostro piacimento, quindi più a basso livello.
Per questo ancora oggi il c viene utilizzato, perchè il software creato è molto snello. </answer_text><num_votes>1</num_votes></answer></question><question id="Q2568"><question_text>Qual è la differenza fra &#34;#define A 20&#34; e &#34;const int A = 20&#34; visto che in entrambi i modi A è una costante con il valore di 20?</question_text><answer id="A2421"><answer_text>Il comando &#34;#define&#34; è detto di preprogramma, è una direttiva al compilatore che definisce una &#34;macro&#34; (stringa), nel nostro caso &#34;A&#34;, che il compilatore, in fase di compilazione sostituirà con la &#34;stringa di sostituzione&#34;, nel nostro caso &#34;20&#34;. Non viene allocato alcun valore in memoria.
Scrivere &#34;const int A = 20&#34; significa dichiarare una costante di tipo intero identificata con &#34;A&#34; e di valore &#34;20&#34;. In questo caso il compilatore predispone una locazione di memoria e vi scrive il valore &#34;20&#34; che rimane costante durante l&#39;esecuzione del programma senza possibilità di essere modificato.</answer_text><num_votes>2</num_votes></answer><answer id="A2429"><answer_text>La dichiarazione di costanti tramite &#34;#define&#34; prevede che i valori assegnati alle costanti vengano sostituiti in fase di compilazione. 
Nel caso di dichiarazione con &#34;const&#34;, invece, il valore assegnato viene archiviato in una zona di memoria.
Ne consegue che l&#39;uso di &#34;#define&#34; diminuisce l&#39;occupazione di memoria e rende più veloce il programma, poiché durante l&#39;esecuzione, quando si utilizzano tali costanti, non è necessario ricercarne i valori in memoria.</answer_text><num_votes>0</num_votes></answer><answer id="A2527"><answer_text>#define è un&#39; istruzione che fa parte del precompilatore: il compilatore esegue una sostituzione di &#39;A&#39; con 20 all&#39;interno del codice prima della compilazione (può, ma in minima parte, rendere un po&#39; più veloce l&#39;esecuzione). Con const, invece, la costante viene elaborata una sola volta e viene allocato spazio per contenerla in una cella di memoria e viene quindi richiamata nel codice con tale indirizzo. Inoltre il compilatore esegue il controllo della validità della costante. Con&#34;const&#34;quando viene applicato ad una variabile, questa cessa di essere modificabile e avremo di fatto una costante.</answer_text><num_votes>1</num_votes></answer><answer id="A2507"><answer_text>&#34;#define A 20&#34; è un comando che si dà prima del main, e quindi nel precompilatore, e quindi il valore &#34;20&#34; viene fisicamente sostituito nel codice dove compare &#34;A&#34;. Invece nel secondo caso si tratta di una variabile che viene sostituita all&#39;occorenza, solo nella fase di ottimizzazione, quindi nelle ultime fasi della compilazione.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2470"><question_text>Una delle caratteristiche del linguaggio C è quella di essere &#34;case sensitive&#34;. Questo cosa significa?</question_text><answer id="A2386"><answer_text>Una caratteristica del C è essere &#34;case sensitive&#34;, il ciò significa che le lettere maiuscole e minuscole sono importanti. Per esempio se dichiaro una variabile come &#34;val&#34; è diverso da &#34;Val&#34; o &#34;VAL&#34;.</answer_text><num_votes>0</num_votes></answer><answer id="A2394"><answer_text>Significa che il compilatore distingue le lettere minuscole dalle mauscole. Scrivere ad esempio printf
o PRINTF o Printf sono casi completamente diversi. Questo permette anche di identificare anche delle
parole chiave che non possono essere utilizzate in altri ambiti (tipo nome_variabile o nome_funzione).</answer_text><num_votes>1</num_votes></answer><answer id="A2395"><answer_text>il linguaggio di programmazione C si dice &#34;case sensitive&#34; poiché riesce a distinguere i caratteri maiuscoli da quelli minuscoli, una caratteristica peculiare di questo linguaggio di programmazione.</answer_text><num_votes>0</num_votes></answer><answer id="A2399"><answer_text>Significa che il linguaggio riconosce le lettere minuscole da quelle maiuscolo, cioè nel caso noi dichiariamo due variabili dal nome &#34;Lettera&#34; e &#34;lettera&#34; in compilazione C non darà errore ma avrà allocato in momoria lo spazio per la variabile &#34;Lettera&#34; e un&#39;altro spazio per la variabile &#34;lettera&#34;.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2490"><question_text>In che modo posso usufruire dei puntatori per la gestione di array?</question_text><answer id="A2452"><answer_text>Nel linguaggio C, un array non è altro che una sequenza di elementi posizionati in modo contiguo in memoria. Proprio per questa caratteristica dell&#39;array, possiamo notare come sia strettamente collegata al concetto di puntatore: un array non è altro che un puntatore ad una serie di elementi. L&#39;uso dei puntatori è quindi indispensabile per qualsiasi operazione atta alla gestione dell&#39;array: l&#39;ordinamento,l&#39;ispezione o qualsiasi algoritmo che operi su un array lo fa attraverso i puntatori ai suoi elementi e\o utilizzando l&#39;aritmetica dei puntatori. </answer_text><num_votes>1</num_votes></answer><answer id="A2485"><answer_text>Innanzitutto se volessi individuare l&#39;n-esimo elemento all&#39;interno di un&#39;array  di nome &#34;a&#34; posso usare indistintamente la scrittura a[n] oppure utilizzando i puntatori  la scrittura a *(a+ n). Inoltre se ho due puntatori &#34;i&#34; ed &#34;n&#34; che puntano a due celle di memoria di un&#39;array la differenza i-n mi darebbe come risultato il numero di elementi presenti tra le due celle di memoria.</answer_text><num_votes>1</num_votes></answer><answer id="A2513"><answer_text>Grazie ai puntatori è possibile la completa gestione di un array. Le operazioni eseguibili dai puntatori sono definite dalla loro aritmetica. Esempio: con le istruzioni &#34;p=&#38;a[0]&#34;, o &#34;p=a&#34; (notazioni equivalenti), dove &#34;p&#34; è un puntatore e &#34;a&#34; un array, è possibile puntare al primo elemento dell&#39;array. Incrementando poi il puntatore (p++) si andrà a puntare al successivo elemento dell&#39;array, allo stesso modo sarà possibile puntare a qualsiasi elemento. Se poi andremo ad eseguire l&#39;istruzione &#34;x=*p&#34;, assegneremo il valore contenuto dentro l&#39;indirizzo al quale punta il nostro puntatore.
</answer_text><num_votes>3</num_votes></answer><answer id="A2480"><answer_text>L&#39;identificatore di un array funge da puntatore al primo elemento dello stesso, ma non è possibile modificarne il valore, quindi i puntatori possono essere utilizzati per puntare a tutti gli altri elementi dell&#39;array. Bisogna porre però particolare attenzione alla dimensione dell&#39;array, per evitare di oltrepassarne i &#34;confini&#34; in memoria.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2503"><question_text>Ci sono due modi per decodificare un numero decimale di tipo reale in forma binaria: decodifica a virgola fissa e a virgola mobile. In cosa consiste e come funziona la rappresentazione in virgola mobile? Quali sono i vantaggi rispetto alla decodifica in virgola fissa? </question_text><answer id="A2385"><answer_text>Innanzi tutto con la rappresentazione in virgola fissa e in virgola mobile si possono rappresentare solo numeri razionali e approssimazioni di numeri reali. La rappresentazione in virgola mobile non decide a priori quanti bit verranno riservati alla parte intera e alla parte decimale del numero al contrario della rappresentazione in virgola fissa. Quindi la rappresentazione in virgola mobile permette di avere una migliore precisione della mantissa.</answer_text><num_votes>0</num_votes></answer><answer id="A2463"><answer_text>Nella rappresentazione in virgola mobile un numero reale in un sistema di numerazione decimale può essere visto come:
r=M*10^n
dove M, detta matissa è un numero frazionario cioè compreso tra -1 e 1, e 10 rappresenta la base (o radice) elevata ad n, un numero intero con segno, detto esponente.
Con questo tipo di rappresentazione si ha il vantaggio rispetto alla virgola fissa di poter codificare numeri molto grandi e numeri molto piccoli con lo stesso numero di bits a disposizione. Per questa ragione si utilizza questo tipo di rappresentazione.</answer_text><num_votes>2</num_votes></answer><answer id="A2526"><answer_text>la codifica in virgola mobile viene eseguita con 32 bit , il msb(bit più significativo) 
rappresenta il segno del numero, i successivi 8 bit rappresentano il valore dell&#39;esponente
( a parte il primo che rappresenta il segno dello stesso), i restanti23 bit rappresentano la mantissa).
il vantaggio di utilizzare questa decodifica è che è possibile rappresentare un insieme di numeri reali più 
grande rispetto la virgola fissa.

</answer_text><num_votes>2</num_votes></answer></question><question id="Q2476"><question_text>Che differenza c&#39;è tra variabile e puntatore?</question_text><answer id="A2434"><answer_text>La variabile é in valore memorizzato nella &#34;locazione di memoria&#34; della variabile, mentre un puntatore dice quale in quale &#34;locazione di memoria&#34; é scritto il valore della variabile.
</answer_text><num_votes>0</num_votes></answer><answer id="A2358"><answer_text>Mentre una variabile contiene un valore, che potrebbe essere di tipo char, int, double , float etc... un puntatore contiene l&#39;indirizzo di una variabile contenente un determinato valore.</answer_text><num_votes>0</num_votes></answer><answer id="A2393"><answer_text>La variabile identifica un certo tipo di dato nella sua cella di memoria. Il puntatore invece tiene nella sua cella di memoria l indirizzo di un altra variabile. Puntatore e variabile indirizzata devono essere dello stesso tipo. I puntatori sono gestiti dagli operatori unari * e &#38; che prendono rispettivamente i right e left value della variabile puntata. Anche sui puntatori valgono le regole dell algebra, ma si gioca sugli indirizzi e non sui valori delle variabili. La memoria utilizzata da variabili e puntatori è sempre la stessa quantità, che dipende dal tipo prescelto.</answer_text><num_votes>3</num_votes></answer><answer id="A2433"><answer_text>La variabile é in valore memorizzato nella &#34;locazione di memoria&#34; della variabile, mentre un puntatore dice quale in quale &#34;locazione di memoria&#34; é scritto il valore della variabile.
</answer_text><num_votes>0</num_votes></answer></question><question id="Q2570"><question_text>Perchè scrivendo while() si otterrà in uscita un programma con un ciclo infinito? </question_text><answer id="A2378"><answer_text>Partendo dal presupposto che scrivendo while() il compilatore ci darà errore,dato che il while tra le parentesi necessita di una condizione (altrimenti è errore);comunque, se tra le parentesi mettiamo una costante !=0 allora il ciclo while ciclerà all&#39;infinito dato che quella condizione è sempre vera, se invece mettiamo tra le parentesi del while uno 0, allora uscirà immediatamente dal ciclo dato che per il c lo 0 equivale a falso e tutto il resto a vero. Il ciclo while terminerà non appena valuta una condizione come falsa, per esempio  int a=5;b=3;
while (a=b) {blocco istruzioni}.</answer_text><num_votes>0</num_votes></answer><answer id="A2363"><answer_text>Nel linguaggio di programmazione C, ogni ciclo while è costituito da while(condizione) e tra parentesi graffe le istruzioni da eseguire. Non inserendo nessuna condizione, quindi while(), il compilatore darà un errore di sintassi e non potrà eseguire il programma (è quindi errato dire che darà un ciclo infinito). E&#39; possibile invece creare un ciclo infinito inserendo tra parentesi una condizione sempre vera oppure qualsiasi valore purchè diverso da 0 
(es. while(a&#62;a-1) oppure while(1)). Con while(0), invece, il programma considera la condizione errata quindi non entrerà mai nel ciclo.</answer_text><num_votes>1</num_votes></answer><answer id="A2438"><answer_text>Scrivendo while(){} non si ottiene in uscita un ciclo infinito; si viene a generare un&#39;errore in fase di compilazione perchè risulta mancante la condizione del ciclo while.
Si ottiene invece un ciclo infinito scrivendo while(1){} perchè la condizione ha sempre valore &#34;1&#34; e quindi è sempre vera (!=0). Per questo il calcolatore non uscirà mai dal ciclo while una volta che ci è entrato.

Al contrario un ciclo while(0){} non verrà mai eseguito perchè la condizione sarà sempre falsa. Quindi sarà un ciclo &#34;inutile&#34; perchè il calcolatore non avrà mai la possibilità di mandarlo in esecuzione</answer_text><num_votes>1</num_votes></answer></question><question id="Q2513"><question_text>Quando si programma si utilizzano delle variabili e/o delle costanti: a cosa servono le variabili e le costanti, in cosa differiscono tra loro e da cosa sono caratterizzate?</question_text><answer id="A2401"><answer_text>Le variabili e le costanti servono per memorizzare e tener traccia di un valore in una determinata area di memoria.Ogni variabile o costante è caratterizzata da un tipo di dato che specifica come devono e possono essere gestiti i dati all&#39;interno di esse.La differenza principale è nel loro utilizzo,infatti,durante l&#39;esecuzione del programma il valori contenuti all&#39;interno delle variabili posso essere modificati mentre i valori delle costanti no(Le costanti sono definite a priori dal programmatore).
dichiarazione variabile: TIPO_DATO NOME
dichiarazione costante: #define TIPO_DATO NOME</answer_text><num_votes>0</num_votes></answer><answer id="A2384"><answer_text>Durante l&#39;esecuzione di un programma l&#39;utilizzo di variabili è fondamentale per permettere al logaritmo di cambiare il risultato finale.
Differenze: 
Le variabili possono cambiare il valore del dato a cui sono state assegnate durante l&#39;esecuzione del programma, inoltre ci sono molti tipi di dati che gli si possono attribuire.
Le costanti invece hanno un valore rigido per tutta la durata del programma e non dispongono di tutti i tipi di dati se non gli interi.
Sebbene le costanti abbiano la stessa funzione delle variabili, il loro utilizzo rende il programma molto più ordinato e affidabile.</answer_text><num_votes>0</num_votes></answer><answer id="A2518"><answer_text>Le costanti sono dati usabili solo in sola lettura e si definiscono sempre fuori dal main mediante il comando specifico #define mentre le variabili sono contenitori il cui contenuto puo cambiare e vengono definite specificando solo il tipo di dato che devono contenere.
Le prime sono usate per esempio nei cicli e negli array per definire il numero di ripetizioni ed il numero di elementi oltre che per valori fissi quali esempio la p greca, le variabili invece si usano per dati e contatori tipicamente.</answer_text><num_votes>1</num_votes></answer><answer id="A2492"><answer_text>variabili e costanti sono utilizzate nel C per memorizzare numeri ,caratteri e stringhe. Come suggerisce il nome, per le variabili una volta dichiarato il loro tipo, possono cambiare infinite volte il loro valore semplicemente dichiarando un valore nuovo. Le costanti mantengono sempre il valore assegnato al momento dell&#39;inizializzazione e non ne permettono la modifica. 
Le variabili possono essere dichiarate ed inizializzate nel seguente modo
 tipo nomevariabile=valore;  esempio int a=1;
E per le costanti in due modi possibili:
 const int c=3;
oppure, prima del main: #define c 3;</answer_text><num_votes>1</num_votes></answer></question><question id="Q2416"><question_text>Quali sono le tre fasi principali nell&#39;esecuzione di un programma? descrivile </question_text><answer id="A2446"><answer_text>Le 3 fasi di esecuzione sono: FETCH: l&#39;indirizzo della prima istruzione viene inserito nel ProgramCounter. La CU copia il contenuto del PC nell&#39; AR e viene letto quell&#39;indirizzo; tale dato viene conservato in DR. Il contenuto di DR viene ricopiato in IR. Nel frattempo PC si è aggiornato alla locazione successiva. DECODE: L&#39;istruzione viene interpretata, prelevando eventualmente dalla memoria altri dati necessari. EXECUTE: i dati vengono caricati nei registri e la CU invia alla ALU il comando di esecuzione dell&#39;operazione. Il risultato sarà contenuto in uno dei registri. La PSW verrà aggiornata</answer_text><num_votes>2</num_votes></answer><answer id="A2528"><answer_text>Le fasi principali di esecuzione di un programma sono:
- Edit: Il programma viene creato e memorizzato sul disco
- Loader: Il programma viene caricato
- Execute: Il programma viene eseguito</answer_text><num_votes>0</num_votes></answer><answer id="A2522"><answer_text>Le tre fasi principali nell&#39;esecuzione di un programma sono la &#34;fase di fetch&#34;, nella quale mediante il registro &#34;program counter&#34; si individua l&#39;indirizzo dell&#39;istruzione che viene posto sul bus indirizzi e attraverso il bus dati l&#39;istruzione individuata viene portata nel registro istruzioni; &#34;la fase di interpretazione&#34; nella quale l&#39;unità di controllo (UC) decodifica l&#39;istruzione nel registro istruzione corrente (CIR);infine nella &#34;fase di esecuzione&#34; la UC genera la sequenza di segnali per eseguire l&#39;istruzione.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2440"><question_text>Perché il linguaggio C viene definito ad alto livello?</question_text><answer id="A2491"><answer_text>Il C, rispetto al linguaggio macchina e assembly, viene considerato un linguaggio di alto livello in quanto permette di astrarre alcuni problemi come la gestione della memoria, delle istruzioni e del linguaggio di definizione dell&#39;algoritmo. Sarà infatti il compilatore, non il programmatore, a gestire queste problematiche. Tuttavia il C risulta molto più vicino al linguaggio macchina di altri linguaggi (Pascal e BASIC) e viene infatti spesso identificato come linguaggio di medio livello.</answer_text><num_votes>1</num_votes></answer><answer id="A2511"><answer_text>In realtà il linguaggio C è definito a medio livello.
Questo perché si trova in una posizione intermedia tra i linguaggi di basso livello (come quello assembler, più vicino al calcolatore) e quelli di alto livello (più lontani dal linguaggio macchina).
Questo trova una spiegazione, ad esempio, nel fatto che il C permetta di intervenire sull&#39;allocazione della memoria, pur distanziandosi notevolmente dal linguaggio macchina.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2418"><question_text>Nella scrittura di un programma quanto incide l&#39;ottimizzazione rispetto alla funzionalità? Si ottimizza una volta che è stato reso funzionate o già in sede di scrittura iniziale?</question_text><answer id="A2487"><answer_text>Per ottimizzazione si intende il processo con cui si incrementano sensibilmente le prestazioni del programma sostituendo alcuni costrutti con altri equivalenti ma più efficienti.La funzionalità è invece il grado con cui il programma risolve i problemi proposti. 
L&#39;ottimizzazione avviene a programma già scritto e funzionante e si compone tipicamente di sei fasi: Collaudo prestazionale, Analisi delle prestazioni, Ottimizzazione Algoritmica, Ottimizzazione indipendente dalla piattaforma, Ottimizzazione dipendente dalla piattaforma software e Ottimizzazione dipendente dalla piattaforme hardware. </answer_text><num_votes>1</num_votes></answer><answer id="A2440"><answer_text>Anche se non so se ho capito la domanda, rispondo a ciò che ho compreso.
Si ottimizza già in sede di scrittura iniziale, se è possibile, per risparmiare lavoro. Ma se ci si accorge, dopo aver scritto il programma, che esiste un alternativa più ottimale, e si ha ancora tempo, si procede con l&#39;ottimizzazione. Chiaramente la funzionalità è molto importante, tuttavia, come in tutte le cose, fare ciò che si vuole fare con meno costo e meno risorse, è meglio.</answer_text><num_votes>0</num_votes></answer><answer id="A2512"><answer_text>Sicuramente l&#39;ottimizzazione è importante, in quanto consente di utilizzare le risorse nel miglior modo; a volte però, a causa dell&#39;elevata funzionalità richiesta, non è possibile effettuare una buona ottimizzazione poichè graverebbe sulla funzionalità; quindi una risposta univoca non esiste, poichè dipende dalle esigenze per cui viene creato quel programma.
L&#39;ottimizzazione viene fatta in fasi dipendenti dalla filosofia e dall&#39;abitudine del programmatore; personalmente ottimizzo già nella fase di scrittura, ma spesso al termine della scrittura riesco ad migliorare ulteriormente il programma.</answer_text><num_votes>1</num_votes></answer><answer id="A2402"><answer_text>Nella scrittura di un programma è essenziale analizzare il problema e progettare l?algoritmo funzionale che poi verrà tradotto in un programma per il computer. È importante la funzionalità dato che un programma super-efficiente che ritorna risultati troppo approssimati non serve ma è importante anche l?ottimizzazione, perché un programma corretto che non funziona non serve. In linea di massima si deve ottimizzare già in sede di scrittura. È possibile comunque ottimizzare ulteriormente il programma una volta che è funzionante.</answer_text><num_votes>0</num_votes></answer><answer id="A2403"><answer_text>Nella scrittura di un programma è essenziale analizzare il problema e progettare l?algoritmo funzionale che poi verrà tradotto in un programma per il computer. È importante la funzionalità dato che un programma super-efficiente che ritorna risultati troppo approssimati non serve ma è importante anche l?ottimizzazione, perché un programma corretto che non funziona non serve. In linea di massima si deve ottimizzare già in sede di scrittura. È possibile comunque ottimizzare ulteriormente il programma una volta che è funzionante.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2560"><question_text>Come si dichiara un puntatore?</question_text><answer id="A2479"><answer_text>Per dichiarare un puntatore si fa seguire alla variabile di tipo puntatore (P) il tipo di riferimento di appartenenza, ad esempio un puntatore che contiene l&#39;indirizzo di una variabile intera si dichiara così:
int* P;
dove l&#39; operatore * (operatore non referenziato) manda al contenuto dell&#39;oggetto a cui punta P. P può avere tre possibili valori:
P: contenuto o valore della variabile P (indirizzo della locazione di memoria a cui punta);
&#38;P: indirizzo fisico della locazione di memoria di P;
*P: contenuto della locazione di memoria a cui punta; </answer_text><num_votes>1</num_votes></answer><answer id="A2373"><answer_text>Un puntatore si dichiara usando l&#39;operatore asterisco (*), il quale restituisce il contenuto dell&#39;oggetto puntato dal puntatore.
Tradotto in C:

TipoDato *TipoPuntatore  (ES: int *puntatore)</answer_text><num_votes>1</num_votes></answer><answer id="A2400"><answer_text>La dichiarazione di un puntatore ha la seguente forma:
------------------------------------TipoDato *Puntatore--------------------------------
Dove:
1)&#34;TipoDato&#34; definisce verso quale tipo di variabile esso &#34;può puntare&#34;;
2)&#34;Puntatore&#34; è l&#39;identificatore della variabile puntatore;
3)?*? si chiama operatore unario di de-referenziazione.
E? molto importante tenere presente che se un programma definisce un puntatore di 
un determinato tipo e poi lo utilizza per puntare ad un oggetto di un altro tipo, 
si potranno ottenere errori di esecuzione e avvertimenti in fase di compilazione.</answer_text><num_votes>3</num_votes></answer><answer id="A2442"><answer_text>Un puntatore è una variabile che memorizza l&#39;indirizzo di una locazione di memoria, cioè l&#39;indirizzo di una variabile.
Un puntatore deve essere dichiarato come qualsiasi altra variabile, in quanto anch&#39;esso è una variabile. Per esempio: Int *p; la dichiarazione specifica una variabile di tipo: puntatore ad un intero.
L&#39;introduzione del carattere * davanti al nome della variabile indica che si tratta di un puntatore del tipo dichiarato.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2460"><question_text>Quali sono le fasi dello sviluppo di un programma C? In che cosa consistono?</question_text><answer id="A2420"><answer_text>Le fasi di sviluppo di un programma in C sono:
1-EDIT: consiste nella creazione e memorizzazione del codice 
2-PREPROCESS: consiste nella preparazione al processo del codice
3-COMPILATION: consiste nella compilazione, cioè nella creazione dei vari oggetti del codice e                  la loro memorizzazione 
4-LINK: consiste nel collegare gli oggetti del codice alle rispettive librerie  
5-LOAD: consiste nel caricare il codice per eseguirlo in output
6-EXECUTE: consiste nell&#39; esecuzione del codice </answer_text><num_votes>0</num_votes></answer><answer id="A2523"><answer_text>Le fasi dello sviluppo di un programma C sono:Edit,Preprocess,Compilation,Link,Load,Execute. Nell&#39;edit il programma viene creato nell&#39;editor e salvato, nel preprocess vengono inclusi altri file (es: librerie standard) e sostituiti simboli speciali che seguono particolari direttive,nella fase di compilazione viene tradotto il programma in linguaggio macchina,nel Linking si ha la risoluzione dei riferimenti a funzioni e variabili definite altrove (es. librerie standard),nel Loading si ha il caricamento in memoria del codice eseguibile, mentre il programma viene eseguito nella fase di Execute.</answer_text><num_votes>1</num_votes></answer><answer id="A2510"><answer_text>Le fasi di sviluppo di un programma in C sono:
-La fase di Editing,ovvero la scrittura del codice, attraverso l&#39;editor viene creato un programma e memorizzato sull&#39;hard disk;
-La fase di Preprocessing cioè la fase di preelaborazione del codice;
-la fase di Compilazione dove il compilatore crea il codice oggetto e lo memorizza su disco;
-La fase di Collegamento in cui si collega il codice oggetto alle librerie;
-La fase di Caricamento nella quale viene caricato il programma in memoria;
-La fase di Esecuzione,l&#39;ultima fase in cui la CPU preleva ciascuna istruzione dalla memoria e la esegue</answer_text><num_votes>1</num_votes></answer><answer id="A2365"><answer_text>Le fasi dello sviluppo di un programma C sono: Edit, Preprocess, Compilation, Link, Load ed Execute. Nella fase di &#34;Edit&#34; il programma viene creato nell&#39;editor e memorizzato su disco; nella fase &#34;Preprocess&#34; il programma preprocessore elabora il codice, di conseguenza nella fase &#34;Compilation&#34; il compilatore crea il codice oggetto e memorizza sul disco;  nella fase &#34;Link&#34; viene collegato il codice oggetto con le librerie, successivamente in &#34;Load&#34; il programma viene caricato in memoria, ed infine, nella fase &#34;Execute&#34; la CPU prende ogni istruzione e la esegue.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2467"><question_text>Quali sono gli errori più facili da commettere lavorando con le stringhe in C e che risultano 
essere piuttosto insidiosi poiché non vengono rilevati dal compilatore?</question_text><answer id="A2360"><answer_text>L&#39;errore più difficile da individuare è l&#39;omissione del simbolo &#34;&#38;&#34; quando si acquisisce da tastiera tramite scanf. Il compilatore non lo rileva come errore, ma il programma smette di funzionare nel momento in cui lo incontra. Bisogna sempre ricordare che la prima posizione nella stringa corrisponde al valore 0 dell&#39;indice, l&#39;ultima al valore n-1: l&#39;ultimo spazio serve infatti per il simbolo &#34;\0&#34; che indica il termine della stringa. E&#39; facile dimenticare di inserire &#34;\0&#34; alla fine della stringa quando questa viene inizializzata manualmente (ad esempio con un ciclo for o while).</answer_text><num_votes>0</num_votes></answer><answer id="A2504"><answer_text>Uno degli errori più facili da commettere è quello di omettere i doppi apici all&#39;inizio e alla fine della stringa. Omettendoli il programma non darà errore e la memorizzerà come variabile.</answer_text><num_votes>0</num_votes></answer><answer id="A2356"><answer_text>L&#39;errore più difficile da individuare è l&#39;omissione del simbolo &#34;&#38;&#34; quando si acquisisce da tastiera tramite scanf. Il compilatore non lo rileva come errore, ma il programma smette di funzionare nel momento in cui lo incontra. Bisogna sempre ricordare che la prima posizione nella stringa corrisponde al valore 0 dell&#39;indice, l&#39;ultima al valore n-1: l&#39;ultimo spazio serve infatti per il simbolo &#34;\0&#34; che indica il termine della stringa. E&#39; facile dimenticare di inserire &#34;\0&#34; alla fine della stringa quando questa viene inizializzata manualmente (ad esempio con un ciclo for o while).</answer_text><num_votes>0</num_votes></answer><answer id="A2524"><answer_text>Se la stringa è composta da caratteri, non bisogna inserire &#34;&#38;&#34; nel comando scanf.
Non tenere conto che l&#39;ultima posizione di una stringa carattere è occupata da&#34;\o&#34;.
Per le stringhe numeriche composte da N elementi, dimenticarsi che gli elementi nel vettore sono nominati da 0 a N-1.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2533"><question_text>Quale differenza esiste tra l&#39;istruzione condizionale &#34;if&#34; e l&#39;istruzione iterativa (ciclo) &#34;while&#34;?</question_text><answer id="A2497"><answer_text>IF(espressione){istruzione_1;}else{istruzione_2;} esegue l&#39;istruzione un&#39;unica volta solo se, una volta valutata l&#39;espressione, questa risulta vera. Altrimenti, viene eseguita l&#39;istruzione_2, se presente. In mancanza di {}, con IF innestate, la parte else viene abbinata sempre all&#39;ultima IF posta nel blocco. WHILE(espressione){istruzione;} ripete l&#39;istruzione fintanto che l&#39;espressione non risulta falsa.</answer_text><num_votes>1</num_votes></answer><answer id="A2390"><answer_text>If valuta una condizione per la quale, se soddisfatta, svolge un compito assegnato una sola volta mentre while continua a svolgerlo finchè la condizione assegnata non è più vera. Ad esempio se assegniamo la condizione i&#60;10 con i=5 l&#39;istruzione if svolgerà il suo compito una sola volta (o mai se i&#62;10) mentre while continuerà a farlo all&#39;infinito a meno che il valore di i non cambi nel tempo assumendo un valore maggiore di 10 (o come con if non svolgerà nessun compito se i&#62;10 già in partenza).</answer_text><num_votes>0</num_votes></answer><answer id="A2412"><answer_text>Entrambi sono dei costrutti di controllo del flusso di programma, utilizzati per eseguire dei sottoprogrammi solo al verificarsi di determinate condizioni. Il costrutto &#34;if&#34; prevede l&#39;esecuzione del sottoprogramma ad esso associato UNA sola volta e mette a disposizione &#34;una seconda scelta&#34;, ovvero un altro sottoprogramma da eseguire nel caso in cui la condizione dell&#39;&#34;if&#34; non venga rispettata. Il costrutto &#34;while&#34;, invece, implementa un ciclo e quindi consente di eseguire il sottoprogramma associato PIU&#39; VOLTE di seguito, fino a quando la condizione di ingresso al ciclo viene rispettata.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2529"><question_text>Qual&#39;è la differenza tra gli operatori di incremento x++ e ++x? Vale allo stesso modo per i due operatori di decremento x-- e --x?</question_text><answer id="A2430"><answer_text>Considerando x una variabile di tipo intero l&#39;espressione x++ vede l&#39;incremento di x di 1 e la sua denotazione prima dell&#39;incremento, mentre nel caso di ++x si ha sempre l&#39;incremento di 1, ma la denotaziine viene effettuata dopo l&#39;incremento. Per esempio:
x=5;
printf(&#34;%d&#34;, x++); // in questo caso a video verrà stampato il valore di x prima dell&#39;incremento, ossia 5.
//in questo istante x a come valore 6.
printf(&#34;%d&#34;,++x); // stampa a video il valore di x dopo l&#39;incremento, ossia 7 

Analogamente vale per x-- e --x solo che invece dell&#39;incremento di 1 si ha il decremento di un&#39;unita. </answer_text><num_votes>0</num_votes></answer><answer id="A2470"><answer_text>La differenza tra gli operatori di incremento x++ e ++x sta nel valutare il valore di x prima o dopo l&#39;incremento. Lo stesso vale per i due operatori di decremento. 
&#34;x++/x--&#34; significa &#34;valuta x e poi incrementa/decrementa il suo valore&#34;.
&#34;++x/--x&#34; significa &#34;incrementa/decrementa x e poi valutane il valore&#34;.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2415"><question_text>Cos&#39;è e a cosa serve il getchar()?
Come si lega al EOF?</question_text><answer id="A2501"><answer_text>getchar() è una funzione della standard library, che va richiamata quindi con l&#39;#include, e che consente la lettura da Standard Input di un carattere per poi restituirlo come intero.
EOF sta per End Of File, cioè fine del file ed è un valore particolare che viene ritornato dalla funzione getchar() quando viene raggiunta la fine del file, cioè quando non ci sono più dati in input.</answer_text><num_votes>0</num_votes></answer><answer id="A2418"><answer_text>getchar() é un&#39;istruzione che permette di leggere l&#39;input dal buffer.
a=getchar();
legge il carattere nel buffer  e lo assegna alla variabile a. L&#39;EOF (end of file) è un carattere speciale che segna la fine di un input di caratteri, quindi serve al compilatore a controllare quando finisce la fase di input per procedere alla sezione successiva del programma</answer_text><num_votes>0</num_votes></answer><answer id="A2407"><answer_text>La funzione getchar() serve a leggere caratteri da tastiera e salvarli come interi all&#39;interno di una variabile, all&#39;occorrenza stampabili attraverso il comando putchar().
Eof (End of Files) è uno speciale comando (Ctlr+z) definito come un&#39;intero dal file &#39;stdio.h&#39;, quindi non utilizzabile da una variabile di tipo char, ma risulta utile con la funzione getchar() dato che i valori letti vengono salvati come interi.
es:
#include &#60;stdio.h&#62;
/* copia l&#39;input nell&#39;output e termina con ctrl+z*/
main ()
{
     int c;
     while ((c = getchar()) != EOF)
         putchar (c);
}</answer_text><num_votes>1</num_votes></answer></question><question id="Q2481"><question_text>Definizione di un array. In C come si accede ad una precisa cella di un array?</question_text><answer id="A2486"><answer_text>In informatica un array o &#34;vettore&#34; è una struttura dati complessa, statica e omogenea, usata in molti linguaggi di programmazione e chiaramente ispirata alla nozione matematica di vettore, (o di matrice, nel caso di array bidimensionali).L&#39;array è inoltre classificato come un costruttore di tipo: ovvero, esso consente di definire nuovi tipi di dati a partire da (come aggregati di valori di) tipi preesistenti.In C si accede ad una precisa cella array tramite l&#39;indice &#34;i&#34;, es: a[i]. Infine per poterlo utilizzare bisogna dichiararlo, es: int a[10].
</answer_text><num_votes>1</num_votes></answer><answer id="A2409"><answer_text>L&#39;array in C è un meccanismo che permette di costruire tipi di dato i cui elementi sono sequenze omogenee di valori appartenenti ad un unico tipo.
Per accedere ad una cella di tipo array si può fare cosi:
int stringa [12];
stringa [6] punterà al 5 elemento di stringa (se stringa[n] allora punterà a n-1) che avrà un valore intero di tipo int.</answer_text><num_votes>0</num_votes></answer><answer id="A2359"><answer_text>Per accedere ad una precisa cella di un array bisogna specificare il nome che identifica l&#39;array e un numero che è l&#39;indice della cella con la seguente sintassi:
NomeArray [indice];
ricordando che gli indici delle celle partono da zero e possono essere solamente positivi. Nel caso di array bidimensionali, invece, gli indici saranno due:
NomeArray [indiceA] [indiceB];</answer_text><num_votes>0</num_votes></answer></question><question id="Q2485"><question_text>Qual è il numero massimo di celle di un array? Cosa dev&#39;essere sempre incluso in questo tipo di atruttura complessa?</question_text><answer id="A2471"><answer_text>int lista[20];
lista è un array di 20 elementi omogenei ed il tipo di ciascun elemento è int. I 20 elementi sono ordinati e accessibili grazie al valore di un indice che precisa la posizione dell&#39;elemento che si desidera considerare. La variabile che verrà usata come indice per indicare l&#39;elemento dell&#39;array deve essere un tipo integral;l&#39;indice varia tra 0 e il valore racchiuso tra []-1. Un array ha dimensioni fisse, infatti la dimensione dell&#39;array deve essere una costante intera, gli estremi di variabilità degli indici dell&#39;array non possono cambiare durante l&#39;esecuzione del programma.
</answer_text><num_votes>0</num_votes></answer><answer id="A2419"><answer_text>quando viene definito un&#39;array si decide il numero di celle ad esso destinate, ricordando che per i valori numerici la prima cella è dedicata al valore 0 e per quelle di tipo char l&#39;ultima è dedicata al &#34;\0&#34;. una parte fondamentale è l&#39;indice, che consente di individuare le varie celle dell&#39;array.</answer_text><num_votes>0</num_votes></answer><answer id="A2502"><answer_text>Il numero massimo di celle di un array e&#39; indicato dall&#39;utente ed e&#39; definito all&#39;inizio del programma, cio&#39; comporta l&#39;impossibilita&#39; di modificarlo successivamente. Nel caso di un array di caratteri il numero di elementi contenuti e&#39; n+1. In questo tipo di struttura complessa deve essere sempre incluso il carattere speciale null.</answer_text><num_votes>0</num_votes></answer><answer id="A2482"><answer_text>In linea teorica un array può occupare tutta la memoria a disposizione nella RAM, ma per essere funzionale deve contenere un numero limitato di elementi (non sopra i 100). Nel momento stesso della dichiarazione è indispensabile indicare di quante celle sarà composto con un numero o una costante definita prima del main. Bisogna ricordare tuttavia che nel caso di un array di caratteri (stringa) l&#39;ultima cella dovrà essere riservata al carattere NULL &#39;\0&#39; che indica la fine della stringa; inoltre le celle vengono numerate con un indice che parte da 0 e non da 1.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2433"><question_text>Perchè il linguaggio C, nonostante sia stato inventato decine di anni fa è ancora in completo utilizzo, almeno in alcuni campi?</question_text><answer id="A2473"><answer_text>Il linguaggio C viene ancora utilizzato perché  efficace e molto efficiente. Ha un livello medio di 
astrazione per questo è possibile gestire la memoria in maniera diretta. Rientra nei linguaggi compilativi (di tipo strong typing) ed è stato utilizzato per lo sviluppo dei sistemi operativi moderni ed è inoltre portabile da una macchina reale all&#39;altra. Il linguaggio C è stato implementato con il C++che offre delle librerie più ampie e una programmazione ad oggetti. Inoltre è preferito ad altri , nell&#39;industria e nell&#39;accademia, per la possibilità di realizzare progetti complessi .</answer_text><num_votes>1</num_votes></answer><answer id="A2509"><answer_text>Il linguaggio C è ancora molto utilizzato perché è un linguaggio flessibile e vicino alla macchina, usato per sviluppare UNIX e anche sistemi operativi più moderni come Windows e Mac OS X.
Una caratteristica molto importante del linguaggio C è la sua indipendenza dall&#39;Hardware, cioè i codici sono portabili da una macchina reale ad un&#39;altra.</answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L31" title="Istruzioni Condizionali, Array" date="2013-10-11"><question id="Q2702"><question_text>Per quale motivo non si può operare l&#39; assegnazione tra array?( Ad esempio se si hanno due array di interi x e y, non si può scrivere x=y)</question_text><answer id="A2633"><answer_text>Non si può operare l&#39;assegnazione tra array, cioè dati due array a e b, è errore scrivere a=b, poiché un array è una sequenza di celle consecutive ed omogenee. Per ottenere due array uguali bisogna eseguire un ciclo for, in grado di assegnare uno ad uno gli elementi dell&#39;array. Ad esempio dati a[dim], b[dim],i dovrò scrivere:

int a[dim]; int b[dim]; int i;

for(i=0;i&#60;dim;i++){
     b[i]=a[i];
}

In questo modo ottengo due vettori uguali in ogni elemento.</answer_text><num_votes>1</num_votes></answer><answer id="A2580"><answer_text>Un array corrisponde a un blocco di memoria composto da tante locazioni quanto la lunghezza dell&#39;array. Per questo motivo si può accedere solo a singoli elementi di un array utilizzando un indice che corrisponde alla posizione della cella di memoria dell&#39;array stesso. Per copiare l&#39;intero contenuto di un array in un altro è necessario utilizzare un ciclo (per esempio un ciclo for) in cui si individua ogni valore tramite l&#39;indice del ciclo stesso.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2744"><question_text>Perche&#39; la prima scrittura risulta migliore rispetto alla seconda nonostante il risultato sia lo stesso?
1. if        (a&#62;b) printf(&#34;a maggiore di b \n&#34;);
    else if (a&#60;b) printf(&#34;b maggiore di a \n&#34;);
    else  printf(&#34;a uguale a b \n&#34;);

2. if  (a&#62;b)  printf(&#34;a maggiore di b \n&#34;);
    if  (a&#60;b)  printf(&#34;b maggiore di a \n&#34;);
    if (a==b) printf(&#34;a uguale a b \n&#34;);

</question_text><answer id="A2694"><answer_text>La prima &#34;scrittura&#34; è preferibile alla seconda perché utilizza if-else nidificati che, con un opportuno utilizzo di parentesi, permette di ottenere una &#34;scrittura&#34; più semplice e leggibile a parità di risultato.</answer_text><num_votes>1</num_votes></answer><answer id="A2636"><answer_text>La prima è migliore perchè rende il codice più leggibile e capibile dal lettore, questo perchè in un if-else si ha un&#39;unica istruzione (if-else) di cui la seconda istruzione(else) non serve che sia composta cioè che abbia anch&#39;essa una condizione perchè entra in gioco quando la condizione nel if è falsa. Quindi il primo caso semplifica di molto il programma.</answer_text><num_votes>1</num_votes></answer><answer id="A2610"><answer_text>Perché nella seconda scrittura in ogni caso vengono valutate tutte e tre le condizioni in ogni caso, mentre nel primo se è vera la prima le altre non vengono valutate. Se è vera la seconda vengono valutate le prime due e solo se è vera l&#39;ultima vengono valutate tutte.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2611"><question_text>Che differenza c&#39;è nell&#39; incolonnare più istruzioni condizionali in sequenza e comporre più istruzioni condizionali nidificate?</question_text><answer id="A2639"><answer_text>comporre le istruzioni condizionali nidificate è meno leggibile da parte dell&#39;operatore, ma ha una struttura che viene elaborata ed eseguita più velocemente. un&#39;istruzione nidificate è per esempio:
 if (...) {
...}
else if(...) {
...}
un&#39;istruzione condizionale incolonnata è invece di struttura più leggibile (e quindi più semplice da scrivere e da ispezionare manualmente), ma più lenta nell&#39;esecuzione.
un esempio di struttura incolonnata è:
if (...) {...}
if (...) {...}

</answer_text><num_votes>3</num_votes></answer><answer id="A2565"><answer_text>Nel primo caso bisogna stare attenti che non vengano introdotte variabili o altre istruzioni che potrebbero modificare il significato delle istruzioni condizionali, nella seconda opzione si prevede meno dispersione di istruzioni e quindi meno possibilità di errori, inoltre se si manifesta un errore, la ricerca di questo risulta più semplice ed immediata.</answer_text><num_votes>1</num_votes></answer><answer id="A2622"><answer_text>Un&#39;istruzione condizionale consente di eseguire due diverse sequenze di istruzioni sulla base del valore di verità di una condizione. E&#39; costituita da IF, seguito dal blocco di istruzioni per il caso vero, e da ELSE, per il caso falso (che può mancare).
Se si hanno più istruzioni INCOLONNATE, allora si avra&#39; un if seguito dal suo else, ecc.
Se invece si hanno delle istruzioni NIDIFICATE, allora prima del ramo else della prima istruzione poniamo un&#39;altra istruzione condizionale.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2618"><question_text>Cosa succede quando si cerca di inserire più dati di quanto possa contenere un array(Cos&#39;è l&#39;overflow)?</question_text><answer id="A2671"><answer_text>Se inserisco un numero maggiore di dati rispetto al numero di celle contenute nell&#39;array, cioè sto andando a scrivere in zone della memoria al di fuori dell&#39;array, i dati verranno semplicemente persi. Siccome le celle dove sono stati scritti i dati, non sono accessibili. Questo è molto pericoloso siccome è possibile andare a modificare involontariamente altre celle di memoria (cosa da evitare!). Questo tipo di errore viene usualmente commesso quando si pensa che la prima cella dell&#39;array ha indice 1, in realtà la prima cella ha indice 0!!!!!  </answer_text><num_votes>2</num_votes></answer><answer id="A2741"><answer_text>Spesso per non &#34;sprecare&#34; celle di memoria vengono usati array di dimensioni contenute, oppure ci si dimentica che l&#39;ultima cella utilizzabile di un array di n elementi è quella in posizione n-1 e può accadere che vengano inseriti più dati di quanti un array possa contenere. In questo caso il compilatore non trovando una quantità di celle necessaria dove poter immagazzinare tutti i dati rischia di perdere dati e/o modificare altre celle di memoria compromettendo la memoria del calcolatore stesso. Molte volte i calcolatori che si trovano in questa situazione bloccano l&#39;esecuzione del programma.</answer_text><num_votes>1</num_votes></answer><answer id="A2703"><answer_text>Quando l?array è dichiarato, il compilatore alloca un blocco di memoria per contenere l?array;se C è un vettore di n elementi il primo elemento è alla posizione 0 e l&#39;ultimo alla posizione n-1.Il C non effettua alcun controllo sui limiti degli array. In altre parole è possibile inizializzare un array di dimensione N con più di N valori senza avere alcun messaggio di errore in compilazione; È compito del programmatore garantire che tutti gli array siano abbastanza grandi da contenere ciò per cui  sono stati creati
</answer_text><num_votes>0</num_votes></answer><answer id="A2729"><answer_text>I dati verranno scritti nelle celle di memoria seguenti, le quali non essendo state riservate per l&#39;array potrebero contenere dati di altre variabili, provocando dei risultati inaspettati.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2670"><question_text>Cosa caratterizza un array di caratteri?</question_text><answer id="A2588"><answer_text>Un array di N caratteri può ben essere usato per
memorizzare stringhe più corte. In questo caso, le celle oltre la k-esima (k essendo la lunghezza della stringa) sono concettualmente vuote: 
praticamente sono inutilizzate e contengono un valore casuale.
Un array di tipo carattere deve essere sempre racchiuso tra virgolette semplici, ad esempio: ?a?.
Oltre agli array di numeri interi o reali, possiamo definire anche gli array di caratteri; per esempio:
char s[]={&#39;c&#39;, &#39;i&#39;, &#39;a&#39;,&#39;o&#39;}
dove s è un array di caratteri formato da 4 elementi:
s[0]=&#39;c&#39;; s[1]=&#39;i&#39;; s[2]=&#39;a&#39;; s[3]=&#39;o&#39;;
</answer_text><num_votes>0</num_votes></answer><answer id="A2630"><answer_text>Un array di caratteri (char) puo&#39; essere utilizzato per rappresentare stringhe, cioe&#39; successioni di caratteri, come ad es. &#34;world&#34;; questo tipo di array e&#39; caratterizzato dall&#39;esistenza di un vincolo consistente nel fatto che l&#39;ultima posizione dell&#39;array deve contenere il valore speciale NULL (&#34;\0&#34;). Tale valore serve a varie funzioni che manipolano stringhe a capire dove finisce la stringa. Quindi il numero di caratteri necessari per memorizzare una stringa di n caratteri e&#39; n+1; ad es. per memorizzare la stringa &#34;world&#34; (5 caratteri) si deve inizializzare un array di 6 caratteri (5+null). </answer_text><num_votes>1</num_votes></answer><answer id="A2587"><answer_text>Un array di N caratteri può ben essere usato per
memorizzare stringhe più corte. In questo caso, le celle oltre la k-esima (k essendo la lunghezza della stringa) sono concettualmente vuote: 
praticamente sono inutilizzate e contengono un valore casuale.
Un array di tipo carattere deve essere sempre racchiuso tra virgolette semplici, ad esempio: ?a?.
Oltre agli array di numeri interi o reali, possiamo definire anche gli array di caratteri; per esempio:
char s[]={&#39;c&#39;, &#39;i&#39;, &#39;a&#39;,&#39;o&#39;}
dove s è un array di caratteri formato da 4 elementi:
s[0]=&#39;c&#39;; s[1]=&#39;i&#39;; s[2]=&#39;a&#39;; s[3]=&#39;o&#39;;
</answer_text><num_votes>0</num_votes></answer></question><question id="Q2729"><question_text>Un unico array può contenere variabili di tipo diverso (int, float, char ecc...)? perchè?</question_text><answer id="A2625"><answer_text>Un unico Array non può contenere variabili di tipo diverso, perché altrimenti non sarebbe un Array e non avrebbe un funzionamento corretto. Dalla definizione sappiamo che un Array è una variabile strutturata contenente un insieme di valori tutti dello stesso tipo (omogenei), individuata da un unico nome collettivo (identificatore); e quindi se utilizziamo una variabile int non possiamo utilizzare una variabile di tipo char.</answer_text><num_votes>1</num_votes></answer><answer id="A2606"><answer_text>No; un array in C per definizione é un insieme di più dati omogeneo quindi un insieme di dati dello stesso tipo. Infatti nella definizione di un array in questo linguaggio di programmazione  [per esempio &#34;int array[N]&#34;] si necessita in primis di scrivere l&#39;UNICO tipo di dato che l&#39;array può contenere. Ovviamente è possibile fare array di tutti i tipi di dati base e non; anche di quelli &#34;creati&#34; dal programmatore, i quali loro volta invece possono essere non omogenei e contenere dati di tipo differente (vedi typedef). L&#39;array in se resta comunque omogeno perchè a[0],a[1], ecc sono tutti uguali.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2673"><question_text>Nelle valutazioni di espressioni, cosa si intende con &#34;associatività&#34;? E in quale caso il suo utilizzo diventa fondamentale?</question_text><answer id="A2740"><answer_text>Se per associatività si intende valutare più espressioni con gli operatori boleani, ovvero casi differenti, come ad esempio valutare se un numero è compreso in un intervallo.
 </answer_text><num_votes>0</num_votes></answer><answer id="A2627"><answer_text>Per associatività si intende in che direzione bisogna valutare un operatore(da destra a sinistra o da sinistra a destra).
Questo diventa importante quando bisogna valutare un&#39;espressione contenente diversi operatori(+,&#38;,!,++,etc...).
Per esempio l&#39;operatore di assegnamento(=) è right-associative cioè assegna il valore dell&#39;espressione alla sua destra a quello che c&#39;è alla sua sinistra(right to left).
Altri operatori invece sono left-associative (left to right) come gli operatori +,&#62;,||, quindi la loro valutazione si effettuerà partendo da sinistra.
</answer_text><num_votes>0</num_votes></answer><answer id="A2648"><answer_text>Il linguaggio C definisce:
- una precedenza degli operatori, per la quale certi operatori hanno maggiore priorità di   altri; 
- associatività, ovvero un ordine in cui operatori diversi, aventi la stessa priorità, vengono associati.
Il suo utilizzo diventa fondamentale nel caso in cui non venga modificato l&#39;ordine della valutazione dell&#39;espressione, attraverso l&#39;utilizzo di parentesi.</answer_text><num_votes>0</num_votes></answer><answer id="A2693"><answer_text>L&#39;associatività definisce il verso con cui il compilatore valuta le espressioni, cioè da sinistra a destra oppure da destra a sinistra. Diventa fondamentale l&#39;utilizzo quando in un&#39;espressione sono presenti operatori dello stesso gruppo di precedenza, in modo da sapere in quale ordine le operazioni verranno svolte. 
Esempio: a+b-2 ; l&#39;espressione viene eseguita da sinistra verso destra, quindi (a+b) e successivamente al risultato viene sottratto 2.</answer_text><num_votes>2</num_votes></answer><answer id="A2553"><answer_text>Per associatività si intende la procedura che assegna il verso di valutazione di un espressione (da sinistra o da destra). Diventa fondamentale quando devo valutare operatori dello stesso gruppo.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2668"><question_text>Quando ha luogo un errore di segmentazione? Può verificarsi in linguaggio C?</question_text><answer id="A2637"><answer_text>L&#39;errore di segmentazione ha luogo quando un programma tenta di accedere ad una posizione di memoria alla quale non gli è permesso accedere, oppure tenta di accedervi in una maniera impropria. Questo errore si verifica spesso nel linguaggio C; per esempio quando ci riferiamo a un puntatore in maniera errata:
char *s=&#34;stringa&#34;;/*puntatore ad una stringa posizionata nel segmento di sola lettura dell&#39;eseguibile, quando si esegue il programma di solito il S.O. la mappa in una zona di sola lettura, impedendone la modifica*/
*s=&#39;a&#39;;/*tenta di scrivere nella memoria di sola lettura e causa errore*/</answer_text><num_votes>3</num_votes></answer><answer id="A2726"><answer_text>Un errore di segmentazione ha luogo quando un programma tenta di accedere ad una posizione di memoria alla quale non gli è permesso di accedere,questo può accadere spesso nel caso degli array e per tanto l&#39;errore può verificarsi in C.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2765"><question_text>E&#39; possibile modificare la grandezza di un array in un secondo momento, dopo averlo dichiarato?</question_text><answer id="A2666"><answer_text>Nel linguaggio C non è possibile modificare la dimensione di un array dopo averlo dichiarato, poichè la macchina gli deve riservare fisicamente uno spazio preciso di memoria.
Questo però non va confuso con l&#39;allocazione dinamica della memoria, dove comunque la dimensione dell&#39;array viene determinata solo in fase di esecuzione. </answer_text><num_votes>4</num_votes></answer><answer id="A2561"><answer_text>no, non è possibile modificare la grandezza di un&#39;array, sebbene esistono array dinamici in cui la lunghezza dell&#39;array stesso è definita da un&#39;espressione o una variabile, che ci consentono di bypassare il problema se inizialmente non conosciamo la grandezza che deve avere l&#39;array</answer_text><num_votes>1</num_votes></answer></question><question id="Q2612"><question_text>L&#39;istruzione:
     int a [3] = {1, 2}; 
Provoca un errore? Che valori sono contenuti in a[0] a[1]  e  a[2]? </question_text><answer id="A2730"><answer_text>No, l&#39;istruzione è corretta e verrà eseguita senza errori. Tuttavia con essa viene dichiarato un array di 3 elementi, di cui solo i primi due sono inizializzati. Per questo motivo, mentre a[0] sarà = 1 e a[1] = 2, in a[3] rimarrà un valore apparentemente casuale, ovvero quello contenuto nella cella di memoria dedicata a tale variabile.</answer_text><num_votes>2</num_votes></answer><answer id="A2555"><answer_text>Questa istruzione non provoca un errore. Nei primi due elementi dell&#39;array sono assegnati gli elementi compresi tra le parentesi graffe, mentre il terzo elemento non è assegnato ed è un valore qualsiasi che era già contenuto all&#39;interno della cella di memoria allocata per questo elemento.</answer_text><num_votes>1</num_votes></answer><answer id="A2683"><answer_text>Questa istruzione non provoca un errore in quanto semplicemente si assegnano 2 valori a un array di 3 valori, cio&#39; significa a[3] non e&#39; stato inizializzato.
Infatti a[0]=1, a[1]=2 e a[2] avra&#39; un valore casuale in quanto e&#39; una locazione di memoria non ancora inizializzata</answer_text><num_votes>0</num_votes></answer></question><question id="Q2626"><question_text>Spiegare la differenza tra il costrutto &#34;if&#34; e il costrutto &#34;if-else&#34;.</question_text><answer id="A2692"><answer_text>Il costrutto &#34;if&#34; viene utilizzato nella situazione in cui è necessario verificare se una condizione è vera. Il costrutto &#34;if-else&#34; invece, permette di verificare se una condizione è vera e nel caso in cui sia falsa, eseguire un altro blocco di istruzioni.</answer_text><num_votes>5</num_votes></answer><answer id="A2581"><answer_text>Il costrutto if da la possibilita&#39; di controllare una sola condizione invece il costrutto if-else da la possibilita di verificare due condizioni.
Nell&#39;if-else al verificarsi della condizione postagli si andra&#39; ad eseguire come un normale if, invece al non verificarsi di essa si andra&#39; ad eseguire il codice oltre il nostro else permettendoci anche di implementare degli altri if-else nidificati in esso, in modo tale da riuscire a ricoprire n condizioni.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2782"><question_text>In che modo si può incrementare la precedenza all&#39;interno di un&#39;espressione?</question_text><answer id="A2597"><answer_text>Non ha senso parlare di &#34;incremento&#34; della precedenza, in un espressione, si può però modificare il naturale ordine di precedenza degli operatori con l&#39;uso delle parentesi. </answer_text><num_votes>1</num_votes></answer><answer id="A2680"><answer_text>si può incrementare la precedenza all&#39;interno di un&#39;espressione utilizzando l&#39;operatore &#34;+&#34; appartenete al gruppo degli additivi.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2784"><question_text>Come vengono valutate le espressioni? Se ci sono operatori di uno stesso tipo come ci si comporta?</question_text><answer id="A2706"><answer_text>Le espressioni vengono valutate come le valuta la matematica; Esistono precedenze e queste possono essere modificate tramite l&#39;utilizzo delle(). Quando ci sono operatori di uno stesso si tratta di &#34;operatori di incremento e decremento&#34;:essi rispettivamente aumentano o diminuiscono di uno l&#39;unico operando che prendono. Sono rappresentati con ++ e --; questi possono essere utilizzati prima, o dopo la variabile(A=--x, A=x--) e rispettivamente significa che: x viene decrementata prima che il suo valore venga copiato in A, viene prima copiato in A il valore di x e poi viene incrementato il valore X</answer_text><num_votes>0</num_votes></answer><answer id="A2710"><answer_text>Le espressioni vengono valutate in base all&#39;ordine di precedenza: gli operatori sono suddivisi in gruppi caratterizzati da precedenze, quindi vengono valutati prima quelli con precedenza superiore e successivamente quelli con precedenza inferiore.
Nel caso di operatori appartenenti allo stesso gruppo di precedenza viene utilizzata la proprietà associativa per determinare il verso di valutazione (da destra o da sinistra). L&#39;ordine di precedenza può essere modificato utilizzando le parentesi ( ) che sono usate anche per aumentare la leggibilità delle espressioni.</answer_text><num_votes>2</num_votes></answer><answer id="A2620"><answer_text>Tutti gli operatori che si possono trovare in un&#39;espressione sono suddivisi in gruppi caratterizzati da precedenze. Quelli con precedenza superiore vengono valutati prima di quelli con precedenza inferiore. In caso di operatori dello stesso gruppo di precedenza viene utilizzata l&#39; &#34;associatività&#34;, che determina il verso di valutazione (da destra o da sinistra). Cioè viene data più importanza, a seconda del gruppo, all&#39;operatore che sta più a destra o a sinistra.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2629"><question_text>Qual è la differenza tra un array ed una matrice? </question_text><answer id="A2566"><answer_text>Una matrice è un sottocaso di un array; un array è un vettore che può avere più di una dimensione; un array di 2 dimensioni corrisponde proprio ad una matrice.</answer_text><num_votes>0</num_votes></answer><answer id="A2568"><answer_text>La differenza sta che un array è una struttura dati complessa monodimensionale e invece la matrice è un &#34;array di un array&#34;, cioè una struttura dati bidimensionale.</answer_text><num_votes>0</num_votes></answer><answer id="A2614"><answer_text>Un array è una struttura dati formata da una sequenza di celle consecutive ed omogenee, contenenti cioè variabili (una per cella) dello stesso tipo.
La matrice è semplicemente un array multidimensionale (soprattutto bidimensionale), in riferimento alla nozione matematica di matrice. 
La differenza sta nel fatto che una matrice ha due (o più) indici (ogni indice è una dimensione) e ogni elemento è identificato dalla combinazione di valori di tutti gli indici del vettore.</answer_text><num_votes>4</num_votes></answer></question><question id="Q2658"><question_text>Elencare i modi con cui è possibile inizializzare un array.</question_text><answer id="A2646"><answer_text>Un array può essere inizializzato in fase di dichiarazione nel seguente modo (nell&#39;esempio di un array di interi):
int array[5]={1,-4,6,5,0};
Un altro modo per fare ciò consiste nell&#39;utilizzare un ciclo for, oppure while, e magari anche la funzione rand() per associare ai vari elementi costituenti l&#39;array un numero casuale:
int i;
srand(time(0));
for (i=0;i&#60;5;i++){
  array[i]=rand();
}
  </answer_text><num_votes>1</num_votes></answer><answer id="A2679"><answer_text>Un array può essere inizializzato in due modi: esplicitamente durante la sua creazione tramite le costanti di inizializzazione dei dati, oppure durante l&#39;esecuzione del programma tramite assegnazione o inserimento di dati all&#39;interno dell&#39;array stesso.</answer_text><num_votes>0</num_votes></answer><answer id="A2684"><answer_text>Inizializzare un array significa assegnare a ciascun suo elemento un valore. Tale operazione è effettuabile nel momento in cui l&#39;array viene dichiarato, ad esempio tramite l&#39;istruzione: &#39;&#39; int array[4] = {3,9,1,7} &#39;&#39;. 
Oppure è effettuabile all&#39;interno del programma tramite l&#39;ausilio di un ciclo come il while o il for. Un esempio è : 

int array [6];
Int i;
for(i=0; i&#60;6; i++) {
   Array[i] = rand()%(MAX-min+1)+min
}  
Questo esempio assegna un valore casuale, compreso tra un valore massimo (MAX)  e uno minimo (min), ad ogni elemento dell&#39;array. 
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2637"><question_text>Cosa si intende per Array Multidimensionali?
</question_text><answer id="A2711"><answer_text>In ambiente C si deve prima di tutto pensare che un array a due dimensioni e&#39; un array monodimensionale i cui elementi sono  a loro volta degli array. Premesso ciò, gli array multimensionali si possono utilizzare per costruire matrici e griglie. Ad esempio a[2][3] definisce un array bidimensionale 2x3 che viene organizzato come un rettangolo:
a[0][0]  a[0][1]  a[0][2]
a[1][0]  a[1][1]  a[1][2]
Viene utile ricordare che C conserva N celle per le righe ma comunque la numerazione va da 0 a N-1.</answer_text><num_votes>0</num_votes></answer><answer id="A2600"><answer_text>Un array multidimensionale è un array di qualsiasi numero di dimensioni ed è da intendersi come un array di array. 
Sono molto utili per creare matrici. Per esempio un array del tipo:

int matrice[N][M] (con N e M costanti)

rappresenta un array multidimensionale (bidimensionale) che identifica una matrice ( di interi) di N righe e M colonne.</answer_text><num_votes>0</num_votes></answer><answer id="A2546"><answer_text>In C si possono definire array bidimensionali: int a[N][M]
Che corrisponde ad una matrice con 10 righe e 5 colonne,è possibile anche usare array a tre o più dimensioni aggiungendo una coppia o più di parentesi quadre :
 float a[10][5][20].Il calcolatore comunque memorizza tutto in modo lineare,una dopo l&#39;altra.
</answer_text><num_votes>0</num_votes></answer><answer id="A2659"><answer_text>Gli Array Multidimensionali(ò n-dimensionali) in pratica sono array contenenti n-elementi che a loro volta si presentano sottoforma di altri array. In C in questo modo si possono rappresentare facilmente matrici e tabelle i cui elementi appartengono tutti allo stesso tipo:
int NomeArray[i][j]
Inoltre per passare un array multidimensionale a una funzione basta indicare il numero delle colonne dato che i suoi elementi sono memorizzati nella RAM riga per riga:
int f(int a[][35]){..}
Pertanto  per l&#39;eccessiva memoria richiesta si sconsiglia l&#39;utilizzo di array con più di 3 indici(ò dimensioni)</answer_text><num_votes>2</num_votes></answer></question><question id="Q2783"><question_text>Scrivi un&#39;espressione che permetta di ottenere il numero di righe di un array multidimensionale utilizzando la funzione sizeof().</question_text><answer id="A2674"><answer_text>#define DIM 20

int main()
{
  int ar[DIM][DIM][DIM];
  int righe;
  
  righe=sizeof(ar)/sizeof(ar[0]); //N°celle allocate per l&#39;intero array/n°celle allocate per una riga
  
  printf(&#34;Nr righe=%d\n&#34;,righe);
  
  system(&#34;PAUSE&#34;);	
  return 0;
}</answer_text><num_votes>2</num_votes></answer><answer id="A2708"><answer_text>La funzione sizeof() serve per conoscere la lunghezza di un&#39;array statico, quindi è possibile ricavare la dimensione di un&#39;array multidimensionale (conosciuto come matrice; ad esempio: matt [] []) indicando nella funzione una riga specifica.
Ad esempio: righe = sizeof(matt []) / sizeof(matt[] [0]);</answer_text><num_votes>3</num_votes></answer><answer id="A2658"><answer_text>int a[17];
int n = sizeof(a);

Essendo un int lungo 4 byte n sarà uguale a 68.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2675"><question_text>Che cosa si intende per &#34;condizione&#34; (o &#34;espressione booleana&#34;) e da cosa è costituita?</question_text><answer id="A2650"><answer_text>Un&#39;espressione Booleana è un&#39;espressione che può avere come risultato soltanto Vero o Falso.
Essa è composta da proposizioni (Vere o False) alle quali si applicano le operazioni logiche AND, OR e NOT. Nell&#39;espressione, dopo aver risolto le parentesi, il NOT ha la precedenza su AND e su OR, AND ha la precedenza su OR.
</answer_text><num_votes>0</num_votes></answer><answer id="A2641"><answer_text>Per &#34;Condizione&#34; si intende il fattore fondamentale che determina il funzionamento di costrutti quali: if-else, while, for ecc...  La condizione è solitamente composta da variabili, costanti e operatori del tipo: &#60;=, ==, &#62;= ecc...
Se la condizione (Es: A == B) viene soddisfatta, solitamente il programma passa all&#39;istruzione successiva, altrimenti ripete il ciclo o salta una linea di codice.   </answer_text><num_votes>0</num_votes></answer><answer id="A2736"><answer_text>Un?espressione booleana è un?espressione che opera solo con i valori binari 0 e 1 (rispettivamente FALSO e VERO). Gli operatori che vengono utilizzati nell?algebra di Boole sono NOT (operatore unario), AND e OR (operatori binari); questi tre operatori nell?ambito di un linguaggio di programmazione si traducono con i caratteri ! (NOT), &#38;&#38; (AND), || (OR). Gli operatori seguono un preciso ordine di precedenza e godono delle proprietà commutativa, associativa e distributiva nonchè di idempotenza (A+A=A) e elemento neutro (A+0=A); si avvalgono inoltre delle leggi di De Morgan. </answer_text><num_votes>5</num_votes></answer><answer id="A2567"><answer_text>Un&#39;espressione booleana è un espressione che restituisce come valore solo vero o falso (1 o 0 , si o no ecc.).</answer_text><num_votes>0</num_votes></answer><answer id="A2612"><answer_text>Un espressione booleana è un tipo di espressione che può restituire solo due valori, vero(1) o falso(0), sul verificarsi o meno di una data condizione.
Essa è costituita da una condizione, da una verifica e da un risultato.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2715"><question_text>Una volta definito un&#39; Array, è possibile variarne la dimensione? Se si come?
</question_text><answer id="A2634"><answer_text>Si, è possibile variare la dimensione di un array dopo averlo definito. Per fare ciò è necessario definire un array tramite una variabile puntatore. In questo modo è possibile variare la dimensione dell&#39;array durante il programma semplicemente gestendo il puntatore assegnato all&#39;array.</answer_text><num_votes>1</num_votes></answer><answer id="A2602"><answer_text>L&#39;array deve trovare spazio in memoria a tempo di esecuzione e non di compilazione, spazio di una dimensione anch?essa nota solo durante l&#39;esecuzione, quindi si può modificare l&#39;indice dell&#39;array dichiarato inizialmente .Basta sostituire il nuovo valore d&#39;array nelle parentesi quadrate .
</answer_text><num_votes>1</num_votes></answer><answer id="A2731"><answer_text>Sì è possibile, ma è necessario definire l&#39;array dichiarando un puntatore al suo primo elemento, ed esprimerne la dimensione con la funzione &#34;malloc()&#34;,ad esempio:
int *v;
v=malloc(10*sizeof(int));
il compilatore riserverà uno spazio in memoria atto a contenere un array di 10 elementi interi a partire dall&#39; indice puntato da &#34;v&#34;. Per variarne la dimensione è necessario &#34;riallocarlo&#34;, ovvero spostarlo in un altra zona della memoria con spazio sufficiente a contenerlo (se restasse dov&#39;è e scrivessi sulle celle sucessive sporcherei la memoria), quindi:
v=realloc(v,20*sizeof(int));
(+10 elem)</answer_text><num_votes>2</num_votes></answer><answer id="A2744"><answer_text>Normalmente la dimensione degli array è definita tramite una costante e la memoria viene allocata durante la fase di compilazione.
Utilizzando i puntatori e la funzione malloc(), però, è possibile creare vettori le cui dimensioni possono essere definite in fase di esecuzione
In particolare se al puntatore si assegna ad un puntatore il valore
malloc(x*sizeof(type));
con x=numero di elementi (definito in input) e type=tipo degli elementi
Quel puntatore sarà effettivamente un vettore di x elementi di tipo &#34;type&#34;, con x definito in fase di esecuzione</answer_text><num_votes>0</num_votes></answer><answer id="A2653"><answer_text>Una volta definito un array, è sempre possibile modificarne la dimensione, che deve essere una costante intera, maggiore di zero, racchiusa all&#39;interno di una coppia di parentesi quadre, scritte immediatamente a destra dell&#39;identificatore dell&#39;array. Infatti, al momento della dichiarazione di tale array, per variarne la dimensione basta semplicemente modificare il valore della costante racchiusa tra parentesi quadre; per esempio, un array di 20 elementi, array[20], ridurrà la propria dimensione a 10 elementi, se troverò scritto array[10].</answer_text><num_votes>0</num_votes></answer></question><question id="Q2671"><question_text>esiste un numero massimo di celle in un array?</question_text><answer id="A2675"><answer_text>Si, poichè la memoria non è illimitata.</answer_text><num_votes>0</num_votes></answer><answer id="A2691"><answer_text>In C non esiste un numero massimo di celle in un array, in quanto si può continuare a 
rendere sempre più grande ed esteso il proprio array, continuando ad allocare memoria; 
quindi se avessimo memoria infinita avremmo un infinito numero di celle in un array. </answer_text><num_votes>3</num_votes></answer><answer id="A2645"><answer_text>Esiste un numero massimo di celle in un erray e dipende dalle dimensioni della RAM.</answer_text><num_votes>0</num_votes></answer><answer id="A2643"><answer_text>Esiste un numero massimo di celle in un erray e dipende dalle dimensioni della RAM.</answer_text><num_votes>1</num_votes></answer><answer id="A2644"><answer_text>Esiste un numero massimo di celle in un erray e dipende dalle dimensioni della RAM.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2625"><question_text>Il linguaggio di programmazione in C è &#34;case sensitive&#34;? Cosa si intende per &#34;case sensitive&#34;?</question_text><answer id="A2662"><answer_text>Significa semplicemente che distingue tra lettere maiuscole e minuscole:
int x;
int X;
si può fare, perchè x e X sono due variabili distinte!</answer_text><num_votes>0</num_votes></answer><answer id="A2608"><answer_text>Si dice case sensitive ogni operazione di analisi del testo che distingua due parole uguali in base all&#39;uso di lettere maiuscole o minuscole.
Quindi il linguaggio C riesce ad identificare diversamente lettere maiuscole e minuscole. Questo risulta importante, ad esempio, nel caso delle password, rese sensibili affinché sia più difficile risalirvi per tentativi</answer_text><num_votes>1</num_votes></answer><answer id="A2584"><answer_text>Il linguaggio C è &#34;case sensitive&#34;, cioè vengono distinti i caratteri maiuscoli da quelli minuscoli. Di conseguenza le parole con caratteri minuscoli (o rispettivamente maiuscoli) avranno un significato differente da quelle con anche un solo carattere maiuscolo ( o rispettivamente minuscoli), pur avendo le medesime lettere. </answer_text><num_votes>0</num_votes></answer><answer id="A2558"><answer_text>Si intende che il linguaggio è in grado di riconoscere le maiuscole dalle minuscole.
Perciò 2 variabili inizializzate con lo stesso nome ma una in maiuscolo e l&#39;altra in minuscolo saranno diverse e quindi occuperanno porzioni di memoria differenti.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2698"><question_text>quando è possibile utilizzare il comando switch() al posto di una sequenza di if()?</question_text><answer id="A2695"><answer_text>L&#39;istruzione if() è costruita per scegliere l&#39;esecuzione di un&#39;istruzione in alternativa a un&#39;altra a seconda del valore di una certa condizione. In molti casi però le alternative tra cui scegliere possono essere molteplici e per ognuno dei possibili caratteri a volte devono essere eseguite azioni diverse. Trattare casi del genere con il costrutto if() può risultare tedioso e innaturale. Per questo viene utilizzato il comando switch(), una struttura di controllo di tipo selettivo.</answer_text><num_votes>1</num_votes></answer><answer id="A2678"><answer_text>Quando lavoriamo sul valore un&#39;unica variabile possiamo sostituire if() con switch(). Infatti scrivere 
if(a=3){printf(&#34;a=3&#34;);}; 
else if (a=4){printf(&#34;a=4&#34;)}; 
In qiesto caso si eseguono le istruzioni specificate a seconda del valore della variabile, la cosa avrebbe più senso con, ad esempio, un vero o falso. 
Il blocco if è equivalente al seguente
switch(a){
case 3: printf(&#34;a=3&#34;); 
case 4: printf(&#34;a=4&#34;);
break;}. 
In questo caso avevamo solo due possibilità, ma lo switch può risultare comodo quando il numero il numero di casi aumenta.
</answer_text><num_votes>0</num_votes></answer><answer id="A2560"><answer_text>Il comando SWITCH viene utilizzato quando si ha un ristretto range di possibili soluzioni. Mentre nel IF si verifica una condizione se è vera o falsa, nello SWITCH si valuta la condizione e in funzione del risultato ottenuto vengono eseguite determinate istruzioni rispetto ad altre. Lo SWITCH inoltre contiene il comando BREAK, inseribile alla fine di un blocco di istruzioni. Se utilizzato fa avanzare alle operazioni successive, altrimenti torna a valutare in che caso si è dei possibili impostati per lo SWITCH. Oltre ai casi per lo switch si può inserire il comando  DEFAULT che ingloba il resto</answer_text><num_votes>0</num_votes></answer><answer id="A2737"><answer_text>L&#39;utilizzo del costrutto &#34;switch&#34; è comodo per sostituire una serie di comandi &#34;if&#34; consecutivi.
Mentre l&#39; &#34;if&#34; verifica solo se una condizione è VERA o FALSA, lo &#34;switch&#34;, data la condizione, verifica più CASI relativi ad essa.
 Però &#34;switch&#34; può essere utilizzato solo in alcuni casi, in cui:
- Viene valutata solo una variabile
- Ogni valore della variabile utilizzata determina una sola istruzione.
Alla fine dell&#39;istruzione eseguita, &#34;break&#34; determina l&#39;uscita dal costrutto &#34;switch&#34;.
Una scelta finale,  &#34;default&#34; , determina l&#39;operazione da eseguire qualora nessun CASO fosse rispettato.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2632"><question_text>Perchè una volta dichiarato un array non è più possibile variare la sua dimensione?</question_text><answer id="A2676"><answer_text>Negli array statici, una volta dichiarata la grandezza dell&#39;array, il compilatore riserva uno spazio di memoria necessario alla memorizzazione di quest&#39;ultimo (così come farebbe con ogni altra variabile dichiarata) e quindi non è più possibile modificarla in seguito. Invece negli array dinamici sarà possibile modificare dinamicamente la sua dimensione. </answer_text><num_votes>4</num_votes></answer><answer id="A2722"><answer_text>Non è possibile dichiarare un array con lo stesso nome, anzi, in genere non è possibile dichiarare un&#39;altra volta la stessa variabile con stesso nome.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2655"><question_text>Per la memorizzazione di stringhe quali sono le sostanziali differenze tra l&#39; utilizzo del comando scanf() ed il comando gets() ? 
Quando conviene utilizzare una rispetto all&#39; altra?</question_text><answer id="A2577"><answer_text>la funzione gets è utlizzzata per leggere le strighe di tipo char e quindi conteneti caratteri. 
Questo è usato poi la funzione gets legge tutti i caratteri fino al carattere &#34;\0&#34; contenuto nella stringa,
altrimenti lo scanf interromperebbe la lettura della stringa quando inserisco ad esempio un &#34;a-capo&#34;.
Ecco che allora conviene utilizzare il comando gets per le stringhe di tipo char e la funzione scanf per le stringhe numeriche.</answer_text><num_votes>0</num_votes></answer><answer id="A2647"><answer_text>Scanf() legge caratteri da tastiera di una singola parola quindi non è possibile memorizzare un&#39;intera riga formata da più parole (non comprende spazi).
Gets() invece legge caratteri dallo standard input fino a quando non incontra un carattere di newline o la fine del file (EOF) e inserisce come ultimo carattere il carattere NULL (&#39;\0&#39;). Conviene utilizzare Gets per memorizzare intere righe, scanf, invece, per una singola parola. Scanf() inoltre ammette array di tutte le tipologie di dato (purchè all&#39;interno dell&#39;array siano presenti dati dello stesso tipo).</answer_text><num_votes>0</num_votes></answer><answer id="A2670"><answer_text>Gets() permette di inserire più parole all&#39;interno di una stringa, leggendo dal file stdin fino al carattere di nuova linea o alla fine del file, e terminando automaticamente con il carattere di fine stringa &#34;\0&#34;. Utilizzando il comando scanf(), al contrario, non è possibile acquisire più di una parola (in quanto il carattere di spazio viene considerato come valore di fine stringa e vengono mantenute nel file stdin eventuali rimanenti parole). Gets è sempre conveniente per memorizzare stringhe di caratteri, scanf è preferibile per singole parole o necessario con gli altri tipi di dato.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2755"><question_text>il nome di una variabile di tipo array contiene un indirizzo di una cella di memoria oppure il contenuto ? perchè?</question_text><answer id="A2591"><answer_text>Array non è un tipo ma un costruttore di tipo. Dichiarato per esempio l&#39;array di tipo intero int array[10] si predisporranno in memoria 10 celle, da 0 a 9, dove l&#39;array funzionerà proprio come un puntatore alle 10 celle predisposte in memoria di tipo intero. array[0] sarà quindi un puntatore alla prima cella e così via fino ad array[9] che punterà all&#39;ultima cella di memoria.</answer_text><num_votes>2</num_votes></answer><answer id="A2721"><answer_text>Il nome di una variabile di tipo array contiene un indirizzo di memoria e non il contenuto perchè il contenuto può variare e quindi verrà cambiato il contenuto della cella senza cambiare l&#39;indirizzo stesso.</answer_text><num_votes>0</num_votes></answer><answer id="A2576"><answer_text>Il nome di una variabile di tipo array contiene l&#39;indirizzo del primo elemento dell&#39;array. Esso è un puntatore a tutti gli effetti. Accedendo all&#39;array mediante le parentesi quadre (es. myArray[n]), non facciamo altro che spostare l&#39;indirizzo puntato da myArray in avanti di n (n volte le dimensioni di una word: int, char, float, double a seconda del tipo dell&#39;array).</answer_text><num_votes>2</num_votes></answer></question><question id="Q2766"><question_text>Quali vantaggi comporta l&#39;allocazione dinamica di un vettore??
Quest&#39;ultima crea problemi in fase di compilazione del programma da parte del compilatore??
Fare un esempio di allocazione dinamica di un array di tipo int.</question_text><answer id="A2717"><answer_text>Il vantaggio più evidente consiste nella definizione e allocazione esattamente della memoria opportuna per l&#39;esecuzione richiesta. La La memoria viene infatti utilizzata durante la esecuzione del programma stesso, evitando che nella fase di compilazione si sprechino risorse. La limitazione principale consiste nella necessità di scrivere opportune righe di codice aggiuntivo, cosa che rallenta la compilazione. 
int *p;
p=(int*) malloc (5*sizeof(int));

garantisce uno spazio necessario per 5 interi</answer_text><num_votes>2</num_votes></answer><answer id="A2638"><answer_text>L&#39;allocazione dinamica di un vettore ci permette di non definire a priori la sua dimensione.Questo viene realizzato attraverso specifiche funzioni (malloc e sizeof) e l&#39;utilizzo dei puntatori.Se l&#39;array così creato però non viene inizializzato potrebbe portare a qualche problema in quanto la memoria utilizzata per la sua allocazione potrebbe essere &#34;sporca&#34;.
int *array;(puntatore ad intero)
int dim;(dimensione dell&#39;array)
array = (int*)malloc(dim*sizeof(int));(riserva in memoria dim &#34;spazi&#34; della dimensione di int e assegna al puntatore array la posizione in memoria del primo elemento)</answer_text><num_votes>1</num_votes></answer></question><question id="Q2781"><question_text>In che modo il programmatore può definire un &#34;tipo&#34;?</question_text><answer id="A2673"><answer_text>typedef tipo NomeNuovoTipo
Esempio: 
typedef char NomiStudenti[LUNGHEZZA_MASSIMA]</answer_text><num_votes>0</num_votes></answer><answer id="A2682"><answer_text>Una dichiarazione di tipo consiste nella parola chiave typedef, seguita dalla rappresentazione o costruzione del nuovo tipo, dall&#39;identificatore del nuovo tipo e dal simbolo &#34;;&#34; che chiude la dichiarazione.
Questo significa che un nuovo tipo può essere definito semplicemente dando un nuovo nome a un tipo già esistente.
</answer_text><num_votes>0</num_votes></answer><answer id="A2599"><answer_text>Il modo principale che un programmatore ha per definire un tipo è mediante una dichiarazione di tipo,che consiste nella parola chiave &#34;typedef&#34; seguita dalla rappresentazione o costruzione del nuovo tipo(ossia dalla specifica di come esso è costruito a partire da tipi già esistenti), dall&#39;identificatore del nuovo tipo e dal simbolo &#34;;&#34; che chiude la dichiarazione. In C è possibile anche definire nuovi tipi senza usare la parola chiave &#34;typedef&#34; tuttavia questa costruzione consente una maggior uniformità di stile nella definizione dei tipi e nella loro associazione a identificatori appropriati.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2733"><question_text>E&#39; possibile sapere a priori la lunghezza di un dato array gia inizializzato da terzi in precedenza?</question_text><answer id="A2548"><answer_text>Si, è possibile conoscere la dimensione di un array attraverso la funzione &#39;sizeof()&#39;.
Questa funzione restituisce la dimensione in byte della porzione di memoria occupata dall&#39;oggetto della funzione, quindi in genere si utilizza l&#39;espressione dimensione=sizeof(array)/sizeof(array[0]); per conoscere il numero di &#34;slot&#34; dell&#39;array.</answer_text><num_votes>0</num_votes></answer><answer id="A2709"><answer_text>E&#39; possibile conoscere la lunghezza, tuttavia si presentano diversi scenari: (i) Se l&#39;array statico è inizializzato, allora sarà definito il numero dei suoi elementi, quindi si può ottenere le dimensioni leggendo l&#39;inizializzazione. (ii) Se l&#39;array è un array di char si può conoscere la lunghezza della stringa scorrendone e contando gli elementi fino al carattere null \0. (iii) Definito un array è possibile calcolarne le dimensioni attraverso la funzione sizeof(&#60;nomearray&#62;) e delle semplici eleborazioni del valore restituito. La funzione restituisce lo spazio dei byte utilizzati in memoria.</answer_text><num_votes>3</num_votes></answer><answer id="A2589"><answer_text>Sì perché inizializzando un array statico bisogna specificare il numero dei suoi elementi, quindi chiunque può ricavarne le dimensioni leggendo l&#39;inizializzazione.</answer_text><num_votes>0</num_votes></answer><answer id="A2690"><answer_text>Se l&#39;array è un array di char (quindi una stringa) è possibile ottenere la dimensione della stringa stessa attraverso un ciclo while che scorra gli elementi della stringa finché non si incontri il carattere &#34;\0&#34;. 
Se l&#39;array è formato ad esempio da numeri interi, per calcolare la dimensione dell&#39;array si può usare il comando sizeof(a) dove a è un vettore di cui vogliamo conoscere la dimensione.</answer_text><num_votes>0</num_votes></answer><answer id="A2590"><answer_text>Sì perché inizializzando un array statico bisogna specificare il numero dei suoi elementi, quindi chiunque può ricavarne le dimensioni leggendo l&#39;inizializzazione.</answer_text><num_votes>0</num_votes></answer><answer id="A2547"><answer_text>Sì, è possibile conoscere la lunghezza di un array attraverso la funzione &#34;sizeof()&#34;.
Questa funzione restituisce la dimensione in byte occupata dall&#39;oggetto della funzione,
quindi in genere si utilizza l&#39;esperessione &#34;dimensione=sizeof(array)/sizeof(array[0]);&#34;
in modo da ottenere l&#39;esatto numero di &#34;slot&#34; che contiene l&#39;array.
</answer_text><num_votes>0</num_votes></answer></question><question id="Q2640"><question_text>Perchè quando si assegna ad un array una stringa (esempio: scanf(&#34;%s&#34;, stringa)), non si utilizza il carattere speciale &#39;&#38;&#39;? Cosa si intende quando invece si utilizza il carattere &#39;&#38;&#39;?
</question_text><answer id="A2619"><answer_text>Quando si assegna ad un array una stringa, non si utilizza l&#39;operatore &#38;, in quanto, il nome di una stringa (ed in generale di un array) denota già un indirizzo (l&#39;indirizzo del primo elemento). Il carattere &#38; si utilizza quindi, nel comando scanf, per assegnare un indirizzo ad una funzione.</answer_text><num_votes>2</num_votes></answer><answer id="A2573"><answer_text>L&#39;operazione di scanf con le stringhe non richiede l&#39;utilizzo del carattere &#39;&#38;&#39;, poiché le stringhe sono dei puntatori.
Negli altri casi il carattere &#39;&#38;&#39; serve a indirizzare la variabile.</answer_text><num_votes>4</num_votes></answer></question><question id="Q2667"><question_text>Perchè l&#39;indice di un array non è compreso tra 1 e n, ma tra 0 e n-1?</question_text><answer id="A2571"><answer_text>perche l&#39;indice di un array parte dal numero 0 fino ad n-1 e poi l&#39;ultima cella dell&#39;array è riservata al carattere di fine stringa ed è nota con  &#34;\0&#34;</answer_text><num_votes>0</num_votes></answer><answer id="A2688"><answer_text>Perchè i creatori del linguaggio di programmazione hanno deciso che sia così, per convenzione.</answer_text><num_votes>1</num_votes></answer><answer id="A2549"><answer_text>perchè in C un array è essenzialmente un puntatore ad una cella di memoria, quindi il primo di elemento contenuto in un array è salvato nella memoria esattamente nel punto [0].</answer_text><num_votes>2</num_votes></answer></question><question id="Q2664"><question_text>In un array è possibile avere dati di tipi diversi o no? </question_text><answer id="A2743"><answer_text>In un array non è possibile avere dati di tipi diversi; una caratteristica dell&#39;array è proprio l&#39;Omogeneità.
Nella dichiarazione si determina il tipo di dato che l&#39;array deve contenere.
Per fare un esempio si può prendere in considerazione un array di char; in cui ogni cella occupa una memoria di 1 byte (8 bit).
Se si volesse provare ad inserire un valore di tipo int (2 byte) in una cella dell&#39;array incontreremo un problema:
Il dato di tipo int non sarebbe soltanto contenuto nella cella in cui lo si vorrebbe immagazzinare ma anche nella cella subito seguente e sarebbe un&#39;errore.</answer_text><num_votes>1</num_votes></answer><answer id="A2685"><answer_text>Il tipo di dato strutturato array e&#39; omogeneo e ha una sequenza di celle consecutive. Non e&#39; possibile quindi avere al suo interno dati di tipo diverso, in fase di dichiarazione si sceglie il tipo di dato che conterrà l&#39;array dichiarato. </answer_text><num_votes>2</num_votes></answer><answer id="A2575"><answer_text>No, una delle caratteristiche dell&#39;array è l&#39;omogeneità dei dati in esso contenuti: tutti i valori immagazzinati sono dello stesso tipo.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2709"><question_text>Dopo una serie di if, l&#39;else alla fine a quale if viene attribuito?</question_text><answer id="A2556"><answer_text>Se si intende una serie di costrutti If annidati uno all&#39;interno dell&#39;altro, la parte Else verrà attribuita all&#39;ultimo costrutto If dichiarato.</answer_text><num_votes>0</num_votes></answer><answer id="A2545"><answer_text>Se siamo in presenza di if nidificati allora l&#39;else alla fine si riferisce al primo costruto if, se invece ci troviamo in presenza di una serie di costrutti if non nidificati l&#39;else finale e&#39; riferito all&#39;ultimo costrutto if.</answer_text><num_votes>1</num_votes></answer><answer id="A2698"><answer_text>Dopo una serie di costrutti if, l&#39;else viene attribuito sempre all&#39;if piu&#39; vicino a meno che non sia diversamente specificato da eventuali parentesi graffe. Ad ogni modo e&#39; utile porre sempre le parentesi graffe in modo tale che l&#39;istruzione risulti piu&#39; chiara sia per chi la programma che per chi dovrebbe modificarla o leggera in un secondo tempo.</answer_text><num_votes>2</num_votes></answer><answer id="A2672"><answer_text>Dopo una serie di if nidificati,l&#39;istruzione else è sempre riferita all&#39;ultima istruzione if che compare nel codice. Nel caso si voglia riferire l&#39;else al penultimo if è necessario chiudere il blocco di istruzioni di tale if prima dell&#39;else inserendo una }. Vedi esempio:

if(cond1){
   istruz1
   if(cond2){
      istruz2
   }
   // se metto la } qui else si riferisce a if(cond1) e devo eliminare l&#39;ultima parentesi graffa
   else{
      istruz3
   }
}

</answer_text><num_votes>0</num_votes></answer></question><question id="Q2661"><question_text>Che cosa si intende con &#34;lazy evaluation&#34; in riferimento alla valutazione delle condizioni in C?</question_text><answer id="A2652"><answer_text>Con &#34;lazy evaluation&#34; si intende la possibilità di valutare un&#39;espressione solo nel momento in cui questa è richiesta o strettamente necessaria. In questo modo rispetto alle &#34;strict (o eager) evaluation&#34; si possono ottenere migliori prestazioni sia dal punto di vista dell&#39;uso della memoria che dell&#39;uso delle risorse di sistema (si evita che le valutazioni avvengano più volte o quando non necessarie). La possibilità nativa di gestire le valutazioni in questo modo non è presente in tutti i linguaggi ma può essere comunque implementata.</answer_text><num_votes>2</num_votes></answer><answer id="A2569"><answer_text>Con &#34;lazy evaluation&#34; si indica una strategia di valutazione secondo la quale un&#39;espressione viene computata solo nel momento in cui questa è richiesta. Ciò permette un&#39;ottimizzazione delle prestazioni perché evita che un&#39;espressione venga computata più volte o quando non necessaria. Rispetto ad una &#34;strict evaluation&#34;, si hanno benefici sia per quanto riguada l&#39;impronta di memoria del programma, sia per quanto concerne la richiesta di prestazioni verso il calcolatore.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2674"><question_text>Perché nel dichiarare un qualsiasi Array si usa definire il numero massimo di elementi che questo può contenere quando si potrebbe semplicemente dichiarare un Array dinamico? </question_text><answer id="A2607"><answer_text>Certe volte si usa la dichiarazione statica di array, perché in quei casi magari si sa già la dimensione massima che serve e in questo modo non si va ad utilizzare,appunto, l&#39;allocazione dinamica che risulta un po&#39; più difficile(per neo-pragrammatori) e, nel caso che tale memoria allocata non venga deallocata dal programmatore si rischia di lasciarla inutilizzata il chè sarebbe uno spreco. </answer_text><num_votes>0</num_votes></answer><answer id="A2686"><answer_text>Utilizzando gli Array definiti da un numero massimo di elementi il programma viene eseguito in modo più immediato e le memorie di allocazione sono già conosciute dalla macchina.
Inversamente un Array dinamico comporta che ad ogni esecuzione il programma farà una stima delle memorie necessarie con la possibilità di utilizzare più celle del necessario o che siano insufficienti (overflow quando il numero di celle richieste sono superiori a quelle disponibili).
Comunque nel scrivere un programma di un tipo o dell&#39;altro questo dipende dal programmatore se è consapevole dei rischi che ci sono.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2672"><question_text>Cosa fa&#39; il compilatore quando viene dichiarato un array? </question_text><answer id="A2618"><answer_text>Quando viene dichiarato un array il compilatore riserva in memoria uno spazio sufficiente a memorizzare le N variabili di cui sarà composto l&#39;array(nel caso in cui l&#39;array sia statico). 
Queste celle saranno consecutive e la prima avrà indice 0 (per accedere sarà sufficiente richiamare il nome dell&#39;array che fa da puntatore, esempio: a[0]) mentre l&#39;ultima N-1. 
Nel caso in cui l&#39;array sia dinamico il compilatore deve trovare lo spazio di una dimensione(N,nota) durante l&#39;esecuzione.</answer_text><num_votes>3</num_votes></answer><answer id="A2564"><answer_text>Quando viene dichiarato un array il compilatore riserva in memoria una serie di celle consecutive in base al numero di elementi dichiarati e assegna alla prima cella, di indice 0, un puntatore (il nome dell&#39;array). In questo modo tutte le volte che l&#39;array verrà richiamato il compilatore utilizzerà l&#39;indirizzo salvato nel puntatore per accedere alla prima cella e si sposterà poi in quelle successive a seconda dell&#39;elemento su cui dovrà operare.</answer_text><num_votes>1</num_votes></answer><answer id="A2714"><answer_text>Quando si dichiara un array (per esempio array[N]) il compilatore riserva in memoria uno spazio di memoria sufficiente a memorizzare N variabili del tipo dichiarato.
A tali celle di memoria si accede tramite un indice, indicato tra parentesi quadre, che individua l&#39;elemento richiesto. Gli indici degli elementi vanno da 0 a N-1 (per accedere quindi al primo elemento dell&#39;array bisognerà quindi scrivere array[0]).</answer_text><num_votes>1</num_votes></answer></question><question id="Q2639"><question_text>Qual è la differenza tra una stringa e un array di caratteri? Fai un esempio.</question_text><answer id="A2696"><answer_text>La stringa non è altro che un tipo di dato definito dall&#39;utente che corrisponde ad un array di caratteri, il cui carattere finale è NULL cioè il carattere &#34;\0&#34; quindi una stringa di lunghezza N contiene N+1 caratteri. La stringa può essere definita dall&#39;utente con un typedef esempio: typedef char stringa[N]; invece l&#39;array di caratteri si dichiara semplicemente con l&#39;espressione di tipo dato char che corrisponde ai caratteri es. char vett[N];</answer_text><num_votes>1</num_votes></answer><answer id="A2544"><answer_text>Le stringhe devono terminare con il carattere terminatore &#39;\0&#39;, mentre un array di caratteri è solo un contenitore per più caratteri</answer_text><num_votes>0</num_votes></answer><answer id="A2699"><answer_text>Un array di caratteri può essere usato per rappresentare una stringa, l&#39;unica differenza è che nel caso di una stringa viene aggiunto il valore NULL per indicare la fine della stringa. Quindi nel caso di una stringa di lunghezza n si dovrà riservare uno spazio di memoria pari a n+1, per via del carattere NULL.
Per esempio:
char stringa[]=&#34;ciao&#34;;
equivale a dichiarare un array di caratteri chiamato &#34;stringa&#34; che sarà composto da 5 elementi.  </answer_text><num_votes>1</num_votes></answer><answer id="A2626"><answer_text>Nel linguaggio C non esiste il tipo stringa, ma è possibile definirlo/crearlo attraverso un array di caratteri. Se ad esempio vogliamo creare la stringa &#34;ciao&#34;, dobbiamo utilizzare un array come: char parola[4]. L&#39;array deve essere di quattro elementi perchè l&#39;ultima casella deve contenere &#34;\0&#34; per terminare la parola. Per stampare a video la parola è poi possibile utilizzarla come una stringa: printf(&#34;%s&#34;, parola).
Un altro modo per definire il tipo stringa è invece quello di utilizzare il costrutto &#34;typedef char stringa[NCAR]&#34; con NCAR il numero di caratteri massimo.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2772"><question_text>E&#39; possibile avere un array dove ogni elemento è un array? fare un esempio e mostrare come si può accedere ai diversi elementi.</question_text><answer id="A2592"><answer_text>Possiamo ottenere l?oggetto richiesto dal quesito utilizzando una variabile di tipo array a 2 dimensioni, oppure attraverso 1 costruttore di tipo ?typedef struct?.
Nel caso di una variabile array a 2 dimensioni 3 x 2, possiamo utilizzare 2 indici. Ad esempio se dichiaramo una matrice int &#60;nome&#62; [3][2]. Poi possiamo accedere al singolo elemento specificando la riga che ci interessa e con l?altro la colonna .
Esempio di assegnazione a variabile
Variabile = Matrice[1][0];
</answer_text><num_votes>1</num_votes></answer><answer id="A2654"><answer_text>Questa forma è detta array multidimensionale. Ad esempio un array bidimensionale si può pensare come una tabella bidimensionale con elementi dello stesso tipo.
Ad esempio se voglio creare una matrice n x m posso dichiarare: int matrice [3][6]; Con questa dichiarazione vedo un array di 6 elementi ciascuno dei quali contiene a sua volta un array di 3 elementi(le 3 righe divise dalle 6 colonne)
Per accedere agli elementi di &#34;matrice&#34; posso scrivere:&#34; matrice[n][m]&#34; dove &#34;n&#34; corrisponde alla riga e &#34;m&#34; alla colonna. Esempio: matrice [2][3]=elemento della terza riga ,quarta colonna.</answer_text><num_votes>4</num_votes></answer></question><question id="Q2641"><question_text>Dato che una funzione non può restituire come risultato un array, come si può inizializzarne uno tramite una funzione o procedura esterna al main?</question_text><answer id="A2718"><answer_text>Iniziamo dicendo che la domanda è valida solo per le funzioni, perché le procedure non possono restituire nulla. Per inizializzare un array con una funzione è necessario passare come parametro un puntatore che punta al primo elemento dell&#39;array. Ora sfruttando il puntatore possiamo usare effettivamente l&#39;array e con un semplice ciclo for lo inizializziamo come sempre, all&#39;interno della funzione. Alla fine la funzione dovrà restituire il puntatore al main. </answer_text><num_votes>2</num_votes></answer><answer id="A2725"><answer_text>Per inizializzare un array tramite funzione è necessario realizzare una funzione che generi valori casuali, generalmente chiamata &#34;random&#34; e chiamarla all&#39;interno di un ciclo for che analizzi ogni singola cella dell&#39;array. Così facendo l&#39;array si riempirà di valori casuali.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2616"><question_text>nel costrutto if, è possibile inserire un blocco di istruzioni vuoto? 
(ossia inserire la parentesi graffa aperta e quella chiusa senza niente all&#39;interno)
</question_text><answer id="A2719"><answer_text>Si&#39;, e&#39; possibile inserire un blocco di istruzioni vuoto nel costrutto if.
Non e&#39; un errore sintattico, pero&#39; sicuramente ci sono delle alternative migliori per svolgere
lo stesso compito. Possiamo dire che il codice e&#39; corretto ma non efficiente.</answer_text><num_votes>2</num_votes></answer><answer id="A2586"><answer_text>Certo che è possibile!
Ad esempio, nel codice sottostante riportato come esempio:
        
        int x;
	x = 0;
	printf(&#34;x = &#34;);
	scanf(&#34;%d&#34;, &#38;x);
	if (x &#62;= 10)
		{
		}
	else
		{
			printf(&#34;x &#60; 10! \n&#34;);
		}

inserendo x&#60;10 verrà eseguita l&#39;istruzione &#34;printf&#34; contenuta nell&#39;else mentre, inserendo x&#62;=10 il programma entrerà nell&#39;if e non eseguirà alcuna istruzione perchè vuoto.
In questo caso il compilatore non segnala alcun errore e, infatti, il programma non è errato; è semplicemente poco efficiente e potrebbe essere implementato meglio.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2642"><question_text>spiega brevemente cos&#39;è un array? e che tipi di array si possono avere nel linguaggio c?</question_text><answer id="A2552"><answer_text>Un array può essere definito come una ?collezione organizzata di oggetti?. Analizziamo la definizione e capiremo molte cose, innanzitutto il concetto di ?collezione? implica che tali oggetti siano dello stesso tipo; un array in C è una collezione di variabili dello stesso tipo.
?Organizzata? implica che sia possibile identificare univocamente tutti gli oggeti dell?array in modo sistematico; questo in C viene fatto tramite l&#39;uso di indici numerici che, in un array di dimensione N, vanno da 0 ad N-1.
Esistono due tipi di array:
-monodimensionali (vettore);
-multidimensionali.
</answer_text><num_votes>1</num_votes></answer><answer id="A2715"><answer_text>Un array può essere definito come una collezione organizzata di oggetti, dove tutti gli elementi appartengono allo stesso tipo (es. numeri reali, numeri reali e caratteri). Ogni elemento dell&#39;array dev&#39;essere identificato in modo sistematico, in quanto dev&#39;essere possibile richiamare ogni singolo elemento attraverso la notazione appropriata, questo in C viene fatto tramite l?uso di indici numerici che, in un array di dimensione N, vanno da 0 ad N-1. Essendo essi solamente una struttura astratta identificata da puntatori è possibile creare una array con qualsiasi tipo di dati. </answer_text><num_votes>1</num_votes></answer><answer id="A2747"><answer_text>un array è un insieme omogeneo di elementi collocati in memoria centrale in modo adiacente, l&#39;indirizzo da cui parte l&#39;array è inserito nell&#39;identificatore dello stesso, vale a dire che se abbiamo int a[10], &#39;a&#39; corrisponde alla prima cella dell&#39;array ovvero ad a[0]. L&#39;array si comporta come puntatore, vale a dire che se vogliamo puntare ad un elemento dereferenziato di 2 celle possiamo scrivere anche *(a +2).
In c ci sono tanti tipi di array quanti sono i tipi in c,importante è che gli elementi presenti in essi siano omogenei. </answer_text><num_votes>0</num_votes></answer></question><question id="Q2619"><question_text>Qual è il metodo più efficiente per scorrere un array con un numero molto grande di elementi?</question_text><answer id="A2570"><answer_text>Il metodo più efficente è l?utilizzo di istruzioni condizionali, quali i costrutti &#34;for&#34; e &#34;while&#34;.Conoscendo il numero,seppur grande,di elementi di un array, creando ed inizializzando una variabile contatore è possibile: 
1)creare un ciclo while che fintantoche il contatore è minore del  numero di elementi dell?array ne spazzi tutti i valori 
2)creare un ciclo for che fintantoche il contatore è minore del  numero di elementi dell&#39;array lo incrementi  e spazzi così tutti gli elementi dell?array stesso
Questi metodi sono necessari sia in fase di inizializzazione che di stampa dell&#39;array.</answer_text><num_votes>0</num_votes></answer><answer id="A2727"><answer_text>Il metodo più efficiente per scorrere un array con un numero elevato di elementi è un costrutto ciclo, più precisamente un ciclo for o while, grazie al quale è possibile scorrere tutti gli elementi dell&#39;array, incrementando l&#39;indice ad ogni passo. Tramite un ciclo for è presente scorrere, visualizzare tutti gli elementi dell&#39;array, dando la possibilità di bloccare il ciclo una volta che viene raggiunta una condizione.</answer_text><num_votes>2</num_votes></answer><answer id="A2572"><answer_text>Se il numero di interazioni è noto, è opportuno usare un ciclo for, che consiste in inizializzazione della variabile indice, condizione ed incremento. Altrimenti è consigliabile l&#39;applicazione di un ciclo while.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2648"><question_text>Esiste le possibilità di dichiarare un array dinamico vettore[a] con a una variabile di tipo int, in modo da poter incrementare il valore di a in un ciclo ottenendo così un array dinamico?</question_text><answer id="A2701"><answer_text>Si può definire in maniera dinamica solo il contenuto di un array.
Mettendo come condizione che vengano definiti in precedenza &#34;N&#34; e &#34;array[N]&#34;, si può quindi lanciare il ciclo &#34;for(a=0,a&#60;N,a++)&#34; e definire il contenuto dell&#39;array in modo dinamico.

</answer_text><num_votes>1</num_votes></answer><answer id="A2700"><answer_text>Si può definire in maniera dinamica solo il contenuto di un array.
Mettendo come condizione che vengano definiti in precedenza &#34;N&#34; e &#34;array[N]&#34;, si può quindi lanciare il ciclo &#34;for(a=0,a&#60;N,a++)&#34; e definire il contenuto dell&#39;array in modo dinamico.

</answer_text><num_votes>1</num_votes></answer></question><question id="Q2649"><question_text>Dare la definizione di array. Gli array dinamici sono utilizzabili nel linguaggio C? Che vantaggi danno?</question_text><answer id="A2738"><answer_text>È una ?collezione organizzata di oggetti?.Il concetto di ?collezione? implica che tali oggetti siano dello stesso tipo.Un array in C è dunque una collezione di variabili dello stesso tipo.?Organizzata? implica che sia possibile identificare univocamente tutti gli oggeti dell?array in modo sistematico;questo in C viene fatto tramite l?uso di indici numerici che,in un array di dimensione N,vanno da 0 ad N-1. int tesoro[100]; Con questa riga di codice ho dichiarato un array di interi, formato da 100 elementi.Questo significa che abbiamo 100 variabili pronte a contenere un numero intero =&#62;Pratico.</answer_text><num_votes>0</num_votes></answer><answer id="A2732"><answer_text>Un array e&#39; un insieme di celle omogenee e consecutive, gli n elementi dell&#39;array sono indicati da un indice che e&#39; compreso nell&#39;intervallo da 0 a n-1. Gli array in C possono essere di due tipi: statici o dinamici. Gli array dinamici prevedono la definizione della  loro dimensione solo durante l&#39;esecuzione. Gli array dinamici consentono al linguaggio di avere piu&#39; flessibilita&#39; ed inoltre permettono al programmatore di delegare la gestione della memoria.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2662"><question_text>Il costrutto &#34;switch case&#34; può confrontare il valore di una variabile con dei valori derivati da un&#39;espressione specificati nell&#39;istruzione &#34;case&#34;? Motiva la risposta.</question_text><answer id="A2609"><answer_text>nella definizione dei &#34;case&#34;, la variabile dev&#39;essere di tipo integral; per confrontare dei valori derivanti da un&#39;espressione, devo inserire l&#39;espressione come argomento di &#34;switch ()&#34; e la variabile INTERA come argomento di &#34;case&#34;.</answer_text><num_votes>1</num_votes></answer><answer id="A2745"><answer_text>Si perché é un confronto</answer_text><num_votes>0</num_votes></answer><answer id="A2728"><answer_text>Lo &#34;switch case&#34; confronta il valore di una variabile con un&#39;espressione COSTANTE specificata nel case.
Quindi il frammento di codice:
int x;
scanf(&#34;%d&#34;,&#38;x);
switch (x) {    
 case (1+1):
  printf(&#34;due \n&#34;);
  break;}
Non darà problemi in fase di compilazione perché l&#39;espressione &#34;1+1&#34; è costante.
Invece il frammento:
int x,y=1;
scanf(&#34;%d&#34;,&#38;x);
switch (x) {
 case (1+y):
  printf(&#34;due \n&#34;);
  break;}
non sarà compilato perché l&#39;espressione &#34;1+y&#34; NON è valutabile in fase di compilazione. Potrei risolvere il problema definendo y come costante (fuori dal main).</answer_text><num_votes>1</num_votes></answer><answer id="A2631"><answer_text>Si il costrutto può realizzare il confronto con valori derivati da un&#39;espressione. Infatti sarà il compilatore a intervenire in fase di compilazione sostituendo l&#39;espressione con il valore derivante da essa in quanto si tratterebbe di un lavoro inutile per la CPU. Dunque scrivere, per esempio, &#34;case 2+(8*2)&#34; oppure &#34;case 18&#34; non cambia in quanto in fase di compilazione l&#39;espressione in c viene sostituita dal valore finale di questa in linguaggio macchina. </answer_text><num_votes>0</num_votes></answer></question><question id="Q2761"><question_text>Cosa succede se in C, in un&#39;istruzione condizionale, la condizione è a=5 (es. if(a=5) ... NB manca un uguale)? Quali sono le insidie di questo errore?</question_text><answer id="A2712"><answer_text>Manca un uguale infatti, quando poniamo una variabile, in questo caso a, uguale ad un valore, 5, significa che viene assegnato questo valore alla variabile, nel caso di un&#39;istruzione condizionale usiamo il doppio uguale (a==5) per verificare se la variabile assume il valore che noi vogliamo, in questo caso 5. Le insidie di questo errore sono che il costrutto non andrà a verificare se la variabile assume il valore da noi voluto, ma il calcolatore assegnerà alla variabile questo valore e non verrà segnalato in compilazione.
</answer_text><num_votes>2</num_votes></answer><answer id="A2687"><answer_text>Si manca un uguale. Infatti quando scriviamo una variabile (a) e la poniamo uguale ad un valore (5), questo significa che noi assegniamo ad a il valore 5. Mentre nel caso del costrutto if a noi interessa verificare quando la variabile (a) è equivalente al valore da noi definito (5). Quindi la forma corretta del costrutto è if (a==5) {}.
Le insidie di questo errore sono che esso non può essere identificato dal calcolatore e quindi e difficilmente rivelabile.</answer_text><num_votes>2</num_votes></answer><answer id="A2746"><answer_text>L&#39;utilizzo di un solo = sta ad indicare un comando di assegnamento, mentre 2 = (==) sono utilizzati per il comando di uguaglianza.
Le insidie di tale errore possono essere, che: se per esempio l&#39;intenzione era di confrontare due valori in un&#39;istruzione if, l&#39;operatore di assegnamento ritornerà un valore che è molto probabile che venga valutato come TRUE, e sarà quindi valutata la clausola then, facendo comportare il programma in modo inatteso.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2688"><question_text>Ricordando la definizione e la funzione di puntatore commenta l&#39;affermazione:&#34;Un puntatore è una variabile che memorizza un indirizzo in memoria&#34;. Quali sono i vantaggi un puntatore rispetto ad altre variabili come array e struct??</question_text><answer id="A2598"><answer_text>Un puntatore e&#39; un tipo di dato, una variabile che contiene l&#39;indirizzo 
in memoria di un&#39;altra variabile. Si possono avere puntatori a qualsiasi tipo
di variabile.
Un puntatore al contrario degli array e delle struct è una variabile, per cui è facilmente utilizzabile all&#39;interno del linguaggio di programmazione.
In generale si può dire che i puntatori facilitano la scrittura.</answer_text><num_votes>2</num_votes></answer><answer id="A2702"><answer_text>I puntatori sono una caratteristica molto importante del linguaggio C, dal momento che permettono di lavorare a basso livello, in particolare per quanto riguarda l&#39;allocazione della memoria e la gestione degli indirizzi.
In particolare, essi sono fondamentali in caso di utilizzo di funzioni, poiché permettono il passaggio di parametri per indirizzo invece che per valore, consentendo così la modifica delle variabili mediante invocazione della funzione.
Proprio per questo fatto, tuttavia, essi possono generare anche effetti collaterali quali modifiche involontarie di variabili.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2630"><question_text>che differenza c&#39;è tra un ciclo for, un ciclo while ed un ciclo do-while?</question_text><answer id="A2551"><answer_text>Questi cilci permettono di eseguire più volte porzioni di codice, piuttosto che un comando come scanf().
La differenza principale tra ciclo for e while e che, mentre nel ciclo for il codice viene eseguito un numero di volte predefinito dall&#39;utente (es. for(i=0;i&#60;N;i++)) il ciclo while esegue il corpo del ciclo fintanto che la condizione è verificata (es. while(i&#60;N)).
Il do while, come il ciclo while, esegue il corpo del ciclo per un numero di volte non predefinito, ma prima esegue il corpo del ciclo e poi verifica la condizione. (es. do {} while(i&#60;N)).</answer_text><num_votes>2</num_votes></answer><answer id="A2579"><answer_text>I tre cicli sono equivalenti.
 Il ciclo &#34;for&#34; può sempre essere ricondotto ad un ciclo &#34;do while&#34; e anche ad un ciclo &#34;while&#34;. C&#39;è anche un teorema che lo dice, il teorema di Böhm-Jacopini. Il ciclo do-while è utile quando il numero di iterazioni è noto a priori. Mentre con il costrutto while la sequenza di istruzioni da ripetere viene eseguita solo se la condizione espressa dal while è verificata, nel ciclo do-while le istruzioni vengono eseguite e dopodiché viene effettuato il controllo che la condizione del while sia verificata.   
</answer_text><num_votes>0</num_votes></answer></question><question id="Q2732"><question_text>Per quale motivo un array deve avere dimensioni fisse?</question_text><answer id="A2705"><answer_text>Per array si intende una sequenza di celle di memoria consecutive ed omogenee. Ad ogni sequenza viene dato un identificatore, mentre ogni singola cella viene identificata mediante il nome della sequenza e un indice. Nel momento in cui creiamo un array dobbiamo indicare di quante celle di memoria necessitiamo,cioè diamo all&#39; array una dimensione fissa, in modo tale che quando richiamiamo una variabile il compilatore sappia a quale cella di memoria deve fare riferimento.</answer_text><num_votes>4</num_votes></answer><answer id="A3435"><answer_text>Gli array sono insiemi di variabili dello stesso tipo. Le singole variabili di un array sono dette elementi. Ogni elemento è identificato da un intero, detto indice. Gli array la cui dimensione viene specificata all&#39;interno del codice si chiamano array statici, dato che la loro dimensione non cambia durante l&#39;esecuzione del programma.  Le aree di memoria delle variabili sono consecutive e vengono riservate al momento della dichiarazione dell&#39;array, quindi la dimensione non può essere più modificata.</answer_text><num_votes>0</num_votes></answer><answer id="A2724"><answer_text>Gli array la cui dimensione viene definita all&#39;interno del programma come una costante sono gli array statici.Gli arraysono insieme di variabili dello stesso tipo.Le singole variabile di un array sono dette elementi.Gli array la cui dimensione fissa viene specificata all&#39;interno del codice si chiamano array statici.,dato che la loro dimensione non cambia durante l&#39;esecuzione del programma a differenza degli array dinamici la cui dimensione viene determinata all&#39;atto della esecuzione del programma .
es . array statici: intx[5]; float y[]={8.34,4.55.2.33.6.12};</answer_text><num_votes>1</num_votes></answer></question><question id="Q2677"><question_text>A cosa serve e quando si usa la funzione &#34;enum&#34;?</question_text><answer id="A2649"><answer_text>La funzione enum serve per definire un nuovo tipo di variabili che possono assumere un numero finito di valori, per questo vengono denominate anche costanti. La funzione enum viene usata quando si vogliono creare queste costanti. Queste costanti vengono enunciate, nel programma, ad esempio, in questo modo: 
&#34;enum Days {Sat, Sun, Mon, Tue, Wed, Thu, Fri};&#34;. </answer_text><num_votes>0</num_votes></answer><answer id="A2578"><answer_text>E&#39; un costrutto che serve per definire dei nuovi tipi di dati ordinati da numeri naturali; in pratica a basso livello verranno sempre visti  come interi, ma ad alto livello noi vedremo nomi più significativi come &#34;lunedì, martedì etc&#34; (se lo utilizziamo per i giorni della settimana).</answer_text><num_votes>0</num_votes></answer><answer id="A2583"><answer_text>Enumeration è un tipo user-defined di C, che permette di definire una lista di simboli.
Si inizializza con: enum {lista di simboli separati da virgola} nome della variabile; solitamente si usa per definire un nuovo tipo con valori predefiniti dal programmatore e di numero limitato. Bisogna fare attenzione riguardo a come i valori definiti vengono gestiti dal  compilatore: vengono infatti considerati come delle costanti intere.</answer_text><num_votes>1</num_votes></answer><answer id="A2632"><answer_text>&#34;enum&#34; è un costruttore di tipo, e la variabile dichiarata con questo costruttore può assumere i valori specificati dentro le parentesi graffe.
Per dichiarare una variabile con queste caratteristiche si usa questa notazione:
  enum {valore1, valore2, ecc} nomeVariabile;
I valori indicati all&#39;interno delle parentesi graffe rappresentano dei valori di tipo intero (non rappresentano stringhe). Per esempio se inizializziamo
  enum {lun, mar, mer, gio, ven, sab, dom} giorno;
  giorno=mar;
e stampiamo il valore di giorno il compilatore stamperà 1.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2627"><question_text>Perché quando si vuole dichiarare una stringa di n caratteri l&#39;array deve avere dimensione n+1?</question_text><answer id="A2562"><answer_text>Perchè un array di caratteri deve contenere in ultima posizione il valore speciale NULL, che indica dove finisce la stringa.</answer_text><num_votes>1</num_votes></answer><answer id="A2735"><answer_text>La stringa è definita in C come un array di caratteri terminante con la variabile &#39;\0&#39;. Durante l&#39;indicizzazione dobbiamo quindi considerare che nel nostro array è contenuto anche questo termine che andrà a diminuire lo spazio effettivo e utilizzabile all&#39;interno della nostra stringa. E&#39; quindi questa la motivazione per cui quando necessitiamo di una stringa di n caratteri dobbiamo dichiararla di dimensione n+1.</answer_text><num_votes>1</num_votes></answer><answer id="A2595"><answer_text>Perchè bisogna riservare l&#39;ultimo posto dell&#39;array per il carattere &#39;\0&#39; che è il carattere di &#34;fine stringa&#34;</answer_text><num_votes>1</num_votes></answer><answer id="A2734"><answer_text>La stringa è definita in C come un array di caratteri terminante con la variabile &#39;\0&#39;. Durante l&#39;indicizzazione dobbiamo quindi considerare che nel nostro array è contenuto anche questo termine che andrà a diminuire lo spazio effettivo e utilizzabile all&#39;interno della nostra stringa. E&#39; quindi questa la motivazione per cui quando necessitiamo di una stringa di n caratteri dobbiamo dichiararla di dimensione n+1.</answer_text><num_votes>0</num_votes></answer><answer id="A2585"><answer_text>Deve avere dimensione n+1 poichè ogni array come ultima posizione deve contenere il carattere speciale NULL. Il carattere viene utilizzato per capire dove finisce la stringa. Dunque il nostro array avrà dimensione n+1 per una stringa lunga n e in posizione n+1 troviamo il carattere speciale NULL. </answer_text><num_votes>0</num_votes></answer></question><question id="Q2685"><question_text>Se dichiaro un array di dieci elementi ( char a[10]; ) quante celle ho a disposizione?
Perché è importante il carattere &#34;\0&#34; nell&#39;ultima cella dell&#39;array?</question_text><answer id="A2742"><answer_text>Dichiarando un array di 10 elementi ho a disposizione in corrispondenza 10 celle, di cui una è riservata al carattere null.
Il carattere \0 è importante poiché corrisponde al carattere che ha valore zero in codifica ASCII.</answer_text><num_votes>1</num_votes></answer><answer id="A2629"><answer_text>Dichiarando &#34;char a[10]&#34; si otterrà un array con posizioni da &#34;a[0]&#34; ad &#34;a[9]&#34;. La posizione &#34;a[10]&#34; sarà occupata dal carattere &#34;\0&#34;. Ciò tornerà utile quando dovremo per esempio verificare la lunghezza, ponendo come condizione a[n]==&#34;\0&#34; come condizione di uscita di un ipotetico ciclo while.</answer_text><num_votes>0</num_votes></answer><answer id="A2593"><answer_text>Denotando con N (in questo caso 10)la dimensione dell&#39;array, il numero di celle a disposizione per memorizzare una stringa sara N+1, quindi 11.
Nell&#39;ultima cella è presente il carattere terminatore \0 che permette di trattare le stringhe senza conoscerne a priori la dimensione e ci indica quando una stringa termina.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2613"><question_text>L&#39;inizializzazione in fase di dichiarazione è un&#39;operazione applicabile ad un intero array? (cioè non ai singoli elementi dell&#39;array)</question_text><answer id="A2657"><answer_text>L&#39;inizializzazione di un array può essere fatta durante la sua dichiarazione,
 in maniera esplicita, indicando ogni valore di ogni cella manualmente, ecco un esempio:
&#34;int array_a[3] = {1, 50, 74};
 char array_vocali[5] = {?s?,&#39;u?,&#39;t?,&#39;y?,&#39;u?};&#34;
Però il modo più comodo per inizializzare array di grandi dimensioni è attraverso
dei cicli iterativi come la FOR, rimandando così  l&#39;inizializzazione in un secondo momento
rispetto alla dichiarazione.
Ecco un esempio:
&#34;int array_b[10];
for(i =0; i &#60; 10; i++)
{
array_b[i] = i;
}&#34;</answer_text><num_votes>0</num_votes></answer><answer id="A2720"><answer_text>E&#39; possibile inizializzare i termini di un array nella fase di dichiarazione nel seguendo modo:
int array[5] = {3,2,1,0,3};
char nome[5] = {&#39;c&#39;,&#39;a&#39;,&#39;r&#39;,&#39;l&#39;,&#39;o&#39;};

Per fare in modo che l&#39;array di caratteri &#34;nome&#34; venga interpretato come una stringa, ossia una serie di caratteri ben definiti ed &#39;uniti&#39;, è necessario introdurre il termine di fine stringa &#39;\0&#39; come nel seguente caso :

char nome[6] = {&#39;c&#39;,&#39;a&#39;,&#39;r&#39;,&#39;l&#39;,&#39;o&#39;,&#39;\0&#39;};

oppure alternativamente :
char nome[6] = &#34;carlo&#34;;
in cui il termine di fine stringa viene introdotto automaticamente.</answer_text><num_votes>0</num_votes></answer><answer id="A2733"><answer_text>Nella programmazione C non è possibile fare operazioni (ad esempio printf o scanf) su un intero array. Per inizializzare il contenuto ci si deve servire del ciclo &#39;for&#39; che permette di scorrere i vari elementi che compongono l&#39;array.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2614"><question_text>Qual&#39;è la differenza tra array statici ed array dinamici?
Quale vantaggio si ha dichiarando array dinamici rispetto alla dichiarazione di array statici?</question_text><answer id="A2642"><answer_text>La differenza sostanziale tra array dinamici e statici è la seguente:negli array statici la dimensione è nota a tempo di compilazione mentre negli array dinamici vi è il dimensionamento e l&#39;allocazione a tempo di esecuzione.Questa,oltre ad essere la sostanziale differenza, è anche il vantaggio principale degli array dinamici rispetto a quelli statici.</answer_text><num_votes>0</num_votes></answer><answer id="A2739"><answer_text>Gli array statici vengono inizializzati con dei valori fissi; quelli dinamici invece no. 
Il vantaggio di avere un array dinamico rispetto ad uno statico è che è più flessibile.</answer_text><num_votes>0</num_votes></answer><answer id="A2716"><answer_text>Quando si dichiara un array statico (es: int coef[20];) e&#39; già noto a tempo di compilazione lo spazio necessario a memorizzare l&#39;array.
Nelle definizioni dinamiche invece (es: char c[len];) l&#39;array deve trovare spazio in memoria a tempo di esecuzione e non di compilazione.
Il vantaggio di utilizzare un array dinamico è che questo aggiunge notevole flessibilita&#39; al linguaggio.
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2652"><question_text>Perchè nell&#39;acquisizione da tastiera di una stringa è preferibile utilizzare il comando &#34;gets&#34; piuttosto che &#34;scanf&#34;?</question_text><answer id="A2582"><answer_text>il gets legge tutti i valori presenti sulla riga finché non trova un /n (a capo) o un /0 (termine riga).
quindi siamo sicuri che tutti i dati che abbiamo inserito, vengano trasportati nell&#39;array.

lo scanf invece innanzitutto analizza il formato del dato da inserire, e poi cattura solo ciò che riguarda lo stesso formato; quindi non c&#39;è la certezza che tutti i datiinseriti, vengano immessi nell&#39;array.</answer_text><num_votes>1</num_votes></answer><answer id="A2697"><answer_text>Nell&#39;acquisizione da tastiera di stringhe è preferibile utilizzare il comando &#34;gets()&#34; in quanto esso permette l&#39;acquisizione di stringhe includenti spazi(blank space) e l&#39;ultimo carattere che indica la fine della stringa  è &#34;invio&#34;(enter key).
Con &#34;scanf()&#34; il carattere indicante la fine della stringa può essere o &#34;invio&#34; oppure &#34;spazio&#34;,di conseguenza non si possono memorizzare stringhe contenenti blank space.</answer_text><num_votes>0</num_votes></answer><answer id="A2713"><answer_text>Scanf è sconsigliata per l&#39;acquisizione delle stringhe in quanto legge il carattere &#34;spazio&#34; come la terminazione della stringa ossia come lo 0. In altre parole se acquisisco ad esempio una stringa con il carattere spazio (es nome cognome) acquisisce solo il nome. Per questo solitamente nell&#39;acquisizione di stringhe da tastiera si usa gets o ancor meglio fgets: f gets infatti esegue un controllo sulla dimensione della stringa segnalando un eventuale errore nel caso la stringa superi la dimensione del buffer.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2778"><question_text>Quali sono i limiti del dato strutturato array?</question_text><answer id="A2617"><answer_text>L&#39;array rappresenta il più semplice tipo di dato strutturato utilizzato in molti linguaggi di programmazione. Oltre alla sua importanza vanno però evidenziati i limiti che questa struttura dati presenta, onde evitare errori in fase di programmazione.
E&#39; bene tenerli a mente dato che IL LINGUAGGIO C NON EFFETTUA ALCUN CONTROLLO SU I LIMITI DEGLI ARRAY.
ERRORI DA NON FARE:
1) Operazioni aritmetiche o di confronto fra array;
2) Chiedere ad una funzione di restituire un array;
3) Assegnare un valore all&#39;intero array;
4) Inizializzare un array di N elementi con più di N valori.</answer_text><num_votes>2</num_votes></answer><answer id="A2613"><answer_text>Un array è un raccoglitore che raggruppa un determinato numero di variabili con lo stesso
nome, ma indice diverso. Le variabili contenute nell&#39;array devono essere tutte dello stesso 
tipo, quindi ad esempio se dichiaro un array di 20 elementi di tipo intero ottengo 19 variabili
(la ventesima è &#34;\0&#34;) tutte di tipo intero.</answer_text><num_votes>0</num_votes></answer><answer id="A2681"><answer_text>gli indici array non hanno nessun controllo sulla correttezza dei dati immessi, quindi molto spesso vengono fatti calcoli su celle di memoria inesistenti.</answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L35" title="Funzioni" date="2013-11-04"><question id="Q3185"><question_text>Le seguenti funzioni utilizzano due metodi differenti per &#34;passare&#34; le variabili:
-int funzione1(int a, int b){...}
-int funzione2(int* a, int* b){...}
Quali sono le differenze tra questi due metodi? come vengono richiamate le funzioni nel main?</question_text><answer id="A3259"><answer_text>Nella funzione 1 passo solo il valore delle variabili a e b mentre nella funzione 2 passo il riferimento alle variabili. Nella funzione due devo stare attento a non modificare il valore delle variabili a e b, in quel caso anche il valore che hanno nel main cambierebbe. Nel main nel primo caso devo passare il nome delle variabili nel secondo devo passare l&#39;indirizzo</answer_text><num_votes>0</num_votes></answer><answer id="A3266"><answer_text>funzione1 utilizza il metodo per valore: viene passato solamente il valore della variabile, che verrà copiata e non subirà modifiche.
funzione2 utilizza il metodo per riferimento: viene passato l&#39;indirizzo di una varabile, che quindi subirà modifiche. I parametri di funzione2 devono essere indirizzi quindi si usa &#38;nomevariabile</answer_text><num_votes>3</num_votes></answer><answer id="A3260"><answer_text>Nella funzione 1 passo solo il valore delle variabili a e b mentre nella funzione 2 passo il riferimento alle variabili. Nella funzione due devo stare attento a non modificare il valore delle variabili a e b, in quel caso anche il valore che hanno nel main cambierebbe. Nel main nel primo caso devo passare il nome delle variabili nel secondo devo passare l&#39;indirizzo</answer_text><num_votes>1</num_votes></answer></question><question id="Q3183"><question_text>Quale è la differenza tra variabili globali e variabili locali?</question_text><answer id="A3162"><answer_text>Le variabili globali si dichiarano fuori dalle funzioni compresa la funzione &#39;main&#39;, per questo vengono viste e possono essere richiamate da tutte loro. Le variabili locali, invece, sono dichiarate all&#39;interno delle funzioni: Esse nascono quando si accede alla funzione si distruggono all&#39;uscita. Generalmente nella programmazione si tende a usare poche variabili globali in quanto si può incorrere facilmente in errori.</answer_text><num_votes>3</num_votes></answer><answer id="A3149"><answer_text>Le variabili globali possono essere usate per tutta la durata del programma, vengono allocate in fase di compilazione e sono dichiarate fuori dal main (subito dopo le librerie). Esse quindi sono viste da tutte le parti del programma, cioè sia dal main che dalle varie funzioni. Queste possono causare uno spreco di memoria a differenza delle variabili locali che vengono viste solo dalla parte di codice in cui sono inserite e sono delimitate dagli operatori { e }. Questo permette di liberare la memoria  e quindi non farla saturare. </answer_text><num_votes>2</num_votes></answer><answer id="A3148"><answer_text>Le variabili globali possono essere usate per tutta la durata del programma, vengono allocate in fase di compilazione e sono dichiarate fuori dal main (subito dopo le librerie). Esse quindi sono viste da tutte le parti del programma, cioè sia dal main che dalle varie funzioni. Queste possono causare uno spreco di memoria a differenza delle variabili locali che vengono viste solo dalla parte di codice in cui sono inserite e sono delimitate dagli operatori { e }. Questo permette di liberare la memoria  e quindi non farla saturare. </answer_text><num_votes>0</num_votes></answer></question><question id="Q3129"><question_text>Quali sono le caratteristiche delle funzioni ricorsive?</question_text><answer id="A3130"><answer_text>Una funzione è ricorsiva quando al suo interno c&#39;è un invocazione a se stessa. Le funzioni ricorsive vengono impiegate quando è necessario compiere una serie di operazioni tutte identiche fra di loro.</answer_text><num_votes>1</num_votes></answer><answer id="A3239"><answer_text>Le caratteristiche delle funzioni ricorsive sono principalmente le seguenti: la presenza di uno o piu&#39; casi base, nei quali il risultato puo&#39; essere determinato direttamente; la presenza di uno o piu&#39; casi complessi, detti ricorsivi, che individuano il risultato della funzione in un valore piu&#39; piccolo e piu&#39; semplice risultante dall&#39;esecuzione della funzione stessa.</answer_text><num_votes>2</num_votes></answer></question><question id="Q3169"><question_text>Che differenza c&#39;è tra i parametri formali ed i parametri attuali di una funzione?</question_text><answer id="A3194"><answer_text>Gli argomenti della funzione, elencati nella testata all&#39;interno delle parentesi, vengono detti parametri formali della funzione. Questi rappresentano quei valori che la funzione richiede per eseguire le operazioni che l&#39;utente ha inserito all&#39;interno. Per quanto riguarda invece i parametri attuali ( detti anche effettivi ) sono quelli con cui la funzione attua le operazioni logiche al suo interno. Quando la funzione viene invocata, i parametri formali vengono inizializzati con i valori dei parametri effettivi.</answer_text><num_votes>1</num_votes></answer><answer id="A3157"><answer_text>I parametri formali sono quelli dichiarati per tipo, numero e ordine nella definizione della funzione.In pratica sono gli argomenti della funzione elencati nell&#39;header.I parametri attuali sono quelli che vengono passati alla funzione all?atto della chiamata.All?atto dell?invocazione della funzione infatti, i parametri formali vengono inizializzati con i valori dei parametri attuali.Importante è la coerenza di tipo e di numero tra parametri formali e parametri attuali, anche se nel trasferimento di valore da parametro attuale a parametro formale possono essere effettuate conversioni implicite.</answer_text><num_votes>1</num_votes></answer><answer id="A3176"><answer_text>I parametri formali di una funzione sono gli argomenti della stessa e vengono elencati nell&#39;header. Questi verranno usati nel corpo della funzione per svolgere le operazioni volute.
I parametri attuali (effettivi) sono quelli con cui la funzione viene attivata e prenderanno il posto (rispettando l&#39;ordine con cui vengono elencati) di quelli effettivi per svolgere la funzione nei diversi casi.
Per es
int A(int n){
 return n*3;
}
n è parametro formale
main
{
.
A(x);
.
} x è parametro effettivo e prenderà il posto di ogni n all&#39;interno della funzione.</answer_text><num_votes>0</num_votes></answer><answer id="A3178"><answer_text>I parametri formali di una funzione sono quelli usati nella sua intestazione, quando essa viene dichiarata. Ad esempio, in una funzione la cui intestazione è &#34;int somma(int a,int b)&#34;, i parametri formali sono &#34;a&#34; e &#34;b&#34;. I parametri attuali di una funzione sono invece i parametri con cui una funzione viene attivata, dopo che è stata opportunamente dichiarata. </answer_text><num_votes>2</num_votes></answer></question><question id="Q3139"><question_text>Che cosa si intende per effetti collaterali (side effects) nell&#39;ambito delle funzioni e quando possono avvenire?</question_text><answer id="A3133"><answer_text>Un &#34;side effect&#34; è un cambiamento dello stato del programma che può compromettere il funzionamento del programma stesso e può modificare variabili presenti in altre funzioni.
Un tipo di side effect si verifica quando vengono utilizzate variabili globali all&#39;interno di un sottoprogramma o di una funzione, senza che esse siano definite all&#39;interno dell&#39;elenco delle variabili della funzione.
In questo caso la funzione, se richiamata, va a utilizzare le variabili globali e questo rende imprevedibile il comportamento della funzione. </answer_text><num_votes>2</num_votes></answer><answer id="A3253"><answer_text>Gli effetti collaterali a cui viene fatto riferimento sono quelli che si manifestano inizializzando una variabile in ambiente GLOBALE, ossia esterno a tutte le funzioni; 
Se si inizializza &#34;int a;&#34; in un ambiente globale, essa può essere usata in più funzioni...ma modificandola, può variare il significato che assume all&#39;interno delle diverse funzioni. Questo è l&#39;effetto collaterale.
E&#39; perciò sconsigliabile l&#39;utilizzo di variabili globali.

</answer_text><num_votes>1</num_votes></answer><answer id="A3134"><answer_text>Un &#34;side effect&#34; è un cambiamento dello stato del programma che può compromettere il funzionamento del programma stesso e può modificare variabili presenti in altre funzioni.
Un tipo di side effect si verifica quando vengono utilizzate variabili globali all&#39;interno di un sottoprogramma o di una funzione, senza che esse siano definite all&#39;interno dell&#39;elenco delle variabili della funzione.
In questo caso la funzione, se richiamata, va a utilizzare le variabili globali e questo rende imprevedibile il comportamento della funzione. </answer_text><num_votes>0</num_votes></answer><answer id="A3189"><answer_text>Il side effect o effetto collaterale è generato dalla modifica dell&#39;ambiente globale, ovvero ciò in cui è contenuto il main e le altre funzioni.
Nell&#39;ambito di queste ultime si verifica un effetto collaterale quando si va a modificare una variabile che non è stata dichiarata all&#39;interno della funzione, ovvero nell&#39;ambiente globale, così facendo l&#39;effetto di esecuzione di una funzione non è più confinato all&#39;interno della stessa, ma potrebbe anche andare a modificare variabili utilizzate dal altre funzioni, compromettendone il funzionamento.
È quindi sconsigliato l&#39;uso di variabili globali.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3131"><question_text>Perché una funzione non può restituire un&#39;array, ma solo un singolo valore o un puntatore?</question_text><answer id="A3232"><answer_text>Una funzione non può restituire un array appunto per definizione di funzione, puo essere restituito un solo valore come puo essere un intero o un puntatore ma non un vettore di valori come un array. La funzione esegue una serie di operazioni su parametri attuali tramite parametri formali per cui il risultato finale DEVE essere un solo valore.</answer_text><num_votes>0</num_votes></answer><answer id="A3246"><answer_text>La funzione è in grado di restituire solo un valore o un puntatore principalmente per problemi relativi alla allocazione statica della memoria necessaria in C. In C++, data la possibilità di allocare dinamicamente la memoria, si ha la possibilità di estrarrae array mediante funzioni.</answer_text><num_votes>1</num_votes></answer><answer id="A3270"><answer_text>Una funzione non può restituire un&#39;array perché la memoria viene deallocata automaticamente durante la sua esecuzione e ritorna solo un singolo valore o puntatore ad esso.</answer_text><num_votes>2</num_votes></answer><answer id="A3245"><answer_text>Una funzione tratta ogni singolo elemento in maniera separata analizzandolo singolarmente!
Siccome un array sono una serie di variabile memorizzate in spazi che non conosciamo, la funzione può restituire solamente il puntatore alle singole celle dell&#39;array!</answer_text><num_votes>1</num_votes></answer><answer id="A3244"><answer_text>Una funzione tratta ogni singolo elemento in maniera separata analizzandolo singolarmente!
Siccome un array sono una serie di variabile memorizzate in spazi che non conosciamo, la funzione può restituire solamente il puntatore alle singole celle dell&#39;array!</answer_text><num_votes>0</num_votes></answer></question><question id="Q3199"><question_text>Come avviene il passaggio di dati per puntatori tra le funzioni?                                                                                                             
                                                                                      </question_text><answer id="A3229"><answer_text>Attraverso il passaggio per riferimento si fornisce alla funzione il puntatore (e quindi l&#39;indirizzo della posizione in memoria) della variabile su cui interessa operare.
In questo modo la funzione è in grado di lavorare sulla variabile stessa, anzichè crearne una copia come nel passaggio per valore. 
Le funzioni successive alla prima vanno ad operare variazioni sulla stessa variabile, che viene modificata.
Il passaggio per riferimento migliora l&#39;efficienza del programma, in alternativa sarebbero necessarie &#39;n&#39; copie della stessa variabile per &#39;n&#39; funzioni.
</answer_text><num_votes>2</num_votes></answer><answer id="A3193"><answer_text>Il passaggio di dati per indirizzo tra le funzioni avviene utilizzando l&#39;operatore di dereferenziazione (*) sulla variabile che viene passata come puntatore; il simbolo &#38; nella chiamata della funzione nel main affinchè sia passato l&#39;indirizzo e di nuovo * nel corpo della funzione per modificare il valore della variabile puntata.</answer_text><num_votes>0</num_votes></answer><answer id="A3182"><answer_text>Il passaggio per indirizzi avviene copiando nella zona di memoria annessa alla funzione solo il puntatore alle variabili interessate. Questo processo è molto utile in quanto si da maggior leggerezza al programma, riducendo i dati da copiare da un istanza all&#39; altra.
La cosa svantaggiosa è però che modifica direttamente le variabili in gioco, quindi bisogna prestare estrema attenzione quando usarla per non modificare valori che invece dovrebbero restare fissi.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3266"><question_text>è possibile implementare una funzione senza per forza dichiarare anche l&#39;Header? se si in quali problemi potremmo incorrere? fare un esempio in cui senza la dichiarazione preventiva degli header delle funzioni non è possibile dichiarare le stesse.</question_text><answer id="A3235"><answer_text>L Header contiene informazioni importanti ai fini di un uso corretto della funzione, dunque è buona norma dichiararla sempre. Nel caso non si dichiarasse potremmo incappare in errori, come ad esempio restituzione del risultato della funzione non corretto o parametri formali non corretti. ES: nel caso non si dichiarasse il tipo di variabili di ritorno potremmo avere un risultato non conforme alla richiesta della funzione.
</answer_text><num_votes>0</num_votes></answer><answer id="A3220"><answer_text>Una funzione deve essere necessariamente dichiarata attraverso:
-una testata (o header) con: il tipo del risultato ritornato, un identificatore del sottoprogramma e una lista di dichiarazioni degli argomenti della funzione.
-un blocco, detto corpo (o body) della funzione.
Possiamo così notare che senza l&#39;header, manca anche l&#39;identificatore e richiamare il sottoprogramma sarebbe impossibile.
Per esempio: se nel programma viene richiamata la funzione stampa(int x), ma nella dichiarazione non è stato definito nessun header, il programma non sa a che cosa è riferito il nome stampa(int x).</answer_text><num_votes>1</num_votes></answer><answer id="A3131"><answer_text>é possibile farlo bisogna però stare attenti a dove la si implementa,una funzione per essere chiamata deve essere stata precedentemente dichiarata/definita.Invocare una funzione non dichiarata/definita precedentemente porterebbe ad un errore.Se per esempio definiamo la funzione(senza header preventivo)al di sotto del main,nel momento in cui andiamo a richiamarla si genera un errore.Stessa cosa avviene nel caso un cui sviluppiamo le funzioni su un&#39;altro file.Se non dichiariamo l&#39;header della funzione e il file in cui si trova prima di usarla, questa non potrà mai essere richiamata.</answer_text><num_votes>3</num_votes></answer></question><question id="Q3135"><question_text>Se io dovessi cambiare il contenuto di un array precedentemente dichiarato quali parametri devo essenziali devo passare alla funzione?
Tale funzione mi ritornerà qualche tipo di dato? Come può essere definita questo tipo di funzione?</question_text><answer id="A3187"><answer_text>Per cambiare il contenuto di un array utilizzo i parametri per indirizzo tramite operatori di differenziazione, operatori di indirizzo e costruttore di puntatore. Ciò consente di ritornare uno o più risultati al chiamante. Avremo quindi una funzione in procedura.</answer_text><num_votes>0</num_votes></answer><answer id="A3188"><answer_text>In C una funzione non può ritornare direttamente un array quindi, per modificare un array precedentemente dichiarato, devo passarlo alla funzione per indirizzo e non per valore. Se lo passassi per valore la funzione riuscirebbe a modificarlo solo localmente e nella funzione chiamante (solitamente il main) non otterrei alcuna modifica. Non è necessario che la funzione ritorni dei dati perché modifica già la variabile dichiarata nella funzione chiamante. Questo tipo di funzione viene chiamata procedura. Per far restituire un array ad una funzione dovrei inserirlo all&#39;interno di una struttura.</answer_text><num_votes>5</num_votes></answer></question><question id="Q3177"><question_text>Quando è più conveniente usare il passaggio di parametri per valore rispetto al passaggio di parametri di indirizzo?</question_text><answer id="A3191"><answer_text>E&#39; più conveniente usare il passaggio di parametri per valore rispetto a quello per indirizzo, quando si effettua cambiamenti dei parametri della procedura, perché questi cambiamenti non influenzano i valori delle variabili del programma principale, cioè la modifica della coppia locale non ha influenza sul parametro originale, inoltre i valori delle variabili del programma principale vengono copiate nei parametri della procedura.
Infine il passaggio di parametri per valore è utile per isolare ciò che fa la funzione dal resto del programma.
</answer_text><num_votes>1</num_votes></answer><answer id="A3174"><answer_text>Normalmente il passaggio per indirizzo è più conveniente, ma non nei seguenti casi:
-Passare un array di dati: un semplice puntatore non è in grado di farlo.
-Gestire dati abbastanza piccoli: non conviene prendere l&#39;indirizzo.
-Modificare i dati passati: per far ciò è molto più semplice passare per parametro.
-Strutture disordinate: generalmente è più complicato operare coi puntatori data la loro 
                                   sintassi meno logica.</answer_text><num_votes>2</num_votes></answer></question><question id="Q3237"><question_text>Da cosa è composta la definizione di funzione? Elenca e spiega le 2 componenti.</question_text><answer id="A3226"><answer_text>La definizione di funzione si avvale di due nozioni: quella di testata (o header) e quella di corpo (o body). L&#39;header della funzione contiene: il tipo del risultato o &#34;codominio&#34; (es. int, float, ecc...), l&#39;identificatore del sottoprogramma (nome per &#34;chiamare&#34; la funzione) e la dichiarazione degli argomenti o &#34;dominio&#34; (es. int x, int y...). Il corpo della funzione è composto da: la parte dichiarativa locale (contiene le variabili necessarie all&#39;esecuzione) e la parte programmatica (contiene le istruzioni per l&#39;esecuzione della funzione, es. cicli for, while e tutte le altre operazioni).</answer_text><num_votes>3</num_votes></answer><answer id="A3138"><answer_text>La definizione di funzione è composta da una testata e da un corpo. La testata, chiamata anche header, contiene le informazioni principali per un corretto funzionamento della funzione. In essa si definiscono il dominio, il codominio (utilizzando parametri formali) e il nome della funzione. Il corpo (body) invece è costituito da un blocco di istruzioni (cicli, istruzioni condizionali, struct o qualsiasi altro tipo di comando) che implementano effettivamente il compito che la funzione deve svolgere.</answer_text><num_votes>2</num_votes></answer></question><question id="Q3171"><question_text>Cosa si intende per record di attivazione di una funzione? Cosa contiene e a cosa serve?</question_text><answer id="A3172"><answer_text>L&#39;insieme dei dati salvati sullo stack (come parametri, variabili locali,...) è detto record di attivazione di una funzione, e rappresenta una funzione in esecuzione.Il record di attivazione nasce e muore con essa e quindi ne esiste uno specifico per ogni funzione.</answer_text><num_votes>3</num_votes></answer><answer id="A3250"><answer_text>Un record di attivazione è una struttura dati salvata in memoria al momento della chiamata di una funzione. In esso sono contenuti tutti  parametri e le variabili locali della funzione che lo ha generato. Sono contenute ino miltre informazioni riguardo l&#39;indirizzo di ritorno (punta all&#39;istruzione successiva a quella che ha chiamato la funzione) e al collegamento al record di attivazione della funzione chiamante.
Serve per mantenere in memoria le informazioni necessarie alla &#34;macchina astratta&#34; per eseguire la funzione.</answer_text><num_votes>3</num_votes></answer></question><question id="Q3163"><question_text>cosa contiene la testata (o &#34;header&#34;) di una funzione?</question_text><answer id="A3140"><answer_text>La testata o &#34;header&#34;, che e&#39; una parte della definizione di una funzione, contiene le informazioni piu&#39; rilevanti per l&#39;uso corretto di una funzione. La testata e&#39; costituita da:1-tipo di risultato (che costituisce il codominio della funzione); 2-dall&#39;identificatore del sottoprogramma; 3-dalla lista dei parametri cui la funzione viene applicata con il relativo tipo (la lista dei parametri costituisce il dominio della funzione). Un esempio di testata e&#39;: int casa( int base, int x) dove il primo int= tipo parametro di ritorno; casa=identificatore funzione e ( int base, int x)=parametri formali.</answer_text><num_votes>4</num_votes></answer><answer id="A3132"><answer_text>La testata di una funzione contiene contiene il tipo di dato che la funzione deve  ritornare (void, int, float...), il nome della funzione, e tra parentesi i parametri formali ovvero i valori che utilizzerà la funzione. L&#39;header andrá poi scritto prima del main o nel file .h</answer_text><num_votes>0</num_votes></answer></question><question id="Q3244"><question_text>Come faccio ad impedire ad una funzione di modificare un parametro passato per riferimento? </question_text><answer id="A3210"><answer_text>Per impedire ad una funzione di modificare un paramentro passato per riferimento è sufficiente utilizzare la parola chiave &#34;const&#34; davanti al tipo di dato nell&#39;intestazione della funzione.

Esempio:

void funzione(const int variabile1, int variabile2){
    variabile1 = 0     // ERRORE, c&#39;è const davanti a &#34;int variabile1&#34;
    variabile2 = 0     // Questo è possibile!!
}</answer_text><num_votes>2</num_votes></answer><answer id="A3268"><answer_text>Con il passaggio per riferimento il contenuto in memoria di quella variabile non viene semplicemente copiato e utilizzato dentro alla funzione, ma viene proprio fatto riferimento alla sua posizione in memoria e quindi il contenuto in memoria viene modificato, cosa che non accade con il passaggio per valore dove il contenuto in memoria di quella variabile non viene modificato. Non avrebbe molto senso passare per riferimento dei parametri che non si vuole che vengano modificati in memoria.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3140"><question_text>Che cosa permettono di fare i sottoprogrammi e quali vantaggi portano alla programmazione? </question_text><answer id="A3136"><answer_text>I sottoprogrammi permettono di svolgere parte del programma in una zona separata.
Il codice risulta così più leggibile e si possono effettuare più operazioni simili semplicemente richiamando il programma senza riscriverlo.</answer_text><num_votes>0</num_votes></answer><answer id="A3141"><answer_text>I sottoprogrammi (o funzioni) sono parti del programma che vengono definite fuori dal main in modo da alleggerire il codice. Di solito sono sottoalgoritmi limitati (ad. es. un codice che riempie un array con valori generati casualmente) che vengono richiamati nel main specificando dei valori (variabili o puntatori) in input e restituiscono un valore in output (fanno eccezione le procedure o funzioni void che non restituiscono nulla).</answer_text><num_votes>0</num_votes></answer><answer id="A3185"><answer_text>I sottoprogrammi sono programmi &#34;asserviti&#34; al programma principale e si suddividono in funzioni, cioè restituiscono un valore al chiamante, e procedure, cioè non restituiscono uno specifico valore (restituiscono void). I vantaggi dei sottoprogrammi sono: astrazione, cioè si può far riferimento in modo sintetico a operazioni complesse, e riusabilità, infatti consentono di scrivere una sola volta il codice ed usarlo più volte. I sottoprogrammi infatti consistono in righe di codice più o meno complesse, che una volta scritte possono essere riutilizzate semplicemente invocandoli nel main.</answer_text><num_votes>4</num_votes></answer><answer id="A3160"><answer_text>I sottoprogrammi sono blocchi di istruzioni che permettono di semplificare la scrittura e la fase di debugging relativa ad un programma.
In particolare, tramite l&#39;utilizzo di sottoprogrammi è possibile far riferimento a determinate sequenze di istruzioni utilizzando semplicemente l&#39;identificatore assegnatogli, passandogli le eventuali variabili.
Inoltre, un sottoprogramma può eventualmente essere utilizzato anche da diversi programmi, evitando così al programmatore la necessità di doverlo scrivere nuovamente.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3133"><question_text>Di cosa si parla, quando si usa una funzione INLINE????	</question_text><answer id="A3255"><answer_text>Premettendo alla definizione di una funzione lo specificatore &#34;inline&#34;, si espande ogni chiamata di una funzione con il codice di implementazione della funzione stessa. L&#39;uso di inline permette di eliminare il sovraccarico di lavoro dovuto alla gestione della comunicazione fra programma e funzione.</answer_text><num_votes>2</num_votes></answer><answer id="A3175"><answer_text>Il risultato di una funzione inline e&#39; simile a quello di una funzione macro, ma con controllo dei tipi. 
In entrambi i casi l&#39;esecuzione e&#39; piu&#39; veloce che con una funzione non inline, in quanto non c&#39;e chiamata di funzione a run-time.
Le funzioni inline sono piu&#39; sicure delle funzioni macro.
Il codice di una funzione inline, sarà riprodotto nel punto di chiamata ogni volta che viene chiamata la funzione.
Una funzione inline contiene poche righe di codice e non presenta loop.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3270"><question_text>Per quale motivo due variabili interne a due funzioni diverse contenute nello stesso programma possono avere lo stesso nome?</question_text><answer id="A3192"><answer_text>In un programma è presente un ambiente globale, nel quale tutti gli elementi possono essere &#34;visti&#34; dalle varie funzioni facenti parte del programma.
Ogni funzione, invece, si trova in un AMBIENTE LOCALE diverso; quindi, gli elementi di una funzione possono essere usati e referenziati solo nel suo ambiente, senza essere visti dalle altre funzioni.
E&#39; per questo che è permesso dichiarare due variabili con lo stesso nome purchè in ambienti diversi.</answer_text><num_votes>2</num_votes></answer><answer id="A3165"><answer_text>possono avere lo stesso nome perchè una funzione riconosce come variabili esistenti solamente quelle interne a se stessa e quelle globali (dichiarate prima del main).
Infatti una variabile non globale è locale alla funzione in cui è definita, (esistente solo nella stessa)quindi non collide con quella dichiarata nel main, però attenzione, tutto ciò è valido solo se non si utilizzano variabili globali, in tal caso la variabile
è presente in tutto il programma, e non mi permette di creare altre variabili con
lo stesso nome.</answer_text><num_votes>3</num_votes></answer><answer id="A3254"><answer_text>Perchè quando viene definita una funzione si crea in memoria una specie di contenitore appartente a una funzione specifica per questo motivo ogni variabile locale definita all&#39;interno della funzione può avere lo stesso nome .Si creano con 2 funzioni per esempio  2 blocchi che possono contenere lo stesso nome del variabile dell&#39;altra funzione ma per il computer sono due variabile diversi ,con diversi compiti, proprio perchè appartengono ai due blocchi diversi .Solo la variabile globale definita all&#39;inizio del programma può intercettare con tutti i blocchi delle funzioni.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3277"><question_text>Il parametro della funzione che sta nel main deve essere per forza uguale al parametro della definizione della  funzione stessa ?</question_text><answer id="A3197"><answer_text>No, i parametri possono avere nomi differenti, purchè siano del tipo dichiarato.
I parametri presenti nella definizione della funzione sono parametri formali, che al momento della chiamata della funzione vengono sostituiti con i parametri effettivi, quelli specificati nel main.
Se ad esempio una funzione è definita come

void funzione(int a, int b);

la chiamata, all&#39;interno del main, può anche avere forma diversa, come ad esempio

int datoA,datoB;
funzione(datoA,datoB);

La funzione, in fase di esecuzione, sostituirà i parametri effettivi datoA e datoB con quelli formali a e b </answer_text><num_votes>4</num_votes></answer><answer id="A3262"><answer_text>Il parametro della funzione che sta nel main può differire dal parametro della funzione stessa. Una funzione che sta all&#39;interno del main è indipendente rispetto al main stesso e i parametri (argomenti) hanno un valore locale rispetto alla funzione richiamata.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3186"><question_text>Quando ha senso che una funzione ritorni un tipo di dato &#34;void&#34;?</question_text><answer id="A3156"><answer_text>Quando la funzione non restituisce nessun valore</answer_text><num_votes>0</num_votes></answer><answer id="A3147"><answer_text>Quando la funzione non restituisce nessun dato al programma principale (main), quindi a schermo viene stampata la funzione ma non viene memorizzata nel main.</answer_text><num_votes>1</num_votes></answer><answer id="A3195"><answer_text>Quando si dichiara che la funzione o meglio procedura (essendo che non ritorna nessun valore), con il tipo void (cioè vuoto), la posso utilizzare ad esempio quando voglio modificare il valore di alcune variabili o per implementare una funzione di stampa:

void stampa(int x){
  printf (&#34;x=%d&#34;,x);
} 

In ogni caso quando non mi interessa che la funzione ritorni &#34;qualcosa&#34;.</answer_text><num_votes>2</num_votes></answer><answer id="A3161"><answer_text>La funzione &#34;void&#34;, gia&#39; disponibile nel linguaggio C, non ritorna alcun tipo di dato, viene inizializzata in questo modo: void NomeFunzione();
Un esempio molto utilizzato e&#39; la funzione &#34;Stampa&#34;, implementata in base alle necessita&#39; del programma, che non deve svolgere un operazione con delle variabili o dei dati precedentemente definiti, ma azioni senza ritornare un risultato.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3178"><question_text>Che differenze ci sono tra il main e una funzione?</question_text><answer id="A3242"><answer_text>Le funzioni sono blocchi di istruzioni che possono essere invocate in diversi punti del programma senza dover essere riscritte ogni volta. Possono essere considerate dei sottoprogrammi rispetto alla funzione principale che e&#39; rappresentata dal main. In questo vengono richiamate le funzioni. E&#39; importante tenere presente che sebbene il main sia una funzione, non e&#39; possibile richiamarla in altre parti del programma.</answer_text><num_votes>4</num_votes></answer><answer id="A3218"><answer_text>La funzione main() deve sempre essere presente in un programma C ed e&#39; la prima funzione a cui viene passato il controllo.
Nel linguaggio C non si possono definire funzioni all&#39;interno di altre funzioni, quindi all&#39;interno del main si potrà solo invocarle.
Il programma termina con il termine della funzione main(), oppure quando viene invocata la funzione exit() della libreria standard.</answer_text><num_votes>1</num_votes></answer><answer id="A3206"><answer_text>Il main è la funzione principale di un programma, all&#39;interno della quale avviene la chiamata alle altre funzioni; quindi affinchè un  programma sia eseguibile deve contenere necessariamente la funzione main, e le eventuali altre funzioni entreranno in gioco solo se e quando richiamate nel main.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3227"><question_text>è possibile in un programma avere due funzioni main??</question_text><answer id="A3153"><answer_text>No, non è possibile.</answer_text><num_votes>0</num_votes></answer><answer id="A3183"><answer_text>No; se il compilatore, durante l&#39;esecuzione del programma, trova due o più funzioni main in contemporanea, dà errore poiché può eseguirne soltanto una.
Esistono metodi per avere più funzioni main nello stesso programma ma bisogna ricorrere  a delle strategie per farne eseguire una o l&#39;altra
come per esempio: -&#62;
////////////////////////////
#define MAIN1
#include &#60;iostream&#62;

using namespace std;

#ifdef MAIN1
int main()                           //main 1
{
[...]return 0;
}
#else
int main()                            //main 2
{
[...]return 0;
}
#endif 
/////////////////////
</answer_text><num_votes>3</num_votes></answer><answer id="A3257"><answer_text>La funzione main è la f?unzione che viene eseguita all&#39;inizio del programma. Essa può avere degli argomenti e deve restituire un valore.
Nessun&#39;altra funzione nel programma deve avere il nome main.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3262"><question_text>Perchè per passare ad una funzione una matrice si devono indicare le dimensioni di 
quest&#39;ultima,come nel seguente caso: 
void init(int m[R][C], int dim);
mentre volendo passare un vettore ciò non è necessario(void init(int v[],int dim))?</question_text><answer id="A3146"><answer_text>Passando semplicemente un vettore (quindi composto da una lista di elementi raggruppati su un&#39;unica riga), al calcolatore basta scorrere gli elementi su questa riga e quindi gli basta sapere la posizione iniziale del primo elemento; invece passando una matrice (quindi elementi raggruppati su più righe) il calcolatore deve fare delle operazioni di somma degli offset con doppi puntatori e quindi deve sapere la dimensione massima di righe e colonne di cui è composta la matrice.</answer_text><num_votes>0</num_votes></answer><answer id="A3181"><answer_text>Nel passaggio di una matrice in una funzione è sempre necessario specificare la dimensione della riga [C], invece la [R] non è davvero necessaria.
Passando un array nel modo da te indicato riesco a calcolare l&#39;indirizzo di un qualsiasi elemento di questo array (basta infatti sommare all&#39;indirizzo un multiplo della dimensione del tipo). 
Si può pensare a un array bidimensionale come un array i cui elementi sono le righe; per questo motivo è necessario conoscere la lunghezza delle righe [NC].</answer_text><num_votes>0</num_votes></answer><answer id="A3144"><answer_text>Passando semplicemente un vettore (quindi composto da una lista di elementi raggruppati su un&#39;unica riga), al calcolatore basta scorrere gli elementi su questa riga e quindi gli basta sapere la posizione iniziale del primo elemento; invece passando una matrice (quindi elementi raggruppati su più righe) il calcolatore deve fare delle operazioni di somma degli offset con doppi puntatori e quindi deve sapere la dimensione massima di righe e colonne di cui è composta la matrice</answer_text><num_votes>1</num_votes></answer><answer id="A3142"><answer_text>Passando semplicemente un vettore (quindi composto da una lista di elementi raggruppati su un&#39;unica riga), al calcolatore basta scorrere gli elementi su questa riga e quindi gli basta sapere la posizione iniziale del primo elemento; invece passando una matrice (quindi elementi raggruppati su più righe) il calcolatore deve fare delle operazioni di somma degli offset con doppi puntatori e quindi deve sapere la dimensione massima di righe e colonne di cui è composta la matrice</answer_text><num_votes>0</num_votes></answer><answer id="A3145"><answer_text>Passando semplicemente un vettore (quindi composto da una lista di elementi raggruppati su un&#39;unica riga), al calcolatore basta scorrere gli elementi su questa riga e quindi gli basta sapere la posizione iniziale del primo elemento; invece passando una matrice (quindi elementi raggruppati su più righe) il calcolatore deve fare delle operazioni di somma degli offset con doppi puntatori e quindi deve sapere la dimensione massima di righe e colonne di cui è composta la matrice.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3233"><question_text>Nelle funzioni cosa implica la parola chiave &#34;const&#34;? In che casi è opportuno utilizzarla?</question_text><answer id="A3223"><answer_text>Const serve a indicare al compilatore che una certa variabile non può essere modificata durante l&#39;esecuzione del programma,viene anche utilizzata nelle funzioni:
-void stampa(..)const {..}
-void funz(const../const*..){..} 
nel primo caso si riferisce al contenuto,nel secondo alla variabile passata per copia o per indirizzo.Le variabili e/o indirizzi sono quindi di SOLA lettura e in fase di compilazione un messaggio di errore comunicherà un eventuale modifica E&#39; opportuno utilizzarlo per evitare risultati corrotti dovuti alla modifica del dato iniziale, errore difficilmente rintracciabile.</answer_text><num_votes>1</num_votes></answer><answer id="A3201"><answer_text>La parola chiave &#34;const&#34; viene utilizzata per evitare di cambiare il contenuto di una variabile mentre questa viene, ad esempio, stampata. Utilizzando const passo quindi un dato di sola lettura, se questo viene modificato, verrà segnalato errore.</answer_text><num_votes>1</num_votes></answer><answer id="A3199"><answer_text>La parola chiave const può qualificare una funzione membro impedendogli qualsiasi modifica della classe di origine.
Ad esempio se dichiaro nella classe &#34;auto&#34; una &#34;funzione()const&#34; essa non potrà modificare alcun valore delle variabili interne.
Le funzioni const sono utili in quanto evitano l&#39;accidentale modifica dei parametri che potrebbero introdurre errori nel programma(ad esempio se il programma viene usato da più persone che non sanno quali parametri possono essere modificati)</answer_text><num_votes>1</num_votes></answer><answer id="A3269"><answer_text>Se prima di specificare un tipo di variabile si premette ?const? il contenuto della variabile non può più essere modificato. Una variabile ?const? deve sempre essere inizializzata.
L&#39;uso di const è consigliato rispetto all&#39;alternativa di scrivere più volte la stessa costante, infatti se il programmatore decide di cambiarne il valore durante la compilazione del programma e ha usato const, è sufficiente che modifichi la sola istruzione di definizione.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3159"><question_text>cosa accade in memoria quando nel main richiamo 2 funzioni (una dietro l&#39;altra)? 
E cosa succede (sempre in memoria) quando il programma termina?</question_text><answer id="A3167"><answer_text>Viene creata la macchina dedicata della prima funzione e allocata la relativa memoria. La memoria è organizzata a pila quindi l&#39;ultima macchina creata è la prima ad essere distrutta. Quando la prima funzione termina la sua macchina dedicata viene distrutta e la sua memoria deallocata.
La stessa cosa accade anche per la seconda funzione.
Quando termina il main la sua macchina virtuale viene distrutta e la sua memoria deallocata perché anch&#39;esso è una funzione. La regola della pila è rispettata, infatti la macchina del main viene creata per prima e distrutta per ultima.
</answer_text><num_votes>3</num_votes></answer><answer id="A3180"><answer_text>La zona di memoria che viene creata per una singola funzione viene detta &#34;record di attivazione&#34;. Quando richiamo le due funzioni, si crea in memoria due record di attivazione contenenti i relativi parametri formali delle funzioni e le relative variabili locali del programma. Quando il programma termina, i record di attivazione creati in precedenza vengono cancellati perché le variabili dichiarate non servono più e si può liberare la memoria.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3192"><question_text>in che modo viene passato un matrice ad una funzione? e perchè?</question_text><answer id="A3135"><answer_text>Innanzitutto occorre chiarire che una funzione/procedura può restituire un solo valore; per questo motivo non può restiture nemmeno un array n-dimensionale (quindi anche una matrice); ci sono 2 modi per passare un array ad una funzione:
1)passando l&#39;indirizzo di base dell&#39;array: la procedura agisce direttamente sull&#39;array originario (guadagnando in velocità e in risparmio di memoria rispetto al copiare l&#39;intera struttura contenente l&#39;array nello spazio di memoria riservato alla funzione come nel caso successivo)
2)inglobando l&#39;array in una struttura e passando l&#39;intera struttura</answer_text><num_votes>1</num_votes></answer><answer id="A3219"><answer_text>Per passare una matrice come parametro di una funzione, dovrò passare alla funzione un parametro intero, specificando il numero di riga e di colonna della matrice.
Ad esempio, prendiamo la matrice &#34;int m[3][4]&#34; e la funzione &#34;void funzione(int m)&#34;, se si decide di passare alla funzione un parametro che è una matrice opererò nel seguente modo: &#34;void funzione(m[2][3])&#34;. In questo caso viene passato alla funzione un valore intero, situato nella seconda riga e terza colonna della matrice.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3206"><question_text>In C si possono definire due tipi di sottoprogrammi: funzioni e procedure. Quali sono le differenze tra i due?</question_text><answer id="A3186"><answer_text>Il compito delle funzioni è restituire un valore al chiamante, come nel caso delle funzioni matematiche. Le procedure invece svolgono un compito per il chiamante ma non restituiscono un valore specifico, restituendo void.
</answer_text><num_votes>1</num_votes></answer><answer id="A3256"><answer_text>Le funzioni in C ritornano un valore dopo averlo ottenuto con una serie di operazioni mentre le procedure non ritornano nulla m eseguono solo operazioni ad esempio la stampa a video di una serie di parametri</answer_text><num_votes>0</num_votes></answer></question><question id="Q3153"><question_text>Che differenza c&#39;è fra passaggio di parametri per valore e passaggio di parametri per indirizzo? </question_text><answer id="A3236"><answer_text>Se ad una funzione viene passato un parametro per valore allora il valore del parametro effettivo (cioè quello con il quale la funzione viene attivata) viene copiato nella variabile della funzione chiamata che rappresenta il parametro formale (cioè l&#39;argomento della funzione elencato nella testa). Con il passaggio per indirizzo invece la funzione invocata riceve un puntatore al parametro effettivo.</answer_text><num_votes>0</num_votes></answer><answer id="A3202"><answer_text>Quando si utilizza il passaggio per valore, ad esempio in una funzione, viene passata una copia dell&#39;argomento, mentre quando si passa il valore per indirizzo viene passato appunto l&#39;indirizzo della locazione di memoria dell&#39;argomento. La differenza tra i due metodi sta nel fatto che il passaggio per valore fa una copia (e quindi utilizza più memoria) della variabile; al contrario il passaggio per indirizzo occupa meno memoria perchè appunto si passa l&#39;indirizzo della cella puntata. </answer_text><num_votes>0</num_votes></answer><answer id="A3205"><answer_text>Quando il passaggio dei parametri avviene per valore, alla funzione viene in effetti passata solo una copia dell?argomento. Grazie a questo meccanismo il valore della variabile nel programma chiamante non viene modificato. In passaggio di parametri per riferimento, alla funzione viene passato l?indirizzo e non il valore dell?argomento. </answer_text><num_votes>0</num_votes></answer><answer id="A3200"><answer_text>Nel passaggio di parametri per valore la copia e&#39; inefficente se il parametro e&#39; ingombrante, il parametro effettivo e formale occupano zone distinte di memoria mentre nel passaggio di parametri per indirizzo c&#39;e&#39; la modifica del parametro effettivo e copia indirizzo della variabile.</answer_text><num_votes>0</num_votes></answer><answer id="A3190"><answer_text>Il passaggio di parametri per valore copia l&#39;intero valore della variabile in questione, il passaggio per indirizzo invece copia solamente l&#39;indirizzo di questa variabile (ovvero l&#39;indirizzo della cella di memoria), con un risparmio di memoria e tempo di calcolo.
Bisogna ricordarsi però che se si perde l&#39;indirizzo della variabile e non se ne ha una copia non saràpiù possibile recuperarla, mentre passando il valore basterà ricordare l&#39;identificatore assegnato.</answer_text><num_votes>0</num_votes></answer><answer id="A3231"><answer_text>Nel passaggio per valore si esegue e si fornisce alla funzione, come variabile locale, una copia del dato sul quale operare. Si occupa nuovo spazio in memoria fino al termine della sua esecuzione. Nel caso di passaggio per riferimento (per indirizzo) si fornisce l&#39;indirizzo di memoria nel quale il dato è allocato ovvero il puntatore a quel dato. Questo sistema presenta evidenti vantaggi (fra i più importanti anche quello di essere l&#39;unico possibile con le array, fra le quali non è possibile l&#39;assegnazione) ma, a meno dell&#39;utilizzo di &#34;const&#34;, rende possibili modifiche indesiderate al valore.</answer_text><num_votes>3</num_votes></answer></question><question id="Q3216"><question_text>Perchè il passaggio di strutture alle funzioni conviene farlo per riferimento anzichè per copia?</question_text><answer id="A3234"><answer_text>Nel passaggio per riferimento viene passato alla funzione un puntatore alla struttura (o più in generale ad una variabile). Se la funzione modifica la struttura queste modifiche sono permanenti cosa che non accade passando la struttura per copia. Infatti in questo caso alla funzione viene passata una copia della struttura e le modifiche che vengono fatte a tale copia non si ripresentano nella struttura originale e vanno perse al termine della funzione, a meno che la struttura non venga ritornata dalla funzione. </answer_text><num_votes>2</num_votes></answer><answer id="A3215"><answer_text>il passaggio di una variabile qualsiasi (strutturata o meno) ad una funzione implica sempre la copia di questa variabile. Quindi, soprattutto nel caso di variabili strutturate, conviene passare la variabile per riferimento invece che per indirizzo poichè in questo modo viene copiato solo l&#39;indirizzo della variabile e non tutto il suo valore, con conseguente risparmio di memoria.</answer_text><num_votes>1</num_votes></answer><answer id="A3216"><answer_text>il passaggio di una variabile qualsiasi (strutturata o meno) ad una funzione implica sempre la copia di questa variabile. Quindi, soprattutto nel caso di variabili strutturate, conviene passare la variabile per riferimento invece che per indirizzo poichè in questo modo viene copiato solo l&#39;indirizzo della variabile e non tutto il suo valore, con conseguente risparmio di memoria.</answer_text><num_votes>2</num_votes></answer><answer id="A3155"><answer_text>Conviene da un punto di vista dell&#39;allocazione della memoria. Se per riferimento mi basta un puntatore cioè un occupazione di memoria di 1 byte, mentre per copia spreco un numero di byte pari al numero di byte occupato dalla struttura. Questo incide anche sulla velocità nell&#39;esecuzione del programma.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3146"><question_text>Cosa sono le variabili globali e come possono essere utilizzate? Quali side-effects si possono generare?</question_text><answer id="A3249"><answer_text>Le variabili globali sono chiamate così perchè la loro definizione avviene al di fuori di qualsiasi funzione (compreso il main)
L&#39;utilizzo di questo tipo di variabili è comodo se abbiamo bisogno di far lavorare delle funzioni su dei dati e vogliamo che questi non vengano cancellati alla fine della funzione (risultato simile si ha passando i dati alle funz)
I possibili side-effects sono due :consumo di memoria elevato (le variabili vengono cancellate solo alla fine del programma) e limitazione nella riusabilità del codice (le funzioni funzionerebbero solo in presenza delle variabili globali)</answer_text><num_votes>0</num_votes></answer><answer id="A3247"><answer_text>Le variabili globali sono quelle variabili che vengono dichiarate all&#39;inizio del programma, al di fuori di qualsiasi funzione.
Esse sono visibili da tutte le funzioni presenti nel programma, cioè posso essere utilizzate e quindi modificate da tutte le funzioni.
Questo potrebbe sembrare un vantaggio ma allo stesso tempo il loro uso non sempre è raccomandabile, poiché è facile che siano modificate accidentalmente (side-effect) e rendono più difficile la ricerca degli errori.</answer_text><num_votes>3</num_votes></answer><answer id="A3222"><answer_text>Le variabili globali sono quelle variabili dichiarate al di fuori di un sottoprogramma, e che quindi sono valide e visibili in tutto il progetto. L&#39;utilizzo di variabili globali non comporta forti rischi ma bisogna stare attenti a non dichiarare variabili locali uguali a quelle globali, perchè potrebbe portare a conflitti.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3158"><question_text>Che cosa succede se creo due o più funzioni con lo stesso nome, ma con i parametri formali diversi?
(es. int nomeFunz(){}
       int nomeFunz(int x){}
       int nomeFunz(int x1, int x2){}
)</question_text><answer id="A3163"><answer_text>Tale operazione in C++ è del tutto lecita (non in C). Una famiglia di funzioni di ugual nome come questa prende il nome di: &#34;Overloading&#34;. 
Esistono però dei requisiti fondamentali per il corretto funzionamento di tale operazione:
1) Il numero dei parametri formali delle diverse funzioni deve essere diverso;
2) Definizioni di funzioni con parametri uguali (in numero) e di diverso tipo vanno
    evitate.
L&#39;es. vede quindi la corretta creazione di funzioni diverse (1) ma con lo stesso nome.
N.B. Il nostro programma eseguirà la funzione appropriata a seconda del tipo di argomenti passati. </answer_text><num_votes>2</num_votes></answer><answer id="A3208"><answer_text>Nel C++, a differenza del C, è lecito avere due (o più) funzioni con lo stesso nome, ammesso però che la lista dei loro parametri formali sia differente, o che questi siano forniti in un ordine diverso (cosa fondamentale poiché permette al compilatore di distinguerle). Quando ciò succede, come mostrato nell&#39;esempio sopra, si verifica il cosiddetto &#34;sovraccaricamento&#34; (overloading) di un nome di funzione. Le funzioni sovraccaricate vengono utilizzate esattamente come le funzioni normali ed è compito del compilatore decidere quale versione di &#34;nomeFunz&#34; utilizzare, in base ai parametri forniti.</answer_text><num_votes>1</num_votes></answer><answer id="A3241"><answer_text>risulterà un errore in quanto si crea confusione nel richiamo della cella.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3174"><question_text>Quali sono i vantaggi che si possono avere strutturando un progetto in tre diversi file : il &#34;.h&#34; il &#34;main&#34; e il &#34;.cpp&#34;?</question_text><answer id="A3439"><answer_text>La separazione del codice in librerie permette di spezzare i programmi in parti separate, con ovvio riuso delle stesse ed aumento della leggibilità/comprensione del programma. La libreria statica consente di collegare il codice contenuto (funzioni/tipi/classi/costanti/etc) staticamente ad un eseguibile, questo collegamento avviene in fase di compilazione.</answer_text><num_votes>0</num_votes></answer><answer id="A3203"><answer_text>I file &#34;.cpp&#34; che contengono l&#39;implementazione del codice possono essere compilati a parte e non hanno bisogno di altre compilazioni a meno che non li si modifichi, velocizzando la fase di compilazione. altro vantaggio è la mantenibilitá del codice, che permette di suddividere facilmente il lavoro in caso si decia di programmare in team.</answer_text><num_votes>2</num_votes></answer><answer id="A3125"><answer_text>Vantaggi:
- riutilizzo del file per diversi progetti;
- facilità di portare avanti un progetto in un team composto da più persone;
- Materiale condivisibile;
...</answer_text><num_votes>0</num_votes></answer><answer id="A3224"><answer_text>Innanzitutto il fatto di avere tre file diversi porta un ordine maggiore nel progetto (fondamentale quando si comincia a fare programmi complessi), e come secondo vantaggio si ha la possibilità di utilizzare l&#39; insieme di funzioni di un file definendolo come libreria all&#39;interno di un qualsiasi altro progetto.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3128"><question_text>è possibile che una funzione restituisca un array? nel caso in cui non fosse possibile esiste una soluzione per poterlo fare?</question_text><answer id="A3214"><answer_text>Non è possibile che una funzione restituisca un array perché questo viene trattato dal programma come un puntatore.
Una soluzione a questo problema è utilizzare il double (RICORDA double mul(double a[], int n) {?.}), inoltre si può utilizzare struct anche se questo comporta alcuni rischi: che gli array vengono passati per indirizzo o per valore e questo metodo è dispendioso dal punto di vista dell&#39;ingombro di memoria.</answer_text><num_votes>1</num_votes></answer><answer id="A3184"><answer_text>In C/C++ non è possibile creare una funzione che restituisca un array in quanto, una volta usciti dalla funzione, verrebbe a mancare il riferimento al puntatore che abbiamo ritornato. Una soluzione possibile è quella di creare un nuovo tipo struttura (struct) che contenga al suo interno un array, quindi implementare la funzione in modo che ritorni un&#39;istanza di quel tipo struttura. Esempio: 
typedef struct miaStruttura{ 
int mioArray[N];
};
miaStruttura funzione() {
miaStruttura daRitornare;
[...]
return daRitornare;
}
Troveremo il nostro array all&#39;interno della struttura ritornata.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3256"><question_text>L&#39;utilizzo di una funzione porta ad una consistente diminuzione dell&#39;allocazione di memoria?</question_text><answer id="A3263"><answer_text>Utilizzare funzioni in un programma rende più semplici la lettura ed eventuale modifica del codice ad altri programmatori rispetto ad un mucchio di istruzioni nella sola funzione &#39;main&#39;. Essendo il C++ un linguaggio di alto livello, non è compito del programmatore allocare in memoria le funzioni. Basti pensare alla funzione main o a quelle di libreria (contenute ad esempio in &#60;iostream&#62;) che non necessitano di essere allocate ma solo dichiarate, anche in una libreria esterna da includere. La quantità di memoria da allocare dipenderà esclusivamente dall&#39;oggetto che si vuole allocare.</answer_text><num_votes>3</num_votes></answer><answer id="A3212"><answer_text>Una funzione occupa memoria soltanto nel momento in cui viene invocata e finisce di esistere a compito terminato quindi non si può dire che vi è una consistente diminuzione dell&#39;allocazione di memoria.</answer_text><num_votes>0</num_votes></answer><answer id="A3158"><answer_text>NO!
Le funzioni servono solo per tenere il codice pulito e applicare la programmazione top-down. Se si passano più di 2 o 3 parametri anziche&#39; scrivere sui registri si scrive in RAM.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3284"><question_text>Dare una definizione di funzione (nel campo informatico), soffermarsi in particolare sulla sintassi della testata e del corpo.</question_text><answer id="A3243"><answer_text>La definizione di una funzione basata sulla specifica iniziale della sintassi del linguaggio, si presenta nella seguente forma:
  tiporitornato nomefunzione(lista_parametri)
                  dichiarazione_parametri
    {
    definizioni/dichiarazioni
    lista_statement
    } 
Se il tiporitornato non viene specificato, per default viene assunto di tipo int.
Se la funzione non ritorna alcun risultato. allora tiporitornato deve essere specificato di tipo void.
  int fattoriale(n)
        int n;
    {
    if (n &#62; 1)
      return n*fattoriale(n-1);
  }</answer_text><num_votes>0</num_votes></answer><answer id="A3213"><answer_text> La definizione di una funzione è composta da: 
1)Una testata (o header), che contiene informazioni rilevanti ai fini di un uso corretto della funzione e cioè:1)Tipo del risultato (il codominio della funzione);2)Identificatore del sottoprogramma;3)Lista di dichiarazioni degli argomenti della funzione (il dominio della funzione);
2)Un blocco, detto corpo (o body) della funzione;
Il corpo della funzione è composto da:
-Una parte dichiarativa, detta parte dichiarativa locale, che contiene le variabili necessarie all esecuzione;
-Una parte programmatica, con le istruzioni del corpo.</answer_text><num_votes>5</num_votes></answer></question><question id="Q3230"><question_text>A cosa serve il tipo di dato void?</question_text><answer id="A3139"><answer_text>Il tipo di dato &#34;void&#34; (vuoto) è usato nelle funzioni che non necessitano di ritornare alcun valore, il queste funzioni non sarà necessario utilizzare il comando &#34;return&#34;.
Un esempio tipico di una funzione che è classificata come void è una funzione di stampa, che non deve ritornare nessun dato se non stampare a video dei valori.</answer_text><num_votes>3</num_votes></answer><answer id="A3265"><answer_text>Il tipo di dato void (o tipo indefinito) viene utilizzato quando il valore di ritorno di una funzione non deve essere preso in considerazione; se viene dichiarata di tipo void la funzione non necessita del comando return e non ritorna quindi alcun valore.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3274"><question_text>Cosa si intende per &#34;macchina dedicata&#34;, come e quando viene realizzata?</question_text><answer id="A3196"><answer_text>Una macchina dedicata viene realizzata all&#39;invocazione di una funzione. Questa crea una propria memoria contenente le variabili della funzione, utilizzate solo all&#39;interno di questa (locali),i parametri (gestiti come variabili locali, inizializzate all&#39;atto della chiamata) e il risultato della funzione. La memoria viene distrutta alla terminazione della funzione.
Per esempio invocando la funzione
void f1 () {printf (&#34;%d&#34;,x);}
nel
main () {f1();};
ci sarà una macchina dedicata alla funzione void che esegue le istruzioni e passa alla macchina principale i parametri &#34;per copia&#34;.</answer_text><num_votes>2</num_votes></answer><answer id="A3237"><answer_text>Con il termine &#34;macchina dedicata&#34; si intende un ambiente dedicato a 
compiere determinate operazioni. Queste macchine dedicate vengono realizzate 
quando, ad esempio, si vuole invocare una funzione; tale funzione viene invocata 
tramite un void.</answer_text><num_votes>0</num_votes></answer><answer id="A3248"><answer_text>La macchina dedicata è un ambiente dotato di una propria memoria, il cui unico scopo sia l&#39;esecuzione di determinate funzioni. Nella pratica, i computer hanno un&#39;unica memoria e un&#39;unica CPU. Per realizzare una macchina dedicata si ricorre quindi ad un sistema LIFO: la stessa macchina che esegue un programma mette in pausa l&#39;esecuzione dello stesso, alloca un determinato spazio in memoria ed esegue il sottoprogramma. Al termine la memoria viene recuperata, l&#39;ambiente rimosso dalla pila e riprende l&#39;esecuzione del programma principale.</answer_text><num_votes>0</num_votes></answer><answer id="A3129"><answer_text>Una macchina dedicata è un oggetto fisico o virtuale che si occupa di svolgere una sola funzione. 
Può essere realizzata tramite una struttura LIFO (o FIFO) e viene realizzata quando è necessario che una funzione nasca e muoia all&#39;interno del maine ma prima che si concluda il programma.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3253"><question_text>Qual&#39;è la differenza tra variabili &#34;statiche&#34; , variabili &#34;dinamiche&#34; , e variabili &#34;automatiche&#34;?</question_text><answer id="A3171"><answer_text>Le variabili statiche sono&#38;#8239;allocate una sola volta e distrutte al termine dell?esecuzione del programma,(lo sono quelle globali) e&#38;#8239;fungono da canali di comunicazione tra funzioni.
Le variabili dinamiche vengono create e distrutte dinamicamente implicitamente dal sistema (automatiche) o esplicitamente dal programmatore, con appositi costrutti.
Le variabili automatiche sono create quando il flusso di esecuzione entra nel loro ambito di visibilità e distrutte all?uscita da tale ambito; vengono dichiarate nelle funzioni (inclusi parametri).
</answer_text><num_votes>1</num_votes></answer><answer id="A3177"><answer_text>Le variabili &#34;statiche&#34; (o &#34;automatiche&#34;) vengono inizializzate all&#39;inizio di un programma o di un blocco di programma e quando questo blocco si chiude, esse vengono distrutte automaticamente. Le variabili &#34;dinamiche&#34; vengono inizializzate e distrutte tramite delle apposite istruzioni (new, delete) indipendentemente dalla struttura del programma e, al contrario delle variabili &#34;statiche&#34;, la loro dimensione può variare durante l&#39;esecuzione di un programma. La zona di memoria dedicata alle variabili dinamiche è chiamata &#34;heap&#34; l&#39;accesso è quindi effettuato tramite puntatore.</answer_text><num_votes>1</num_votes></answer><answer id="A3127"><answer_text>Una variabile è detta automatica (o dinamica), se cessa di esistere non appena il flusso del programma esce dalla funzione in cui la variabile è definita.
Una variabile è detta statica se il suo &#34;tempo di vita&#34; coincide con l&#39;intera durata del programma: quando il flusso del programma torna nella funzione in cui è definita una variabile statica, ritrova la variabile come l&#39;aveva lasciata (cioè con lo stesso valore).
Esiste anche, per le variabili automatiche, lo specificatore auto, ma è inutile in quanto di default (può essere usato per migliorare la leggibilità del programma).</answer_text><num_votes>1</num_votes></answer><answer id="A3128"><answer_text>Una variabile è detta automatica (o dinamica), se cessa di esistere non appena il flusso del programma esce dalla funzione in cui la variabile è definita.
Una variabile è detta statica se il suo &#34;tempo di vita&#34; coincide con l&#39;intera durata del programma: quando il flusso del programma torna nella funzione in cui è definita una variabile statica, ritrova la variabile come l&#39;aveva lasciata (cioè con lo stesso valore).
Esiste anche, per le variabili automatiche, lo specificatore auto, ma è inutile in quanto di default (può essere usato per migliorare la leggibilità del programma).
</answer_text><num_votes>0</num_votes></answer></question><question id="Q3243"><question_text>Qual&#39;è la differenza fra Testata (Head) della funzione e Corpo (Body)? In un programma suddiviso in più file (es: main.cpp, funzioni.h, funzioni.cpp), dove va collocata la Testata e dove il Corpo?</question_text><answer id="A3170"><answer_text>La testata di una funzione è la parte dove sono presenti le dichiarazioni, in cui vi è il tipo di dato della funzione (int,void,char),il nome della funzione e i parametri in ingresso, invece il body contiene le variabili locali e una parte con il codice. La testata di una funzione e il suo contenuto vanno sempre dichiarate nel file header(funzioni.h), e la sua definizione che comprende sia head che body va inserita nel file .cpp (funzioni.cpp).</answer_text><num_votes>1</num_votes></answer><answer id="A3173"><answer_text>la testata va collocata in funzioni.h e è del tipo 
tipodatoritornato nomefunzione (input) ;
il body va collocato nel funzioni.cpp ed è del tipo 
tipodatoritornato nomefunzione (input) {
azionedellafunzione
}</answer_text><num_votes>0</num_votes></answer></question><question id="Q3160"><question_text>È possibile che una funzione richiami se stessa? Se si quale nome assume e quali caratteristiche deve avere?</question_text><answer id="A3261"><answer_text>Sì, assume il nome di funzione ricorsiva che per svolgere il proprio lavoro richiama sè stessa. Ad ogni richiamo la &#34;profondità&#34; dell&#39;elaborazione aumenta, finchè ad un certo punto, lo scopo viene raggiunto e la funzione ritorna. Il tipico esempio di una funzione Ricorsiva è la visualizzazione di dati in strutture gerarchiche, per esempio la visualizzazione dei file contenuti in una directory. Viene creata una funzione &#39;generica&#39; che legge una directory e visualizza ogni file. Se il file è una directory, la funzione richiama sè stessa usando directory trovata come parametro.</answer_text><num_votes>1</num_votes></answer><answer id="A3159"><answer_text>Si, nel linguaggio di programmazione C è ammessa la chiamate ricorsiva di sottoprogrammi. Nella programmazione ricorsiva viene associata un&#39;area dati non al sottoprogramma ma a ogni sua esecuzione, chiamata record di attivazione.</answer_text><num_votes>2</num_votes></answer></question><question id="Q3136"><question_text>Cos&#39;è una variabile automatica e come può essere implementata (scrivere un esempio di codice)?</question_text><answer id="A3225"><answer_text>Variabile automatica in C e C++ è sinonimo di variabile locale. Essa vive dal punto in cui viene definita fino alla fine del blocco &#34;}&#34;. La memoria viene riservata tramite un instruzione di definizione come &#60;tipo&#62; &#60;nomevariabile&#62;; dove &#60;tipo&#62; è un tipo di variabile (int char float...) e il nome variabile è una sequenza di caratteri attraverso cui sarà possibile accedere all&#39;area di memoria riservata.
Esempio codice:
...{
int a=0; //definizione di a variabile locale o automatica
a++; //operazione su a
...
} //fine blocco: la memoria riservata ad a viene deallocata
...</answer_text><num_votes>3</num_votes></answer><answer id="A3126"><answer_text>una variabile automatica è una variabile dichiarata all&#39;interno di una funzione (o perlomeno dichiarata in un &#34;blocco&#34; racchiuso da parentesi graffe); in pratica viene allocata una parte di memoria in maniera dinamica
esempio:
void main(void){
      int x = 1;
      printf(&#34;%d, %d&#34; ,x);
}
dove x è una variabile automatica</answer_text><num_votes>0</num_votes></answer></question><question id="Q3281"><question_text>Quali sono i 3 casi della complessità dell&#39; input e spiegane il funzionamento.</question_text><answer id="A3240"><answer_text>Complessità nel caso peggiore, nel caso medio e nel caso migliore.
1)Il caso migliore è il caso in cui i dati in input sono i migliori dati possibili per     l&#39;algoritmo, cioè quelli che richiedono meno elaborazioni per essere trattati.
2)Il caso medio permette di studiare l&#39;algoritmo in base alla frequenza con cui si        verificano gli input e alla complessità di ciascuno di essi.E&#39; il più utile da analizzare in quanto fornisce un reale indicatore della complessità dell&#39;algoritmo.
3)Il caso peggiore è il caso in cui i dati in input  richiedono il massimo numero di passi per l&#39;algoritmo.</answer_text><num_votes>3</num_votes></answer><answer id="A3211"><answer_text>Negli algoritmi di ricerca esistono tre casi di complessità, e sono:
-Il caso peggiore è il caso in cui il numero di ricerche corrisponde al numero di elementi e quindi impieghiamo un tempo che è pari a N (numero elementi).
-Il caso migliore è il caso in cui l&#39;elemento cercato è il primo della lista e quindi impieghiamo un tempo unitario per la ricerca.
-Il caso medio è il più difficile da calcolare, perché dipende dall&#39;algoritmo utilizzato nella ricerca
Ad esempio nella ricerca lineare corrisponde a N/2, mentre nella ricerca binaria è pari a log2(N)</answer_text><num_votes>2</num_votes></answer></question><question id="Q3167"><question_text>Da cosa è composta la definizione di funzione? Da cosa è costituito il corpo?</question_text><answer id="A3152"><answer_text>Se per &#39;definizione di funzione&#39; si intende l&#39;&#34;header&#34;(o testata);esso contiene le informazioni relative :
-al tipo del risultato ritornato dalla funzione(es. int);
-all&#39; identificatore della funzione(nome);
-ai parametri formali della funzione identrificati da tipo e nome(quelli tra le parentesi);
es. int diff(int a,int b);
Il corpo della funzione invece è costituito da:
-una parte dichiarativa locale che contiene le variabili locali interne alla funzione.
-una parte di codice contenente le operazioni che saranno eseguite al momento dell&#39;invocazione.
</answer_text><num_votes>1</num_votes></answer><answer id="A3164"><answer_text>In C/C++ una funzione è composta da una testata (HEADER) e un corpo (BODY).

La prima, definita anche come &#34;prototipo&#34; e posta solitamente nei header-files, è costituita da:
-tipo di risultato (che deve essere unico) o specifica &#34;void&#34; (se non ritorna nessun parametro)
-nome della funzione
-argomenti o parametri formali (sostituiti da quelli effettivi al momento dell&#39;invocazione della funzione)

Il blocco del corpo è invece formato da:
-parte dichiarativa (di variabili locali necessarie all&#39;esecuzione)
-parte programmatica contente le istruzioni della vera e propria implementazione.</answer_text><num_votes>1</num_votes></answer><answer id="A3169"><answer_text>La definizione di una funzione si divide in
HEADER: dichiarato nel progetto.h con la seguente struttura: 
TipoDelRisultato NomeDellaFunzione (TipoDellArgomento Argomento); 
BODY: implementato nel progetto.c/.cpp con la seguente struttura:
HEADER{
Parte dichiarativa locale, ossia le variabili necessarie al funzionamento del sottoprogramma non specificate nell&#39;header;
Parte programmatica, ossia le istruzioni che la funzione deve compiere; 
Return VariabileDaRitornareDopoAverEffettuatoLeIstruzioni;}
Nel caso di una procedura, ossia una funzione che non ritorna nulla, prima dell&#39;header</answer_text><num_votes>1</num_votes></answer><answer id="A3168"><answer_text>La definizione di una funzione si divide in
HEADER: dichiarato nel progetto.h con la seguente struttura: 
TipoDelRisultato NomeDellaFunzione (TipoDellArgomento Argomento); 
BODY: implementato nel progetto.c/.cpp con la seguente struttura:
HEADER{
Parte dichiarativa locale, ossia le variabili necessarie al funzionamento del sottoprogramma non specificate nell&#39;header;
Parte programmatica, ossia le istruzioni che la funzione deve compiere; 
Return VariabileDaRitornareDopoAverEffettuatoLeIstruzioni;
}

Con soli 500 caratteri è difficile spiegare meglio.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3187"><question_text>Spiega brevemente i due tipi di passaggio di variabili alle funzioni: il passaggio deio parametri per valore (o copia) e quello per indirizzo</question_text><answer id="A3264"><answer_text>Il passaggio di parametri per valore è un modo molto comune per passare informazioni a una funzione ed è anche il modo normalmente utilizzato in C++.
Invece nel passaggio di parametri per riferimento (o reference), alla funzione viene passato l?indirizzo e non il valore dell?argomento. Questo approccio richiede meno memoria rispetto alla chiamata per valore, e soprattutto consente di modificare il valore delle variabili che sono ad un livello di visibilità esterno alla funzione o al metodo.
Per passaggio per indirizzo ha bisogno di passare alla funzione degli argomenti di tipo puntatore</answer_text><num_votes>2</num_votes></answer><answer id="A3204"><answer_text>Il passaggio dei parametri per valore avviene per coppia(dall&#39;ambiente main all&#39;ambiente search)con lo svantaggio che i parametri effettivi e quelli formali occupano zone diverse di memoria e che il sistema di passaggio per coppia diventa inefficiente con valori ingombranti. Il passaggio per indirizzo, invece, utilizza un parametro formale di tipo puntatore il quale non contiene i dati di una variabile ma contiene l&#39;indirizzo della cella di memoria dove essi sono contenuti e per accedervi viene usato l&#39;operatore de-referenziazione(*)che permette di accedere al contenuto della cella di memoria</answer_text><num_votes>1</num_votes></answer></question><question id="Q3145"><question_text>Quando si dichiara una funzione viene allocata una macchina nella memoria, che ha il compito di svolgere le operazioni richieste dalla funzione. Esiste però una parte di memoria esterna a tutte queste macchine chiamata ambiente globale: che cosa contiene? Cosa succede se viene modificata?</question_text><answer id="A3154"><answer_text>L&#39;ambiente globale contiene tutte le parti che compongono il programma: variabili globali, locali, sottoprogrammi. E&#39; riconducibile ad una scatola in cui vengono inseriti tanti oggetti distinti e staccati gli uni dagli altri, ma tutti indispensabili per ottenere il risultato finale.
Apportando modifiche ai singoli blocchi queste si ripercuotono solo sul sottoprogramma interessato mentre, modificando le variabili globali, si modifica ogni parte del programma principale in cui queste sono presenti. Per questo le variabili globali vanno usate solo se necessario e vanno gestite accuratamente.
</answer_text><num_votes>2</num_votes></answer><answer id="A3258"><answer_text>In C, ogni funzione ha il suo ambiente locale che 
comprende i parametri e le variabili definite 
localmente alla funzione.
Esiste però anche un ambiente globale:
quello dove tutte le funzioni sono definite. 
Qui si possono anche definire variabili, dette 
variabili globali
La denominazione &#34;globale&#34; deriva dal fatto che 
l&#39;environment di definizione di queste variabili 
non coincide con quello di nessuna funzione 
(neppure con quello del main).</answer_text><num_votes>0</num_votes></answer><answer id="A3252"><answer_text>L&#39;ambiente globale in questione è descritto come una parte di memoria in cui tutte le funzioni e le variabili vengono definite. Tali variabili sono dette appunto variabili globali. La denominazione &#34;globale&#34; deriva dal fatto che l&#39;environment di definizione di queste variabili non coincide con quello di nessuna funzione (neppure con quello del main) ma è un&#39;allocazione a sè. Questa parte non può essere modificata dall&#39;utente in quanto è una prerogativa del sistema.</answer_text><num_votes>0</num_votes></answer><answer id="A3238"><answer_text>L&#39;ambiente globale contiene le variabili globali visibili in tutto il programma e possono essere usate sia dal main che dalle altre funzioni.
In realtà le variabili globali creano molti più problemi di quanti ne risolvono, ragion per cui il loro uso è in generale fortemente sconsigliato. Anzitutto rendono il programma molto più difficile da leggere e da correggere in caso di errori: infatti se una variabile può essere usata e modificata da tutti, il suo valore può essere cambiato in qualsiasi punto del programma (e addirittura all&#39;interno di un differente file).</answer_text><num_votes>0</num_votes></answer><answer id="A3209"><answer_text>la memoria esterna o ambiente globale (in c in particolare) ha lo scopo di contenere le variabili dichiarate fuori dal main e da qualsiasi altra funzione, le quali valgono durante tutta l&#39;esecuzione del programma, vengono però disallocate quando il programma termina. Se questa variabile viene modificata nel main o in altre funzioni allora in quella funzione la variabile viene modificata, ma se creiamo altre funzioni la variabile avrà sempre il valore di quella dichiarata in ambiente globale (a meno che non la modifichiamo in quella funzione nuovamente).</answer_text><num_votes>0</num_votes></answer></question><question id="Q3282"><question_text>E&#39; possibile passare un vettore o una matrice ad una funzione? Se sì, come?</question_text><answer id="A3150"><answer_text>Si, è possibile. Si passa il puntatore (indirizzo) alla prima zona di memoria allocata per il vettore o la matrice. Dopodichè la variabile puntatore si preoccupa di effettuare tutte le operazioni che la funzione svolge sul vettore o sulla matrice. In un header di una funzione, per i parametri in ingresso, viene usata la sintassi:  tipodato vett[]. Stessa cosa per le matrici in cui si fa: tipodato mat[][].</answer_text><num_votes>1</num_votes></answer><answer id="A3143"><answer_text>Si, è possibile. Si passa il puntatore (indirizzo) alla prima zona di memoria allocata per il vettore o la matrice. Dopodichè la variabile puntatore si preoccupa di effettuare tutte le operazioni che la funzione svolge sul vettore o sulla matrice. In un header di una funzione, per i parametri in ingresso, viene usata la sintassi:  tipodato vett[]. Stessa cosa per le matrici in cui si fa: tipodato mat[][].</answer_text><num_votes>0</num_votes></answer><answer id="A3179"><answer_text>Il passaggio di un vettore come parametro avviene tramite il passaggio a un puntatore
Solitamente bisogna passare il numero di elementi poiché la funzione altrimenti non ha la capacità di conoscere la dimensione del vettore.
Ad esempio: void InserisciVettore (Vettore v, int dim) {?.......}.
Lo stesso procedimento e stesso metodo risulta valido quando si considera una matrice.</answer_text><num_votes>1</num_votes></answer></question><question id="Q3238"><question_text>Perchè è consigliabile definire in modo separato header e body delle funzioni?</question_text><answer id="A3198"><answer_text>Non si definiscono separatamente gli header e i body, ma si creano dei riferimenti a funzioni. int NumeroPrimo(int n);
Questa tecnica è utile in due casi: quando realizziamo un programma in un solo file, in cui definiamo tutti i riferimenti alle funzioni prima di creare esse o nella creazione di progetti con più file, in cui è buona norma scrivere il riferimento nel file &#34;.h&#34;(header-files), mentre la funzione si implementa nel file &#34;.cpp&#34;(implementation-file). In entrambi i casi si ha la possibilità di implementare le funzioni nell&#39;ordine che preferiamo e si ha un ordine maggiore nel codice.</answer_text><num_votes>1</num_votes></answer><answer id="A3221"><answer_text>Quando si scrivono programmi di grosse dimensioni è consigliabile suddividere i 
programmi in moduli separati per avere più ordine e per rendere più leggibile il codice.
La funzione main() sarà contenuta in un solo file (es: ?mioprogr.c?).
E?buona norma dichiarare strutture e header delle funzioni in un file separato (header file)
da includere in tale modulo (es: #include ?mioprogr.h?).
Per finire è meglio creare un file dove verrà implementato il body delle funzioni. </answer_text><num_votes>1</num_votes></answer><answer id="A3217"><answer_text>Inanzi tutto bisogna dire che questo non è obbligatorio, infatti noi possiamo definire funzioni, senza il cosiddetto prototipo. Il vantaggio nel farlo consiste nel fatto che il codice diventa molto più leggibile e facile da interpretare dall&#39;uomo, e permette al compilatore C di controllare la sintassi delle chiamate di funzioni.</answer_text><num_votes>0</num_votes></answer></question><question id="Q3202"><question_text>Come si calcola la complessità della funzione ricorsiva e di quella non ricorsiva?</question_text><answer id="A3166"><answer_text>nell&#39;informatica, le funzioni ricorsive sono una classe di funzioni dai numeri naturali ai numeri naturali che sono &#34;calcolabili&#34; in un qualche senso intuitivo. Infatti nella teoria della calcolabilità si mostra che le funzioni ricorsive corrispondono precisamente a quelle funzioni che possono essere calcolate tramite una macchina di Turing. non tutte le funzioni sono calcolabili, cioè ricorsive, queste si dicono funzioni non ricorsive e vengono calcolate attraverso alcuni teoremi, come quello della fermata.</answer_text><num_votes>0</num_votes></answer><answer id="A3230"><answer_text>Ogni volta che una funzione invoca se stessa(funzione ricorsiva), sta richiedendo la soluzione di un problema più semplice di quello di partenza. Si arriverà dunque ad un
problema di dimensione sufficientemente piccola da poter essere affrontato,detto caso base. A questo punto viene restituita una risposta che, a cascata e all&#39;indietro, permette di calcolare le risposte intermedie più complesse rimaste in sospeso.
Per calcolare la complessità è necessario introdurre le equazioni di ricorrenza che, per l&#39;appunto,descrivono una funzione in termini del suo valore su input sempre più piccoli.</answer_text><num_votes>3</num_votes></answer><answer id="A3227"><answer_text>La complessità di una funzione può essere descritta attraverso l&#39;analisi di vari fattori quali tempo di esecuzione, memoria occupata per il suo svolgimento e difficoltà che l&#39;elaboratore incontra per acquisire un input e restituire un output. Questi fattori sono fortemente influenzati dall&#39;efficienza dell&#39;algoritmo scelto per la funzione. In una funzione ricorsiva la complessità può essere inoltre calcolata in base a quanto viene semplificato ad ogni ricorsione il problema iniziale.  </answer_text><num_votes>0</num_votes></answer></question></lecture><lecture id="L27" title="Architettura del Calcolatore, Algebra di Boole" date="2013-09-23"><question id="Q2211"><question_text>Quando si parla di un sistema operativo basato su micro-kernel cosa si intende? E in un sistema operativo Micro-Kernel le applicazioni utente possono essere eseguiti in modalità Kernel mode?</question_text><answer id="A2159"><answer_text>In un S.O. basato su micro-Kernel, il Kernel, per il suo elevato costo computazionale, è ridotto all&#39;essenziale, ossia fornisce soltanto una minima gestione dell&#39;hardware di basso livello (driver) e della memoria delegando il resto ad altre parti esterne dette server o moduli in comunicazione con il kernel stesso. 
Dunque se un&#39;applicazione utente non richiede la diretta gestione delle &#34;politiche&#34; e dei meccanismi dei processi, può essere eseguito in un S.O. Micro-Kernel (anche in Kernel Mode).</answer_text><num_votes>1</num_votes></answer><answer id="A2188"><answer_text>Premettendo che non abbiamo svolto questi argomenti a lezione. Un microkernel a differenza di un kernel implementa meno funzioni, è quindi di più facile implementazione. Per rendere disponibili i servizi necessari al software vengono creati dei &#34;moduli server&#34; a &#34;livello&#34; più alto.
Questo significa che se uno di questi moduli server crasha, non provoca il blocco dell&#39;OS, ma può essere riavviato a parte. Per la seconda domanda con kernelmode cosa si intende? La linea di comando?Non avrebbe senso</answer_text><num_votes>2</num_votes></answer></question><question id="Q2216"><question_text>Che relazione esiste tra la frequenza del clock e la velocità del computer?</question_text><answer id="A2261"><answer_text>Il clock è un orologio interno al calcolatore che grazie a degli impulsi da lui generati scandisce il lavoro della CPU (Central Processing Unit). Di conseguenza maggiore è la frequenza degli impulsi del clock e maggiori sono le operazioni che il calcolatore può eseguire nell&#39;unità di tempo.</answer_text><num_votes>1</num_votes></answer><answer id="A2157"><answer_text>La velocità o frequenza di clock è il numero di commutazioni tra i due livelli logici &#34;0&#34; e &#34;1&#34; che l&#39;unità  di elaborazione (CPU) è in grado di eseguire nell&#39;unità  di tempo di un secondo, ed è espressa in cicli al secondo, o Hertz. La frequenza del clock e la velocità del computer sono direttamente proporzionali: infatti, maggiore è la frequenza, più sono le operazioni che possono essere eseguite nello stesso lasso di tempo e quindi maggiore è la velocità del computer.</answer_text><num_votes>3</num_votes></answer><answer id="A2267"><answer_text>La velocitÃ?Â  di elaborazione di un computer Ã?Â¨ direttamente proporzionale alla velocitÃ?Â  di clock della CPU. Infatti una velocitÃ?Â  di clock elevata garantisce un maggior numero di istruzioni eseguite nell&#39;unitÃ?Â  di tempo, nonostante non sia l&#39;unico fattore che concorre ala velocitÃ?Â  di una macchina.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2241"><question_text>Esistono due tipi di rappresentazione binaria dei numeri reali, in virgola fissa e in virgola mobile.
Qual è la rappresentazione più vantaggiosa e per quale motivo?</question_text><answer id="A2138"><answer_text>La rappresentazione piu&#39; vantaggiosa e&#39; quella in virgola mobile (floating point) che utilizza la notazione esponenziale: i vantaggi riguardano la possibilita&#39; di rappresentare con poche cifre numeri molto grandi oppure di rappresentare con precisione numeri molto piccoli; in sostanza, la rappresentazione in virgola mobile estende l&#39;intervallo di numeri rappresentati, a parita&#39;  di cifre, rispetto alla notazione in virgola fissa.</answer_text><num_votes>0</num_votes></answer><answer id="A2260"><answer_text>Sicuramente la rappresentazione in virgola mobile, in quanto permette di scrivere il numero come nella &#34;notazione scientifica&#34;, riducendo quindi il quantitativo di memoria necessario per memorizzarlo.</answer_text><num_votes>0</num_votes></answer><answer id="A2202"><answer_text>La rappresentazione più vantaggiosa è quella in virgola mobile (floating point)che utilizza la notazione esponenziale; i vantaggi riguardano la possibilità di rappresentare con poche cifre numeri molto grandi oppure di rappresentare con precisione numeri molto piccoli. In sostanza la rappresentazione in virgola mobile estende l’intervallo di numeri rappresentati, a parità di cifre, rispetto alla notazione in virgola fissa.</answer_text><num_votes>0</num_votes></answer><answer id="A2112"><answer_text>La rappresentazione binaria più vantaggiosa per i numeri reali è quella in virgola mobile in quanto essa permette di rappresentare in maniera compatta numeri molto grandi, ma anche molto piccoli. La rappresentazione in virgola mobile standard in 32 bit è la seguente: il primo bit codifica il segno, i successivi 8 codificano l&#39;esponente &#34;e&#34; che indica l&#39;ordine di grandezza del numero ed infine i restanti 23 codificano la mantissa &#34;m&#34; la quale rappresenta le cifre significative del numero.</answer_text><num_votes>1</num_votes></answer><answer id="A2200"><answer_text>La rappresentazione più vantaggiosa è quella in virgola mobile (floating point)che utilizza la notazione esponenziale; i vantaggi riguardano la possibilità di rappresentare con poche cifre numeri molto grandi oppure di rappresentare con precisione numeri molto piccoli. In sostanza la rappresentazione in virgola mobile estende l’intervallo di numeri rappresentati, a parità di cifre, rispetto alla notazione in virgola fissa.</answer_text><num_votes>0</num_votes></answer><answer id="A2135"><answer_text>E&#39; sicuramente più vantaggiosa la rappresentazione a virgola mobile la quale permette di esprimere numeri molto grandi con poche cifre e con precisione numeri molti piccoli. Nella rappresentazione a virgola mobile si utilizzerà una notazione esponenziale a 32 bit dove il 1 bit indicherà il segno, 8 bit l&#39;esponente, detto caratteristica, che indicherà la posizione della virgola e infine 23 bit la mantissa che rappresenta le cifre più rappresentative del numero.</answer_text><num_votes>2</num_votes></answer><answer id="A2205"><answer_text>La rappresentazione più vantaggiosa è quella in virgola mobile (floating point)che utilizza la notazione esponenziale; i vantaggi riguardano la possibilità di rappresentare con poche cifre numeri molto grandi oppure di rappresentare con precisione numeri molto piccoli. In sostanza la rappresentazione in virgola mobile estende l’intervallo di numeri rappresentati, a parità di cifre, rispetto alla notazione in virgola fissa.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2323"><question_text>Come avviene la gestione delle periferiche di sistema? è a carico del bus o del sistema operativo? cosa sono il polling e l&#39;interrupt?</question_text><answer id="A2254"><answer_text>La gestione delle periferiche e&#39; a carico del sistema operativo, che la puo&#39; gestire in due metodi: polling e interrupt.
Nel primo caso, il processore continua a verificare se il dato e&#39; arrivato dalla periferica mentre nel secondo, il processore viene notificato dell&#39;arrivo del dato; la notifica interrompe ci  che il processore stava facendo.
La gestione a polling e&#39; semplice, ma ha lo svantaggio di tenere il processore in sospeso nel ciclo in attesa del dato.</answer_text><num_votes>3</num_votes></answer><answer id="A2255"><answer_text>La gestione delle periferiche Ã¨ a carico del sistema operativo, che la puÃ² gestire in due metodi: polling e interrupt.</answer_text><num_votes>0</num_votes></answer><answer id="A2099"><answer_text>La gestione delle periferiche di sistema Ã?Â¨ uno dei compito che designato al SO;
Tale gestione viene effetuato tramite il cosidetto interrupt;

Interrupt: richiesta d&#39;attenzione da parte della periferica alla CPU; si &#34;interrompe/freeze/sospesa momentaneamente&#34; cosÃ?Â¬ il processo in esecuzione, 
viene &#34;interrogata&#34; periferica e ad operazione conclusa si ritorna all&#39;esecuzione precedente.</answer_text><num_votes>0</num_votes></answer><answer id="A2147"><answer_text>La gestione delle periferiche è affidata al sistema operativo il quale, attraverso programmi denominati driver, gestisce le operazioni di input/output delle periferiche.
Il polling e l&#39;interrupt sono due differenti modalità di controllo e gestione delle periferiche di I/O.
Il polling è un controllo ciclico delle periferiche, mentre l&#39;interrupt è un segnale di tipo asincrono inviato alla cpu, che viene generato al verificarsi di un evento esterno o interno.  </answer_text><num_votes>2</num_votes></answer></question><question id="Q2329"><question_text>Quali sono le differenze principali tra il concetto di &#34;compilazione&#34; e quello di &#34;interpretazione&#34; di un linguaggio?</question_text><answer id="A2095"><answer_text>Quando il programmatore crea un software,ovvero il codice sorgente,in un determinato linguaggio di programmazione questo per essere&#34;capito&#34;dal computer o qualsiasi automa,deve essere tradotto in linguaggio macchina,ovvero operazioni di bassissimo livello. Per fare questo operazione ci sono due software:il compilatore prende l&#39;intero codice sorgente e lo traduce in linguaggio macchina creando così l&#39;eseguibile, basta un errore e non viene creato. L&#39;interprete traduce riga per riga e la esegue.</answer_text><num_votes>1</num_votes></answer><answer id="A2266"><answer_text>Con il termine &#34;compilazione&#34; si intende la traduzione di tutto il programma ad un linguaggio ad un altro. In questo metodo la traduzione è più veloce ma puo&#39; richiedere molto tempo. 
Con &#34;interpretazione&#34;, invece, si intende la traduzione di una linea alla volta. Con questo metodo l&#39;esecuzione è più lenta ma la programmazione è maggiormente interattiva.</answer_text><num_votes>1</num_votes></answer><answer id="A2144"><answer_text>I linguaggi compilati, a differenza di quelli interpretati, vengono scritti in un editor che si occuperà di controllare la correttezza del codice per poi compilarlo, ovvero, ogni istruzione viene trasformata nel corrispondente codice in linguaggio macchina che può essere eseguito dal processore.
Mentre il linguaggi interpretati vengono elaborati al volo e vengono eseguite le istruzioni così come descritte nel codice sorgente senza che vi sia un controllo degli errori.</answer_text><num_votes>1</num_votes></answer><answer id="A2311"><answer_text>Con il termine &#34;compilazione&#34; si intende la traduzione di tutto il programma da un linguaggio ad un altro. In questo metodo la traduzione Ã¨ piÃ¹ veloce ma puo&#39; richiedere molto tempo. 
Con &#34;interpretazione&#34;, invece, si intende la traduzione di una linea di programma alla volta. Con questo metodo l&#39;esecuzione Ã¨ piÃ¹ lenta ma la programmazione Ã¨ piÃ¹ interattiva.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2275"><question_text>Quali sono le categorie principali di istruzioni eseguite dal processore?
</question_text><answer id="A2265"><answer_text>Le istruzioni eseguite dal processore possono essere classificate in tre categorie principali:
Â?-&#62; Istruzioni aritmetiche:
               â?¢ Somme, sottrazioni, moltiplicazioni, divisioni, shift ecc.
Â?-&#62; Istruzioni di controllo
               â?¢ incondizionato, condizionale, salto, chiamate a sottoprogramma
-&#62;Istruzioni di trasferimento dei dati:
               â?¢ Da un registro allâ??altro
               â?¢ Da uno dei registri alla memoria o viceversa</answer_text><num_votes>0</num_votes></answer><answer id="A2264"><answer_text>Le istruzioni eseguite dal processore possono essere classificate in tre categorie principali:
 -&#62; Istruzioni aritmetiche:
              * Somme, sottrazioni, moltiplicazioni, divisioni, shift ecc.
-&#62; Istruzioni di controllo
              * incondizionato, condizionale, salto, chiamate a sottoprogramma
-&#62;Istruzioni di trasferimento dei dati:
              * Da un registro all&#39; altro
              * Da uno dei registri alla memoria o viceversa</answer_text><num_votes>0</num_votes></answer><answer id="A2128"><answer_text>le categorie principali di istruzioni eseguite dal processore sono:
1)istruzioni aritmetiche(per esempio somme,sottrazioni,moltiplicazione e divisione)
2)istruzioni di controllo(per esempio condizionale e chiamate a sottoprogramma)
3)istruzioni di trasferimento dati(da un registro all&#39;altro o dal registro verso la memoria o viceversa)
un esempio di istruzione aritmetica potrebbe essere:
esegui l&#39;operazione a=b+c</answer_text><num_votes>2</num_votes></answer><answer id="A2293"><answer_text>il processore è l&#39;unità  principale di un personal computer e la sua funzione principale è l&#39;elaborazione dati dell&#39;intera macchina.</answer_text><num_votes>0</num_votes></answer><answer id="A2193"><answer_text>Ci sono tre principali tipologie di istruzioni: le Istruzioni Aritmetiche, le Istruzioni di Controllo e le Istruzioni di Trasferimento dei Dati.
Le prime sono eseguite nell&#39;Unità Aritmetico-Logica e in altri registri della CPU dedicati.
Le Istruzioni di Controllo vengono elaborate principalmente nell&#39;Unità di Controllo che si occupa del prelievo, della decodifica e dell&#39;esecuzione dei dati.
Infine le Istruzioni di Trasferimento passano i dati da un registro all&#39;altro o fra la Memoria e la CPU</answer_text><num_votes>1</num_votes></answer></question><question id="Q2368"><question_text>Quali sono gli operatori booleani e le loro proprietà? Come vengono rappresentati nel linguaggio di programmazione c ? </question_text><answer id="A2272"><answer_text>Gli operatori logici booleani sono NOT,AND,OR. 
NOT (unario) da come risultato l&#39;opposto dell&#39;operando. AND da come risultato vero(1) se entrambi gli operandi sono veri, OR se almeno uno dei due operandi Ã¨ vero.
Le proprietÃ  sono:
COMMUTATIVA: A AND B=B AND A
DISTRIBUTIVA: A AND(B OR C)=(A AND B)OR(A AND C)  (Valide anche invertendo AND ed OR)
Nel linguaggio di programmazione C  NOT,AND,OR sono rappresentate rispettivamente con !, &#38;&#38;, || ed utilizzate in espressioni logiche.</answer_text><num_votes>3</num_votes></answer><answer id="A2258"><answer_text>Gli operatori booleani sono:
-NOT &#39;!&#39; (NOT A rende l&#39;opposto del valore di A);
-AND &#39;&#38;&#38;&#39; (A AND B è vero se entrambi gli operatori sono veri);
-OR &#39;||&#39; (A OR B è vero se uno degli operandi è vero);

Le proprietà  sono la proprietà commutativa e distributiva:
-commutativa: A OR B=B OR A, 
                       A AND B=B AND A;
-distributiva: A OR(B AND C)=(A OR B)AND(A OR C), 
                    A AND(B OR C)=(A AND B)OR(A AND C).</answer_text><num_votes>1</num_votes></answer></question><question id="Q2271"><question_text>a che cosa serve la codifica CA2 in &#34;complemento a 2 per i numeri interi&#34;?</question_text><answer id="A2125"><answer_text>la codifica CA2 serve per rappresentare i numeri negativi nel sistema binario, con tale sistema si ha che il bit iniziale (più a sinistra) del numero, segnala se questo sia negativo (1) o positivo (0), consente inoltre di avere una sola rappresentazione dello 0 e richiede un solo circuito per somma e sottrazione</answer_text><num_votes>2</num_votes></answer><answer id="A2118"><answer_text>La codifica ca2 nel complemento a due per i numeri interi serve per trovare il valore decimale di un  numero intero con segno partendo da un numero binario o viceversa. Infatti se il bit più significativo(MSB), ovvero quello più a sinistra è 0 il numero decimale sarà sicuramente positivo, al contrario se l&#39;MSB è 1 il numero sarà negativo. Nella codifica ca2 con n bit è possibile rappresentare i valori da -2^(n-1) a 2^(n-1)-1.</answer_text><num_votes>3</num_votes></answer><answer id="A2122"><answer_text>La codifica in CA2 ti permette di rappresentare numeri interi negativi e risulta molto utile in ambiente informatico perchè il calcolatore non deve controllare il segno del numero rappresentato per sapere se deve usare l&#39;addizione o la sottrazione ma semplicemente svolge una sola operazione, ovvero l&#39;addizione velocizzando il tutto.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2284"><question_text>Quali sono le principali differenze tra una DRAM (dynamic RAM) e una SRAM (static RAM)?</question_text><answer id="A2148"><answer_text>Una DRAM richiede che i dati vengano periodicamente aggiornati per essere mantenuti in memoria, mentre una SRAM li conserva finchè viene alimentata da corrente. Ne consegue che una SRAM è più veloce e consuma meno potenza rispetto alla DRAM. Strutturalmente la SRAM necessita di più transistors per contenere una certa quantità di dati rispetto alla DRAM. La DRAM è più economica e per questo è maggiormente utilizzata.</answer_text><num_votes>2</num_votes></answer><answer id="A2301"><answer_text>La principale differenza tra un DRAM e una SRAM Ã¨ che il contenuto di una DRAM, un tipo di RAM che immagazzina ogni bit in un diverso condesatore, necessita 
di essere &#34;rinfrescato&#34; periodicamente, consentendo maggiori densitÃ  rispetto alla SRAM. Le SRAM hanno inoltre bassi tempi di lettura e
bassi consumi, anche se costi piÃ¹ elevati dovuti alla complessitÃ  delle celle di memoria che la compongono. La SRAM puÃ² inoltre mantenere le
informazioni per un tempo teoricamente infinito, al contrario delle DRAM che invece perdono le informazioni quando cessa l&#39;alimentazione del sistema.</answer_text><num_votes>0</num_votes></answer><answer id="A2249"><answer_text>La principale differenza tra una DRAM e una SRAM Ã??Ã?Â¨ che nella DRAM, un tipo di RAM che immagazzina
un bit in ogni diverso condesatore, il contenuto va &#34;rinfrescato&#34; periodicamente. Inoltre, quando 
cessa l&#39;alimentazione e il condesatore perde le cariche, l&#39;informazione viene persa. La SRAM, al contrario
non necessita di refresh e puÃ??Ã?Â² mantenere le informazioni per un tempo teoricamente infinito.
Hanno inoltre bassi tempi di lettura e bassi consumi.</answer_text><num_votes>0</num_votes></answer><answer id="A2151"><answer_text>La SRAM è una RAM volatile che non necessita di refresh, i banchi di memoria consentono di mantenere le informazioni per un tempo teoricamente infinito, hanno bassi tempi di lettura e bassi consumi. 
La necessità di usare molti componenti per cella le rende però più costose delle DRAM.
La DRAM, è un tipo di RAM che refresha solo i banchi di memoria che lo necessitano. </answer_text><num_votes>0</num_votes></answer><answer id="A2152"><answer_text>La SRAM è una RAM volatile che non necessita di refresh, i banchi di memoria consentono di mantenere le informazioni per un tempo teoricamente infinito, hanno bassi tempi di lettura e bassi consumi. 
La necessità di usare molti componenti per cella le rende però più costose delle DRAM.
La DRAM, è un tipo di RAM che refresha solo i banchi di memoria che lo necessitano. </answer_text><num_votes>0</num_votes></answer></question><question id="Q2351"><question_text>I dati e le istruzioni sono eseguiti dall&#39;unità di elaborazione solo se codificati in forma binaria; allora perché nei calcolatori i dati/le istruzioni vengono spesso memorizzati/e in una forma ottale o esadecimale?</question_text><answer id="A2113"><answer_text>Perché entrambi sono molto utili per la memorizzazione dei valori nei registri in quando ogni loro cifra traduce rispettivamente 3(ottale) e 4(esadecimale) bit nel sistema binario. In particolare il sistema esadecimale permette di memorizzare dei valori anche molto grandi utilizzando, in termini di byte, una minor quantità di memoria. Ad esempio un byte può essere espresso tramite solamente due cifre esadecimali permettendo così un risparmio di memoria.</answer_text><num_votes>1</num_votes></answer><answer id="A2119"><answer_text>Per approssimare il meno possibile, dato che la forma binaria presenta solo i numeri 0 e 1.</answer_text><num_votes>0</num_votes></answer><answer id="A2114"><answer_text>Perché entrambi sono molto utili per la memorizzazione dei valori nei registri in quando ogni loro cifra traduce rispettivamente 3(ottale) e 4(esadecimale) bit nel sistema binario. In particolare il sistema esadecimale permette di memorizzare dei valori anche molto grandi utilizzando, in termini di byte, una minor quantità di memoria. Ad esempio un byte può essere espresso tramite solamente due cifre esadecimali permettendo così un risparmio di memoria.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2239"><question_text>In che modo le mappe di Karnaugh possono minimizzare una funzione booleana?</question_text><answer id="A2316"><answer_text>Le mappe di K. sn un metodo gRafico x semplIfiC una funz Booleana, alternativo all&#39;uso teoremi algebra B
Ogni mappa sara una griglia di 2^n caselle dove n e&#39; il num di variabili.Ogni Casella avra il valore dellA funz calcolata in una paRticolare combinaz Delle variabIli
Es
n=not
A,B,C variab
F=n(A)&#38;&#38;n(B)&#38;&#38;n(C)||n(A)&#38;&#38;B&#38;&#38;n(C)||n(A)&#38;&#38;B&#38;&#38;C||A&#38;&#38;B&#38;&#38;C||A&#38;&#38;n(B)&#38;&#38;C
MAPPA
  |00|01|11|10&#60;-(A,B)
0| 0 | 1 | 0 | 0
1| 1 | 1 | 1 | 1
^
|
C
Colonna01: funzione vera per A=0 e B=1 indip da C equivale a: not(A)&#38;&#38;B
Riga2 funz sempre vera equivale a: C
F=1-&#62;o B=1 o n(A)&#38;B=1
Si ricava: F=not(A)&#38;&#38;B||C
</answer_text><num_votes>0</num_votes></answer><answer id="A2070"><answer_text>Le mappe di Karnaugh sono una particolare forma di tabella di verità, che consente di individuare immediatamente, in una qualsiasi funzione Booleana, le parti che possono essere semplificate utilizzando le seguenti proprietà dell&#39;algebra di Boole.
              _              _
AxB + AxB = Ax(B+B) = A
 _
(A+B)(A+B)=B

Tale metodo grafico comporta quindi la riduzione della complessità delle funzioni.
La sua applicazione però risulta semplice fino ad un numero di variabili pari a 4.

 
 </answer_text><num_votes>2</num_votes></answer><answer id="A2154"><answer_text>Le mappe di Karnaugh possono minimizzare una funzione booleana perchè capaci di compilare valori dei risulati di una espressione in funzione dei singoli operandi semplificando lo svolgimento dell intera operazione logica.</answer_text><num_votes>0</num_votes></answer><answer id="A2262"><answer_text>Data un&#39;espressione, le mappe di Karnaugh permettono di evidenziarne gli implicanti (particolari gruppi di valori in ingresso che danno in uscita lo stesso valore), codificabili in una serie di AND. L&#39;espressione iniziale equivale implicanti. L&#39;utilizzo delle mappe si confÃ Â a sistemi che non superano i 6 valori in ingresso, altrimenti l&#39;analisi diventa pesante. Il risultato delle mappe non e&#39; univoco, ma la funzione sarÃ  minimizzata come grazie a delle semplificazioni algebriche.</answer_text><num_votes>2</num_votes></answer><answer id="A2150"><answer_text>Le mappe di karnaugh possono minimizzare una funzione booleana perchè permettono di valutare e risolvere i valori binari dell&#39;espressione in funzione dei singoli operandi (vero o falso, 0 o 1) semplificando lo svolgimento dell&#39;espressione logica.</answer_text><num_votes>0</num_votes></answer><answer id="A2168"><answer_text>Le mappe di Karnaugh  permettono la soluzione di una funzione booleana tramite una costruzione grafica (una tabella) che riduce il tutto a banali operazioni di somma e prodotto.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2266"><question_text>che differenza c&#39;è tra #define N 50 e const int N=50 ?</question_text><answer id="A2093"><answer_text>&#34;const int N=50&#34; è una dichiarazione di costante, che associa permanentemente un valore a un identificatore, in questo caso associa alla variabile intera N il valore 50. Invece &#34;#define N 50&#34; è una dichiarazione di variabile che non riserva spazio di memoria e la sostituzione del valore costante al posto dell&#39;identificatore viene eseguita dal processore nel tempo di compilazione.</answer_text><num_votes>0</num_votes></answer><answer id="A2312"><answer_text>Con #define, essendo una istruzione preprocessore, il compilatore esegue una semplice sostituzione testuale di tutte le occorrenze all&#39;interno del compilato prima della compilazione, in pratica può, ma in minima parte, rendere un po&#39; più veloce l&#39;esecuzione. Con const, la costante viene elaborata una sola volta e viene allocato spazio per contenerla nello stack, il compilatore esegue il controllo della validità Â  della costante (short, word, etc...). La const viene quindi richiamata nel sorgente col suo indirizzo.</answer_text><num_votes>0</num_votes></answer><answer id="A2166"><answer_text>La definizione di costanti con &#34;#define&#34; non produce nessuna occupazione di memoria, mentre l&#39;istruzione del C &#34;const&#34; riserva memoria per la costante che viene definita, in questo caso intera.
La &#34;#define&#34; vale per tutto il sorgente (programma) da quel punto in poi, mentre la &#34;const&#34; è limitata alla function corrente.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2295"><question_text>Parlando di espressioni booleane, qual è il significato di contraddizione? E il significato di tautologia? </question_text><answer id="A2195"><answer_text>L`algebra di Boole è basata su tre operazioni logiche fondamentali
 NOT (es NOT A) Op. UNARIO, 
 AND (es A AND B) Op. BINARIO, 
 OR  (es A OR B ) Op. BINARIO 
che si applicano a operandi che possono assumere solo i valori binari VERO e FALSO.
Per CONTRADDIZIONE si intende un&#39;espressione che è sempre falsa ad esempio A AND (NOT A). 
Per TAUTOLOGIA si intende un&#39;espressione che è sempre vera ad esempio A OR (NOT A). </answer_text><num_votes>0</num_votes></answer><answer id="A2199"><answer_text>L`algebra di Boole è basata su tre operazioni logiche fondamentali
!? NOT (es NOT A) Op. UNARIO, 
&#38;? AND (es A AND B) Op. BINARIO, 
|| OR  (es A OR B ) Op. BINARIO 
che si applicano a operandi che possono assumere solo i valori binari VERO e FALSO.
Per CONTRADDIZIONE si intende un&#39;espressione che è sempre falsa ad esempio A AND (NOT A). 
Per TAUTOLOGIA si intende un&#39;espressione che è sempre vera ad esempio A OR (NOT A). </answer_text><num_votes>0</num_votes></answer><answer id="A2139"><answer_text>Un&#39; espressione booleana di contraddizione si ottiene quando abbiamo un&#39; espressione sempre falsa, es. A AND(NOT A); mentre abbiamo un&#39; espressione booleana tautologica quando abbiamo un&#39; espressione sempre vera, es A OR (NOT A).</answer_text><num_votes>2</num_votes></answer><answer id="A2198"><answer_text>L`algebra di Boole è basata su tre operazioni logiche fondamentali
!? NOT (es NOT A) Op. UNARIO, 
&#38;? AND (es A AND B) Op. BINARIO, 
|| OR  (es A OR B ) Op. BINARIO 
che si applicano a operandi che possono assumere solo i valori binari VERO e FALSO.
Per CONTRADDIZIONE si intende un&#39;espressione che è sempre falsa ad esempio A AND (NOT A). 
Per TAUTOLOGIA si intende un&#39;espressione che è sempre vera ad esempio A OR (NOT A). </answer_text><num_votes>0</num_votes></answer></question><question id="Q2234"><question_text>Quali sono le leggi di De Morgan e in cosa consistono?</question_text><answer id="A2253"><answer_text>Le leggi di De Morgan provano l&#39;equivalenza tra due specifiche espressioni booleane. 
La prima legge afferma che A AND B equivale a NOT ((NOT A) OR (NOT B)); mentre la seconda verifica che NOT ((NOT A) AND (NOT B)) Ã¨ uguale a A OR B.</answer_text><num_votes>0</num_votes></answer><answer id="A2216"><answer_text>Le leggi di De Morgan dimostrano che utilizzando la doppia negazione e l&#39;operatore opposto il risultato della formula non cambia. Ad esempio A AND B = NOT ((NOT A) OR (NOT B)) oppure A OR B = NOT ((NOT A) AND ( NOT B))</answer_text><num_votes>0</num_votes></answer><answer id="A2246"><answer_text>Le leggi di De Morgan provano l&#39;equivalenza tra due specifiche espressioni booleane. 
La prima legge afferma che A AND B equivale a NOT ((NOT A) OR (NOT B)); mentre la seconda verifica che NOT ((NOT A) AND (NOT B)) Ã¨ uguale a A OR B.</answer_text><num_votes>0</num_votes></answer><answer id="A2079"><answer_text>Le leggi di De Morgan sono delle formule di equivalenze che permettono di riscrivere un&#39;operazione di &#34;and&#34; come un&#39;operazione di &#34;or&#34; e &#34;not&#34;, o viceversa. Queste formule sono utilizzate, per esempio, se si vuole riscrivere un&#39;espressione booleana utilizzando solo &#34;and&#34; o solo &#34;or&#34;.
Le leggi di De Morgan sono:
  A and B = not( (not A) or (not B) )
  A or B = not( (not A) and (not B) )</answer_text><num_votes>2</num_votes></answer><answer id="A2252"><answer_text>E&#39; utile trovare delle espressioni booleane che si equivalgono, questo avviene se e solo se le tavole di verita&#39; corrispondenti le espressioni sono uguali. In particolare, De Morgan ha trovato che le seguenti espressioni si equivalgono:
A AND B = NOT ( (NOT A) OR ( NOT B ) ); 
A OR B = NOT ( ( NOT A ) AND ( NOT B ) ); queste leggi di De Morgan ci aiutano a semplificare delle espressioni booleane che troveremo piu o meno complesse in una forma piu&#39; facile da leggere e piu&#39; intuitiva.</answer_text><num_votes>2</num_votes></answer><answer id="A2263"><answer_text>Due espressioni booleane sono equivalenti se e solo se hanno la medesima tavola di veritÃ?Â .
Le leggi di De Morgan sono le seguenti:
Prima) Ã?Â A AND B = NOT ((NOT A) OR (NOT B)) 
Seconda) Ã?Â A OR B = NOT ((NOT A) AND (NOTB)) 
Queste leggi sono particolarmente utili per velocizzare e semplificare i calcoli.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2245"><question_text>Come posso rappresentare, all&#39;interno dell&#39;ambiente di programmazione C, numeri decimali con un&#39;ingente quantità di cifre dopo la virgola? tra le varie modalità di rappresentazione, quale è la più conveniente in termini di risorse?</question_text><answer id="A2228"><answer_text>In C i numeri decimali si rappresentano mediante il tipo float. Per rappresentare un’ingente quantità di cifre dopo la virgola è bene utilizzare la rappresentazione in virgola mobile al posto di quella in virgola fissa (dove vi è uno spreco di risorse in quanto si riserva a priori un numero di bit per parte intera e parte frazionaria senza sapere se realmente il numero sfrutterà questi spazi). In questo modo si ha un utilizzo più efficiente dei bit e quindi un’ottimizzazione delle risorse.</answer_text><num_votes>4</num_votes></answer><answer id="A2176"><answer_text>Per rappresentare i numeri con la virgola e possibile usare 3 tipi diversi: float, double oppure long double. Per numeri con molte cifre decimali si usa il long double, che però occupa molta memoria. Il tipo float è il più conveniente in termini di memoria,  ma può contenere meno </answer_text><num_votes>1</num_votes></answer></question><question id="Q2307"><question_text>Perchè esiste il registro interruzioni(INTR)? In particolare, a cosa serve nel funzionamento del processore?</question_text><answer id="A2143"><answer_text>il registro delle interruzioni è un sistema utilizzato dai vari hardware per segnalare azioni e eventi alla CPU.
Poichè il processore riceve informazioni solamente attraverso un singlo ingresso, un qualsiasi hardware che 
debba richidere l&#39;utlizzo della CPU per il suo funzionamento, invia un seganle alla CPU stessa che interrompe 
ciò che stava elaborando per analizzare la richiesta dell&#39;hardware.</answer_text><num_votes>0</num_votes></answer><answer id="A2142"><answer_text>Il registro delle interruzioni è un sistema utilizzato dai vari hardware per segnalare azioni e eventi alla CPU.
Poichè il processore riceve informazioni solamente attraverso un singlo ingresso, un qualsiasi hardware che 
debba richidere l&#39;utlizzo della CPU per il suo funzionamento, invia un seganle alla CPU stessa che interrompe 
ciò che stava elaborando per analizzare la richiesta dell&#39;hardware. </answer_text><num_votes>1</num_votes></answer><answer id="A2214"><answer_text>Il registro delle interruzioni INTR serve ad indicare all&#39;unità di elaborazione il verificarsi di eventi esterni.</answer_text><num_votes>1</num_votes></answer><answer id="A2141"><answer_text>il registro delle interruzioni è un sistema utilizzato dai vari hardware per segnale delle attività al processore.
Poichè il processore può ricevere informazioni solamente attraverso un ingresso, quando un hardware(interno o esterno al pc)
richiede delle operazioni alla CPU interrompe le attività che sta svolgento quest&#39;ultima per far si che elabori
la rischiesta dell&#39;hardware in questione.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2344"><question_text>Che differenza c&#39;è tra memoria RAM e memoria cache? Trattano tipi di dato differenti o elaborano operazioni differenti o altro?</question_text><answer id="A2245"><answer_text>La RAM è la memoria centrale del calcolatore dove risiedono dati e programmi sui quali esso opera mentre la CACHE è una memoria associata ad una principale dove vengono momentaneamente sistemati dei dati che servono più di frequente in modo tale da non doverli di volta in volta recuperare dalla RAM. Un&#39;altra differenza consiste nel fatto che la RAM ha un tempo di accesso alle celle contenenti le parole maggiore rispetto ad una memoria cache e contiene anche molti più dati rispetto ad essa</answer_text><num_votes>3</num_votes></answer><answer id="A2281"><answer_text>Le differenze tra le due memorie riguardano la quantità di istruzioni e di dati che riescono ad immagazzinare e la velocità con cui riescono a fornirli al processore. La memoria cache è in grado di rendere disponibili le informazioni in pochi nanosecondi in quanto è situata molto vicino al chip del processore o su quello stesso ma non può contenere tutte le informazioni della RAM.
Quando il processore, nell&#39;accedere ad un dato, non lo trova in cache, lo deve prelevare dalla memoria RAM.</answer_text><num_votes>0</num_votes></answer><answer id="A2292"><answer_text>La memoria RAM è la memoria più veloce all&#39;interno di un computer e l&#39;accesso ai suoi dati è indipendente dalla posizione che occupano.
Supponendo la memoria cache in SRAM questa è di tipo uguale alla RAM, ma i dati rimangono salvati anche quando cessa l&#39;alimentazione del pc.
Il tipo di dati che sono memorizzati nelle due memorie è lo stesso.
Di solito nella memoria cache vengono memorizzati temporaneamente dati sui quali opera la CPU, la quale li recupera più velocemente che dalla memoria di massa.
</answer_text><num_votes>0</num_votes></answer></question><question id="Q2201"><question_text>In che modo l&#39;unità di controllo rende possibile l&#39;esecuzione di un&#39;istruzione e quali registri vengono chiamati in causa durante questa fase di esecuzione?</question_text><answer id="A2222"><answer_text>La UC attraverso un primo segnale di controllo sposta il contenuto del pc nel registro degli indirizzi(AR);tramite un secondo segnale viene letto il dato.Il dato viene spostato nel registro dati(DR)e in seguito all&#39;arrivo del segnale MFC (memory function completed)la CU sposta il dato nel registro Istruzione corrente (CIR).Infine la UC decodifica l&#39;istruzione e in seguito genera la sequenza di segnali necessari all&#39;esecuzione dell&#39;istruzione, utilizzando altri registri come quelli degli operandi </answer_text><num_votes>0</num_votes></answer><answer id="A2187"><answer_text>L&#39;unita&#39; di controllo esegue tre fasi: preleva, decodifica e manda in esecuzione. In fase di esecuzione la UC genera la sequenza di segnali di controllo necessari ad eseguire l’istruzione mediante registro degli operandi.
I registri che vengono chiamati in causa durante questa fase sono: A e B principalmente.
</answer_text><num_votes>0</num_votes></answer><answer id="A2167"><answer_text>L&#39;unità di controllo (UC) gestisce e sequenzializza le ooperazioni. Il suo ruolo è prelevare e decodificare le istruzioni.
Più precisamente nella fase di fetch è la UC che sposta le istruzioni nel registro indirizzi (AR) e successivamente sposta i dati ricevuti dalla memoria nel registro istruzione istruzione corrente (CIR)
Ruolo dell&#39;UC è anche decodificare l&#39;istruzione, ossia tradurla in termini che la ALU (unità aritmetico logica) possa comprendere ed eseguire</answer_text><num_votes>0</num_votes></answer><answer id="A2303"><answer_text>L&#39;unita&#39;Ã?Â  di controllo(UC) manda un segnale di controllo affinche&#39; il contenuto del PC sia
spostato nel registro degli indirizzi, e un altro alla memoria per leggere il dato posto all&#39;indirizzo.
Il dato letto viene reso disponibile nel registro dati,dopo l&#39;arrivo del segnale MFC,la UC manda un segnale di controllo affinche&#39; il contenuto del DR sia spostato nel registro istruzione corrente,CIR.
Infine decodifica l&#39;istruzione in CIR e genera la sequenza di segnali di controllo necessari ad eseguire l&#39;istruzione.
Registro: contatore,interruzioni,di stato,dati,indirizzi.</answer_text><num_votes>2</num_votes></answer><answer id="A2227"><answer_text>La UC attraverso un primo segnale di controllo sposta il contenuto del pc nel registro degli indirizzi(AR);tramite un secondo segnale viene letto il dato.Il dato viene spostato nel registro dati(DR)e in seguito all&#39;arrivo del segnale MFC (memory function completed)la CU sposta il dato nel registro Istruzione corrente (CIR).Infine la UC decodifica l&#39;istruzione e in seguito genera la sequenza di segnali necessari all&#39;esecuzione dell&#39;istruzione, utilizzando altri registri come quelli degli operandi</answer_text><num_votes>1</num_votes></answer><answer id="A2224"><answer_text>La UC attraverso un primo segnale di controllo sposta il contenuto del pc nel registro degli indirizzi(AR);tramite un secondo segnale viene letto il dato.Il dato viene spostato nel registro dati(DR)e in seguito all&#39;arrivo del segnale MFC (memory function completed)la CU sposta il dato nel registro Istruzione corrente (CIR).Infine la UC decodifica l&#39;istruzione e in seguito genera la sequenza di segnali necessari all&#39;esecuzione dell&#39;istruzione, utilizzando altri registri come quelli degli operandi</answer_text><num_votes>1</num_votes></answer><answer id="A2225"><answer_text>La UC attraverso un primo segnale di controllo sposta il contenuto del pc nel registro degli indirizzi(AR);tramite un secondo segnale viene letto il dato.Il dato viene spostato nel registro dati(DR)e in seguito all&#39;arrivo del segnale MFC (memory function completed)la CU sposta il dato nel registro Istruzione corrente (CIR).Infine la UC decodifica l&#39;istruzione e in seguito genera la sequenza di segnali necessari all&#39;esecuzione dell&#39;istruzione, utilizzando altri registri come quelli degli operandi</answer_text><num_votes>0</num_votes></answer><answer id="A2226"><answer_text>La UC attraverso un primo segnale di controllo sposta il contenuto del pc nel registro degli indirizzi(AR);tramite un secondo segnale viene letto il dato.Il dato viene spostato nel registro dati(DR)e in seguito all&#39;arrivo del segnale MFC (memory function completed)la CU sposta il dato nel registro Istruzione corrente (CIR).Infine la UC decodifica l&#39;istruzione e in seguito genera la sequenza di segnali necessari all&#39;esecuzione dell&#39;istruzione, utilizzando altri registri come quelli degli operandi</answer_text><num_votes>0</num_votes></answer></question><question id="Q2228"><question_text>E&#39; possibile dedicare parte della memoria RAM di un calcolatore come memoria cache? 
Cosi&#39; facendo miglioro le prestazioni del PC?</question_text><answer id="A2247"><answer_text>La memoria centrale, RAM Random Access Memory, e&#39; utilizzata al fine di memorizzare i dati o programmi utili al funzionamento del compilatore. La RAM puo&#39; essere di due tipi: statica (SRAM) o dinamica (DRAM). LA SRAM si adatta ad essere utilizzata come una memoria cache, in quanto consente di memorizzare dati richiesti frequentemente; la DRAM consente di contenere una maggiore quantita&#39; di dati ed e&#39; meno veloce rispetto alla SRAM. Le prestazioni del pc migliorano se aumenta la capacita&#39; della RAM.</answer_text><num_votes>2</num_votes></answer><answer id="A2310"><answer_text>E&#39; possibile anche se tipicamente, per migliorare le prestazioni del PC, viene installata una memoria piccola e veloce di tipo SRAM direttamente sulla CPU (o vicino) dove vengono salvati gli indirizzi della parte di RAM che viene utilizzata piu&#39; frequentemente così da accelerare le operazioni .La cache e&#39; un tipo di memoria che deve poter essere utilizzata frequentemente , avere una buona accessibilità  e contenere pochi dati. </answer_text><num_votes>1</num_votes></answer><answer id="A2087"><answer_text>RAM e cache sono fisicamente diverse.
La cache è realizzata con una sRAM (serie di circuiti a flip-flop), diversa dalla dRAM usata per la RAM (una cella è composta da un condensatore e un transistor).
Non è quindi possibile &#34;trasformare&#34; la RAM del PC in cache.
Teoricamente si può realizzare una macchina che opera solo su cache: effettivamente per via della maggior velocità  di accesso miglioreresti di molto le prestazioni del PC. Il costo sarebbe però proibitivo.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2332"><question_text>Come funziona la gestione dei processi? Se vengono eseguiti sequenzialmente e non in parallelo come è possibile che una CPU anche a single core possa permettere il multitasking all&#39;utente?</question_text><answer id="A2162"><answer_text>Per avere più processi che vengano svolti in parallelo da una singola CPU, ad esempio il processo a A e il processo B, la CPU svolge per un brevissimo lasso di tempo il processo A (non sta svolgendo altri processi) per poi svolgere il processo B per un altro brevissimo lasso di tempo (ovviamente la CPU non sta svolgendo altri processi), per poi tornare su A e così via. 
In questo modo riesco ad eseguire due processi in parallelo su una singola CPU.</answer_text><num_votes>0</num_votes></answer><answer id="A2068"><answer_text>La gestione dei processi è uno dei compiti più importanti del processore. 
Quando la CPU è chiamata a eseguire più processi, sicuramente la soluzione migliore sarebbe quella di eseguirli contemporaneamente. 
Nel caso di una CPU a single core questo non è possibile. La CPU riceve quindi i processi in modo sequenziale e gli esegue uno ad uno. Siccome un processore esegue un&#39;istruzione in un tempo dell&#39;ordine di grandezza di milionesimi di secondo l&#39;utente avrà l&#39;impressione del multi tasking.  </answer_text><num_votes>2</num_votes></answer><answer id="A2160"><answer_text>Per avere più processi che vengano svolti in parallelo da una singola CPU, ad esempio il processo a A e il processo B, la CPU svolge per un brevissimo lasso di tempo il processo A (non sta svolgendo altri processi) per poi svolgere il processo B per un altro brevissimo lasso di tempo (ovviamente la CPU non sta svolgendo altri processi), per poi tornare su A e così via. 
In questo modo riesco ad eseguire due processi in parallelo su una singola CPU.</answer_text><num_votes>0</num_votes></answer><answer id="A2161"><answer_text>Per avere più processi che vengano svolti in parallelo da una singola CPU, ad esempio il processo a A e il processo B, la CPU svolge per un brevissimo lasso di tempo il processo A (non sta svolgendo altri processi) per poi svolgere il processo B per un altro brevissimo lasso di tempo (ovviamente la CPU non sta svolgendo altri processi), per poi tornare su A e così via. 
In questo modo riesco ad eseguire due processi in parallelo su una singola CPU.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2200"><question_text>Quali sono i principali operatori logici e qual è l&#39;ordine di priorità tra essi?</question_text><answer id="A2127"><answer_text>I principali operatori logici sono NOT, AND, OR. Da questi si ricavano in seguito le varianti negate di AND, e OR (NAND e OR).
Combinando piu&#39; elementi si ricavano gli operatori EXOR e EXNOR.
Gli operatori sono stati citati in ordine di priorita&#39; , ovvero per primo NOT, poi AND e infine OR.
Esempio : !AB+C e&#39; un modo sintetico di scrivere [(!A)*B]+C.</answer_text><num_votes>0</num_votes></answer><answer id="A2069"><answer_text>Gli operatori logici di base sono AND, OR e NOT. Le regole di precedenza ci dettano che tali operazioni, all&#39;interno di un espressione, vanno eseguite nel seguente ordine: prima viene eseguito il NOT, poi l&#39;AND ed infine l&#39;OR. Tali precedenze possono essere modificate a piecere mediante l&#39;uso di parentesi.</answer_text><num_votes>2</num_votes></answer><answer id="A2302"><answer_text>I principali operatori logici sono AND, OR e NOT.
L&#39;ordine di prioritÃ  Ã¨ il seguente:
1. NOT
2. AND
3. OR</answer_text><num_votes>1</num_votes></answer></question><question id="Q2347"><question_text>Descrivi gli elementi funzionali principali che costituiscono la macchina di von Neumann.</question_text><answer id="A2132"><answer_text>Gli elementi principali della macchina di Von Neumann sono:
Processore=esege i programmi;
memoria centrale=memorizza dati e istruzioni;
memoria di massa=memorizza grandi quantità di dati per lungo tempo;
periferiche I/O=consentono interfacciamento con l&#39;esterno;
bus di sistema=collega tutti gli altri elementi.</answer_text><num_votes>0</num_votes></answer><answer id="A2284"><answer_text>La macchina di Von Neumann esegue un&#39;istruzione alla volta,ed è composta da:
-Memoria centrale: accoglie dati e programmi con i quali opera il calcolatore, è composta da celle ognuna delle quali contiene una parola accessibile specificandone l&#39;indirizzo;
-CPU:è l&#39;unità  di calcolo che si occupa di elaborare i programmi;
-memoria di massa: è più lenta della mem. centrale ma memorizza in maniera persistente i dati;
-Periferiche;
-BUS: è la via di comunicazione per lo scambio dati.</answer_text><num_votes>1</num_votes></answer><answer id="A2271"><answer_text>Macchina di von Neumann:
1)Unità di elaborazione(CPU):scandito dal clock interpreta ed esegue le istruzioni del programma(unità di controllo,ALU).Presenta registri(CIR,PC,INTR,SR).
2)Memoria centrale:volatile,contiene istruzioni e dati utili all&#39;esecuzione di un programma.Si suddivide in celle ,contenenti una parola, indirizzate(RAM).
3)Periferiche:permettono scambio di informazioni tra elaboratore e mondo esterno(memorie di massa,tastiere,mouse).
4)Memorie di massa:memorizzano dati in modo persistente.
5)Bus di sistema:collega gli elementi funzionali consentendo scambio di dati.</answer_text><num_votes>2</num_votes></answer><answer id="A2131"><answer_text>Gli elementi principali della macchina di Von Neumann sono:
Processore=esege i programmi;
memoria centrale=memorizza dati e istruzioni;
memoria di massa=memorizza grandi quantità di dati per lungo tempo;
periferiche I/O=consentono interfacciamento con l&#39;esterno;
bus di sistema=collega tutti gli altri elementi.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2229"><question_text>Perché la memoria centrale (RAM) è detta memoria ad accesso casuale? E cosa significa che è una memoria volatile?</question_text><answer id="A2178"><answer_text>La RAM è detta memoria ad accesso casuale in quanto permette l&#39;accesso diretto a qualsiasi indirizzo di memoria in brevissimo tempo, per questo infatti è utilizzata come memoria centrale. 
È una memoria di tipo volatile poiché necessita di alimentazione elettrica per mantenere al proprio interno le informazioni, ad esempio spegnendo il computer tutte le informazioni memorizzate all&#39;interno di essa vengono cancellate; per questo motivo viene dette anche memoria temporanea.</answer_text><num_votes>0</num_votes></answer><answer id="A2179"><answer_text>La RAM è detta memoria ad accesso casuale in quanto permette l&#39;accesso diretto a qualsiasi indirizzo di memoria in brevissimo tempo, per questo infatti è utilizzata come memoria centrale. 
È una memoria di tipo volatile poiché necessita di alimentazione elettrica per mantenere al proprio interno le informazioni, ad esempio spegnendo il computer tutte le informazioni memorizzate all&#39;interno di essa vengono cancellate; per questo motivo viene dette anche memoria temporanea.</answer_text><num_votes>0</num_votes></answer><answer id="A2180"><answer_text>La RAM è detta memoria ad accesso casuale in quanto permette l&#39;accesso diretto a qualsiasi indirizzo di memoria in brevissimo tempo, per questo infatti è utilizzata come memoria centrale. 
È una memoria di tipo volatile poiché necessita di alimentazione elettrica per mantenere al proprio interno le informazioni, ad esempio spegnendo il computer tutte le informazioni memorizzate all&#39;interno di essa vengono cancellate; per questo motivo viene dette anche memoria temporanea.</answer_text><num_votes>0</num_votes></answer><answer id="A2268"><answer_text>La memoria RAM (random access memory) e&#39; detta memoria ad accesso casuale perche&#39; nell&#39;istante in cui il processore deve estrarre dei dati da essa, si basa sugli indirizzi delle celle di memoria per accedere alle informazioni memorizzate, non accedendo dunque in maniera sequenziale. E&#39; per questo motivo che il tempo di accesso e&#39; molto ridotto. E&#39; inoltre detta memoria volatile perche&#39; con l&#39;interruzione della corrente elettrica (spegnimento pc o guasto) tutti i dati contenuti in essa vengono persi.</answer_text><num_votes>2</num_votes></answer><answer id="A2206"><answer_text>La RAM è detta memoria ad accesso casuale perche impiega lo stesso tempo ad accedere a indirizzi diversi cioè non serve scorrere tutte le parole presenti nella memoria perche basta sapere l&#39;indirizzo.È una memoria volatile perche quando il sistema operativo viene riavviato i dati in essa vengono cancellati ogni volta.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2223"><question_text>In che modo il numero di bit (caratteristico del processore) che costituisce un indirizzo di memoria influenza la quantità di memoria che è possibile allocare? E&#39; possibile in qualche modo allocare più memoria?</question_text><answer id="A2203"><answer_text>Il numero di bit che costituisce un indirizzo di memoria influenza la quantità di memoria che è possibile allocare poiché lo stesso indirizzo di memoria occupa dei bit della memoria stessa e di conseguenza influisce, diminuendo, la quantità di memoria effettiva della cella.
Tuttavia è possibile allocare più memoria espandendola con altre memorie.</answer_text><num_votes>0</num_votes></answer><answer id="A2146"><answer_text>La memoria può essere considerata come una sequenza finita di celle, ognuna contenente una sequenza di bit. Quindi lo spazio fisico della memoria può essere immaginato come una serie di posizioni alle quali vengono associate dei bit. Valori tipici del numero di bit che possono essere memorizzati sono 8, 16, 32 o 64. Questa variazione del numero di bit coinvolti non significa un aumento della memoria, ma un cambiamento nell&#39;architettura del processore</answer_text><num_votes>1</num_votes></answer><answer id="A2156"><answer_text>Il processore, influenza la memoria dove e&#39; possibile allocare le &#34;word&#34; in modo che se il numero di bit in potenza di 2 da le celle di memoria e variano da 0 a 2^bit - 1.
Esempio: 2^10 = 1024 celle quindi da 0 a 1023
Il modo per aumentare la memoria di un calcolatore e&#39; quello di cambiarla allo stato fisico cioe&#39; estrarla e sostituirla a seconda delle esigenze del utente.</answer_text><num_votes>0</num_votes></answer><answer id="A2201"><answer_text>Il numero di bit che costituisce un indirizzo di memoria influenza la quantità di memoria che è possibile allocare poiché lo stesso indirizzo di memoria occupa dei bit della memoria stessa. Di conseguenza influisce, diminuendo, la quantità di memoria effettiva della cella.
Tuttavia è possibile allocare più memoria espandendola con ulteriori memorie.</answer_text><num_votes>0</num_votes></answer><answer id="A2177"><answer_text>La memoria e&#39; costituita da numerosissime celle, dispositivi bistabili, capaci di assumere due stati (0 o 1) attraverso i quali e&#39; possibile memorizzare la quantita&#39;Ã?Â  minima di informazione (1 bit). Il numero di bit identifica lo spazio di indirizzamento, avendo a disposizione k bit e&#39; possibile indirizzare 2^(k) bit all&#39;interno del processore; ad esempio se si hanno a disposizione 10 Byte (10*8 bit) si potranno indirizzare 2^(10) Byte di memoria, 1 Kilo Byte. Non e&#39; possibile allocare piu&#39; memoria di quella disponibile.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2210"><question_text>Quali componenti formano l&#39;architettura del calcolatore? In che modo comunicano tra loro?</question_text><answer id="A2257"><answer_text>I principali sono il processore (CPU) che esegue le operazioni, la memoria centrale (RAM) nella quale vengono salvati temporaneamente i dati per essere elaborati, e la memoria di massa principale (hard disk) nella quale sono salvati permanentemente dati e programmi. Questi comunicano tra loro e con le periferiche (monitor, tastiera, mouse, stampante, scheda di rete, altre memorie di massa come pendrive ecc.) attraverso il bus di sistema sul quale sono trasferiti dati e comandi</answer_text><num_votes>1</num_votes></answer><answer id="A2081"><answer_text>i componenti che formano l&#39;architettura del calcolatore sono:
- la CPU (o processore) -&#62; &#34;esegue&#34; i programmi
- la memoria centrale -&#62; memorizza dati e istruzioni
- la memoria di massa -&#62; memorizza grandi quantità di dati
- le periferiche (monitor, tastiere, schede di rete...)
e comunicano tutte mediante il bus di sistema.
Questo modello di hardware è detto &#34;macchina di Von Neumann&#34;</answer_text><num_votes>0</num_votes></answer><answer id="A2078"><answer_text>i componenti che formano l&#39;architettura del calcolatore sono:
-la CPU(o processore) -&#62; &#34;esegue&#34; i programmi
-la memoria centrale -&#62; memorizza dati e istruzioni
-la memoria di massa -&#62; memorizza grandi quantità di dati e programmi
-le periferiche (monitor, tastiere, schede di rete..)
e comunicano tra loro tramite il BUS di sistema.
Questo modello di hardware è detto &#34;macchina di Von Neumann.&#34;
</answer_text><num_votes>1</num_votes></answer><answer id="A2089"><answer_text>Un calcolatore è composto dalle seguenti parti:
- processore (svolge l&#39;elaborazione)
- memoria centrale (memorizza dati e istruzioni)
- periferiche (mouse, tastiera)
- memoria di massa (memorizza grandi quantità di dati in maniera non volatile)
Questi comunicano tra loro attraverso il bus di sistema, che consente lo scambio di dati.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2270"><question_text>Esistono fattori che influenzano la velocità di calcolo del processore?</question_text><answer id="A2317"><answer_text>Si.
Il primo fattore che influenza la velocità  di clock, ovvero la quantità  di impulsi generati dall&#39;orologio interno, più elevata è la frequenza degli impulsi del clock più sono le istruzioni eseguite nell&#39;unità  di tempo (clock, viene misurato in Hz).
Secondo fattore è la quantità di memoria RAM disponibile all&#39;interno del computer.</answer_text><num_votes>0</num_votes></answer><answer id="A2223"><answer_text>Un&#39;elevata frequenza di clock della CPU (ad esempio 2 o 3 GHz) fa in modo che tutte le tue operazioni 
di calcolo siano più veloci soprattutto quando usi programmi che fanno elaborazione grafica.</answer_text><num_votes>0</num_votes></answer><answer id="A2295"><answer_text>i fattori che influenzano la velocitÃ  di un processore sono due.
il primo consiste nella grandezza delle word (gruppi di bit di 8-16-32-64) con cui il processore comunica con le periferiche, la seconda consiste nella sua frequenza, infatti questa rappresenta la velocitÃ  con cui vengono emesse le word, ovviamente la capacitÃ  di gestione di un microprocessore aumenta al crescere della frequenza e della gradezza delle word, in conclusione un clock (onda quadra) sincronizza le operazioni della cpu</answer_text><num_votes>0</num_votes></answer><answer id="A2296"><answer_text>i fattori che influenzano la velocitÃ  di un processore sono due.
il primo consiste nella grandezza delle word (gruppi di bit di 8-16-32-64) con cui il processore comunica con le periferiche, la seconda consiste nella sua frequenza, infatti questa rappresenta la velocitÃ  con cui vengono emesse le word, ovviamente la capacitÃ  di gestione di un microprocessore aumenta al crescere della frequenza e della gradezza delle word, in conclusione un clock (onda quadra) sincronizza le operazioni della cpu</answer_text><num_votes>3</num_votes></answer></question><question id="Q2276"><question_text>Perchè la memoria RAM possiede una velocità di scrittura e lettura superiore a un HardDisk?</question_text><answer id="A2108"><answer_text>Perchè la memoria RAM è una memoria con tempo d&#39;accesso casuale,ovvero che non dipende dalla posizione(indirizzo) della parola di codice.Questo avviene grazie al registro di indirizzi,il quale denota ogni parola di codice con un indirizzo di k bit:al momento dell&#39;accesso basterà conoscere il suo indirizzo per individuarla velocemente;e grazie al registro di dati che contiene già la word da memorizzare.Negli HD questo processo deve essere fatto scrivendo/leggendo singoli bit 0/1 da dischi fisici.</answer_text><num_votes>3</num_votes></answer><answer id="A2275"><answer_text>L&#39;HardDisk risulta estremamente piÃ?Â¹ lento rispetto a una memoria RAM a causa delle operazioni fisiche, delle attivitÃ?Â Ã?Â  di lettura, indirizzamento necessarie e dell&#39;enorme quantitÃ?Â Ã?Â  di informazioni che questi supporti possono contenere.I dati presenti sull&#39;HD, infatti, non vengono persi una volta avvenuto l&#39;arresto. Questa Ã?Â¨ una differenza sostanziale,che va a pesare in termini di velocitÃ?Â Ã?Â ,con la RAM che Ã?Â¨ una memoria volatile e alla chiusura del computer perde tutti i dati contenuti.</answer_text><num_votes>3</num_votes></answer><answer id="A2270"><answer_text>L&#39; HardDisk e&#39;  composto da piu&#39; dischi sormontati da una testina che scrive o legge il contenuto del disco stesso,il tutto e&#39; contenuto in un involucro metallico collegato alla scheda madre per mezzo di un cavo e ogni byte viene scritto e la sua posizione registrata in una tabella chiamata file system. Tutto cio&#39; rende l&#39;HardDisk piu&#39; lento della RAM, la quale e&#39; invece composta da elementi hardware collegati direttamente alla scheda madre  e che dialogano molto piu&#39; velocemente con la stessa </answer_text><num_votes>0</num_votes></answer></question><question id="Q2237"><question_text>Perchè per leggere una memoria volatile superiore a 4096 MB serve un architettura a 64 bit?</question_text><answer id="A2126"><answer_text>Per leggere una memoria volatile superiore a 4096 MB serve un&#39;architettura a 64 bit, perché ha più memoria rispetto al  sistema a 32 bit che non la supporta, visto che il limite di memoria realmente utilizzabile varia a seconda dell&#39;hardware intorno ai 3,50 GB. Questo significa che in un&#39;architettura a 32 bit la massima quantità di dati che potrà indirizzare sarà circa 4096 MB (4 GB), ma una parte viene utilizzata anche per gli indirizzi necessari al funzionamento dell&#39;hardware e delle periferiche.</answer_text><num_votes>1</num_votes></answer><answer id="A2285"><answer_text>Le architetture in genere possono essere a 16,32 o 64 bit. Nella memoria volatile RAM i dati vengono salvati a &#34;pacchetti&#34; di 1 byte. Se abbiamo per esempio un sistema a 32 bit, la massima quantita&#39; di dati che esso puo&#39; indirizzare e&#39; pari a 2^32 byte. Facendo un rapido calcolo otteniamo che 2^32 byte corrispondono proprio a 4096 MB. Percio&#39; per leggere una memoria volatile SUPERIORE a 4096 MB serve un&#39;architettura a 64 bit poiche&#39; quella a 32 bit risulta essere insufficiente.</answer_text><num_votes>3</num_votes></answer><answer id="A2165"><answer_text>Serve un&#39;architettura a 64 bit per una memoria volatile superiore a 4096 MB perchè con 32 bit si arriva a 4096 MB, ma non si riesce ad andare oltre. </answer_text><num_votes>1</num_votes></answer><answer id="A2209"><answer_text>Un&#39;architettura a 32 bit permette un numero di indirizzi di memoria pari a 2 alla 32, ovvero 4GB. Il SO quindi può usare al massimo circa 3GB di memoria RAM perché il restante viene utilizzato da altre memorie quali registri e la RAM della GPU. Un&#39;architettura a 64 bit invece permette un numero di indirizzi di memoria pari a 2 alla 64, un numero assai maggiore del precedente e quindi permette l&#39;utilizzo di memorie volatili superiori ai 4GB.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2203"><question_text>Che differenza presenta l&#39;operatore logico &#34;XOR&#34; rispetto all&#39;operatore logico &#34;OR&#34;?
</question_text><answer id="A2189"><answer_text>L’operatore OR in C viene anche scritto come | (pipe) ed è detto somma logica. Quando viene effettuato l’OR tra due bit, il risultato varrà VERO se almeno uno dei due bit vale VERO.

L’operatore XOR (OR esclusivo)  in C viene anche scritto come ^ (elevamento a potenza) ed è detto somma modulo 2. Quando viene effettuato l’XOR tra due bit, il risultato varrà VERO se soltanto uno dei due bit vale VERO.</answer_text><num_votes>0</num_votes></answer><answer id="A2192"><answer_text>L’operatore OR in C viene anche scritto come | (pipe) ed è detto somma logica. Quando viene effettuato l’OR tra due bit, il risultato varrà VERO se almeno uno dei due bit vale VERO.

L’operatore XOR (OR esclusivo)  in C viene anche scritto come ^ (elevamento a potenza) ed è detto somma modulo 2. Quando viene effettuato l’XOR tra due bit, il risultato varrà VERO se soltanto uno dei due bit vale VERO.</answer_text><num_votes>0</num_votes></answer><answer id="A2297"><answer_text>L&#39;operatore logico &#34;XOR&#34; restituisce come output &#34;vero/1&#34; solo se uno dei due operandi presenta un valore &#34;vero/1&#34;, ciÃ??Ã?Â² implica che nel caso gli operandi siano entrambi &#34;veri/1&#34; o &#34;falsi/0&#34; dare come output un valore &#34;falso/0&#34;; &#34;OR&#34; invece restituisce in output un valore &#34;vero/1&#34; se almeno uno dei due operandi Ã??Ã?Â¨ &#34;vero/1&#34; e restituisce un valore &#34;falso/0&#34; se e solo se entrambi gli operandi hanno valore &#34;falso/0&#34;</answer_text><num_votes>1</num_votes></answer><answer id="A2101"><answer_text>L&#39;operazione logica OR restituisce 1 se almeno uno degli elementi è 1, mentre restituisce 0 negli altri casi.
L&#39;operatore XOR, restituisce 1 se e solo se il numero degli operandi uguali a 1 è dispari, mentre restituisce 0 in tutti gli altri casi. </answer_text><num_votes>0</num_votes></answer><answer id="A2191"><answer_text>L’operatore OR in C viene anche scritto come | (pipe) ed è detto somma logica. Quando viene effettuato l’OR tra due bit, il risultato varrà VERO se almeno uno dei due bit vale VERO.

L’operatore XOR (OR esclusivo)  in C viene anche scritto come ^ (elevamento a potenza) ed è detto somma modulo 2. Quando viene effettuato l’XOR tra due bit, il risultato varrà VERO se soltanto uno dei due bit vale VERO.</answer_text><num_votes>0</num_votes></answer><answer id="A2190"><answer_text>L’operatore OR in C viene anche scritto come | (pipe) ed è detto somma logica. Quando viene effettuato l’OR tra due bit, il risultato varrà VERO se almeno uno dei due bit vale VERO.

L’operatore XOR (OR esclusivo)  in C viene anche scritto come ^ (elevamento a potenza) ed è detto somma modulo 2. Quando viene effettuato l’XOR tra due bit, il risultato varrà VERO se soltanto uno dei due bit vale VERO.</answer_text><num_votes>1</num_votes></answer><answer id="A2171"><answer_text>l&#39;operazione logica &#34;OR&#34; restituisce 1 se almeno uno degli operandi è 1, mentre restituisce 0 se tutti gli operandi sono 0.
l&#39;operatore logico &#34;XOR&#34; restituisce 1 se e solo se gli operandi uguali a 1 sono dispari, mentre restituisce 0 in tutti gli altri casi.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2283"><question_text>In quale caso l&#39;operatore logico OR restituisce 1 in un&#39;operazione di algebra booleana?E quando restituisce 0?</question_text><answer id="A2308"><answer_text>quando entrambi gli ingressi sono falsi (bit 1) l&#39; uscita Ã¨ falsa; se invece almeno uno degli ingressi Ã¨ vero (bit 0), allora l&#39;uscita Ã¨ vera (bit 0).</answer_text><num_votes>0</num_votes></answer><answer id="A2106"><answer_text>L&#39;operatore logico OR (il cui simbolo, leggibile dal compilatore e&#39; ||) restituisce 1, cioe&#39; vero, se almeno uno degli operandi coinvolti nell&#39;espressione booleana vale 1, cioe&#39; risulta vero; al contrario dara&#39; 0, cioe&#39; falso, se tutti gli operandi valgono 0.</answer_text><num_votes>1</num_votes></answer><answer id="A2294"><answer_text>Ipotizziamo di avere due variabili A e B che per l&#39;algebra booleana possono assumere come valore  &#34;0&#34; (false) o &#34;1&#34; (true). L&#39;espressione A OR B rstituisce &#34;1&#34; nel momento in cui almeno uno dei due operatori fosse &#34;1&#34;, restituisce &#34;0&#34; se entrambi assumono  &#34;0&#34; come valore .</answer_text><num_votes>3</num_votes></answer><answer id="A2145"><answer_text>In generale, l&#39;operatore logico OR restituisce 1 quando almeno uno dei valori dell&#39;operazione è 1. Viceversa restituisce 0 quando tutti i valori dell&#39;operazione sono di valore 0.</answer_text><num_votes>1</num_votes></answer><answer id="A2123"><answer_text>L&#39;operatore restituisce 1 (vero) quando uno dei due ingressi (o entrambi) consistono nel bit 1 (vero); l&#39;uscita e&#39; 0 (falso) quando entrambi gli ingressi consistono nel bit 0 (falso).</answer_text><num_votes>0</num_votes></answer></question><question id="Q2286"><question_text>Come mai è necessario dichiarare le variabili nella programmazione?</question_text><answer id="A2318"><answer_text>La memoria RAM è una risorsa limitata che viene condivisa dai processi dell&#39;intero sistema. In quest&#39;ottica, la dichiarazione delle variabili ne permette una corretta gestione: saranno definiti gli indirizzi disponibili e riservati in numero e dimensione necessari a contenere le variabili del tipo dichiarato. Queste aree di memoria allocate saranno riempite in esecuzione del programma. In più, la dichiarazione tipizzata permette al compilatore di verificare eventuali errori semantici nel codice.</answer_text><num_votes>1</num_votes></answer><answer id="A2136"><answer_text>Il compilatore deve riservare in memoria lo spazio necessario all&#39;inizializzazione di ciascuna variabile. Bisogna tenere presente che se la variabile non viene inizializzata, lo spazio di memoria assegnatole potrebbe contenere già un valore. </answer_text><num_votes>0</num_votes></answer><answer id="A2305"><answer_text>PerchÃ¨ dichiarando la variabile viene valutata e definita la quantitÃ  di memoria destinata a contenere i dati a cui la variabile si riferisce. La quantitÃ  di memoria che viene allocata dipende dal tipo di variabile che si dichiara. Nella dichiarazione si specifica il tipo della variabile, in modo che il compilatore possa verificare eventuali errori semantici presenti all&#39;interno di un programma che sintatticamente risulta corretto (es. moltiplicare una variabile stringa per una variabile intera). Se non viene dichiarata una variabile il compilatore si accorge dell&#39;anomalia e da errore.</answer_text><num_votes>4</num_votes></answer></question><question id="Q2209"><question_text>Data la seguente espressione booleana:
NOT Y AND Y AND (X OR NOT Y) 
-Ricavare il risultato
-Riportare osservazioni se opportune</question_text><answer id="A2269"><answer_text>X | Y | NOT Y | X OR NOT Y | NOT Y AND Y AND (X OR NOT Y)
0   0      1              1                       0
0   1      0              0                       0
1   0      1              1                       0
1   1      0              1                       0

Come si puÃ² notare dalla tabella, l&#39;espressione booleana data non da mai in uscita un valore vero, ma sempre e solo valori falsi.</answer_text><num_votes>1</num_votes></answer><answer id="A2185"><answer_text>Dal momento che confrontiamo Y con il suo opposto (NOT Y) utilizzando l&#39;operatore logico &#34;AND&#34; si crea una contraddizione con risultato sempre falso. Avendo AND anche nella seconda parte dell&#39;espressione e poichè il risultato del primo parziale è sempre 0, ne consegue che anche il risultato finale sia 0, cioè l&#39;espressione sarà falsa in ogni circostanza. </answer_text><num_votes>1</num_votes></answer><answer id="A2289"><answer_text>L&#39;espressione restituisce 0 per qualsiasi coppia (X,Y) considerata. Si nota che il termine NOT Y AND Y restituisce anch&#39;esso sempre zero; data la successiva operazione AND, il risultato finale sarÃ?Â  zero per ogni coppia qualsiasi sia l&#39;espressione dentro la parentesi.</answer_text><num_votes>1</num_votes></answer><answer id="A2182"><answer_text>Dal momento che confrontiamo Y con il suo opposto (NOT Y) utilizzando l&#39;operatore logico &#34;AND&#34; si crea una contraddizione con risultato sempre falso. Avendo AND anche nella seconda parte dell&#39;espressione e poichè il risultato del primo parziale è sempre 0, ne consegue che anche il risultato finale sia 0, cioè l&#39;espressione sarà falsa in ogni circostanza. </answer_text><num_votes>0</num_votes></answer><answer id="A2215"><answer_text>Il risultato è 0. Si può osservare che NOT Y AND Y fa sempre 0 quindi i risultato dell&#39;espressione non sarà mai 1 perchè l&#39;operatore AND da come risultato 1 solo se entrambi gli operandi sono 1.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2348"><question_text>Dalla legge di De Morgan possiamo dimostrare l&#39;uguaglianza tra:
A AND B = NOT ((NOT A) OR (NOT B)) 
a livello computazionale le due espressioni hanno lo stesso peso e quindi usare una piuttosto che l&#39;altra è solo in base al gusto o una delle due è più facilmente computabile?
</question_text><answer id="A2133"><answer_text>Osservando che &#34;computabile&#34; significa &#34;calcolabile&#34;, il calcolatore non fa distinzione tra le due forme poiché entrambe sono calcolabili. La differenza tra A AND B e NOT ((NOT A) OR (NOT B)) risiede nella velocità di esecuzione del calcolo da parte del compilatore. Per l&#39;espressione A AND B, infatti, è necessario una sola operazione, mentre per NOT ((NOT A)OR(NOT B)) sono necessarie quattro operazioni. Per questa differenza si può allora affermare che A AND B è più rapidamente computabile.</answer_text><num_votes>3</num_votes></answer><answer id="A2304"><answer_text>La prima espressione Ã¨ piÃ¹ facilmente computabile perchÃ© corrisponde una tavola di veritÃ  molto piÃ¹ semplice e leggera a differenza della seconda in cui le combinazioni da calcolare sono molte di piÃ¹. 
</answer_text><num_votes>0</num_votes></answer><answer id="A2075"><answer_text>L&#39;espressione A AND B è più rapidamente computabile in quanto eseguita in un solo ciclo macchina: la velocità di computazione dipende infatti dal numero di operazioni che il calcolatore deve eseguire, 1 sola per A AND B, ben quattro per NOT ((NOT A) OR (NOT B))</answer_text><num_votes>1</num_votes></answer><answer id="A2129"><answer_text>Osservando che &#34;computabile&#34; significa &#34;calcolabile&#34;, il calcolatore non fa distinzione tra le due forme poiché entrambe sono calcolabili. La differenza tra A AND B e NOT ((NOT A) OR (NOT B)) risiede nella velocità di esecuzione del calcolo da parte del compilatore. Per l&#39;espressione A AND B, infatti, è necessaria una sola operazione, mentre per NOT ((NOT A)OR(NOT B)) sono necessarie quattro operazioni. Per questa differenza si può allora affermare che A AND B è più rapidamente computabile.</answer_text><num_votes>0</num_votes></answer><answer id="A2259"><answer_text>La legge di De Morgan puÃ?Â² essere facilmente verificata in via teorica tramite la tavola della veritÃ?Â . Per una macchina risolvere le due espressioni consiste nello stesso problema matematico, che viene quindi svolto senza alcuna differenza. Dal punto di vista pratico spesso si vorrÃ?Â  prediligere una delle due espressioni o per motivi di semplicitÃ?Â  (A AND B Ã?Â¨ piÃ?Â¹ intuitivo) oppure, soprattutto in elettronica, in base al materiale che si ha a disposizione.</answer_text><num_votes>0</num_votes></answer><answer id="A2250"><answer_text>Il peso computazionale di A AND B è inferiore rispetto a NOT((NOT A) OR (NOT B)). 
La realizzazione della prima richiede una sola porta logica, mentre la seconda 4.
Questo porta ad un maggior tempo di calcolo pari 3 ritardi porta (considerando lo stesso ritardo porta per porte AND OR e NOT) rispetto a 1 ritardo porta di A AND B, ed a un maggior consumo di energia a causa del maggior numero di componenti utilizzati.</answer_text><num_votes>0</num_votes></answer><answer id="A2074"><answer_text>L&#39;espressione A AND B e&#39; piu&#39; rapidamente computabile in quanto eseguita in un solo ciclo macchina: la velocita&#39; di computazione dipende infatti dal numero di operazioni che il calcolatore deve eseguire, 1 sola per A AND B, ben quattro per NOT ((NOT A) OR (NOT B)).</answer_text><num_votes>0</num_votes></answer></question><question id="Q2365"><question_text>Come mai viene utilizzato maggiormente lo standard ASCII piuttosto che lo standard UNICODE nella codifica dei caratteri? Quali sono i vantaggi e gli svantaggi di entrambi gli standard?</question_text><answer id="A2196"><answer_text>ASCII:
Vantaggi: minor utilizzo di memoria per singolo carattere (7 o 8 bit)
Svantaggi: minor numero di caratteri codificabili, esistenza di varie codifiche ASCII esteso incompatibili tra loro.

UNICODE:
Vantaggi: un&#39;unica codifica per tutti i caratteri delle lingue utilizzate.
Svantaggi: maggior occupazione di memoria (16 o 32 bit).

Uno dei motivi è che il codice UNICODE non è implementato nel software e nell&#39;hardware &#34;di vecchia data&#34; (antecedente il 1990), che quindi non è compatibile.</answer_text><num_votes>2</num_votes></answer><answer id="A2212"><answer_text>ASCII e Unicode sono due diversi sistemi di codifica dei caratteri.
Il primo può codificare fino a 256 tra simboli e caratteri di controllo fondamentali, utilizzando 8 bit; non include però caratteri di altri alfabeti (es. cirillici).
Il secondo, invece, unisce in sé tutte le codifiche regionali delle singole aree, riuscendo così a rappresentare caratteri appartenenti a tutte le lingue; tuttavia a tal fine sono necessari da 16 a 21 bit, comportando cioè un maggiore utilizzo di memoria.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2299"><question_text>Cosa significa che due espressioni booleane sono equivalenti?</question_text><answer id="A2083"><answer_text>Due equazioni booleane 1 e 2 si dicono equivalenti quando, per qualsiasi valore assegnato alle variabili di tali espressioni, il risultato delle due espressioni 1 e  coincide. Ad esempio si notano i due teoremi di De Morgan dove, l&#39;espressione </answer_text><num_votes>0</num_votes></answer><answer id="A2120"><answer_text>Due espressioni logiche si dicono EQUIVALENTI se e solo se hanno la medesima tavola di verità, ossia, avendo due espressioni contenenti le variabili A e B il risultato delle due operazioni in funzione dei valori degli operandi è lo stesso.
Due esempi di espressioni booleane equivalenti sono dati dalle LEGGI DI DE MORGAN:
A AND B = NOT ((NOT A) OR (NOT B))
A OR B = NOT ((NOTA) AND (NOT B))</answer_text><num_votes>2</num_votes></answer><answer id="A2121"><answer_text>Due espressioni logiche si dicono EQUIVALENTI se e solo se hanno la medesima tavola di verità, ossia, avendo due espressioni contenenti le variabili A e B il risultato delle due operazioni in funzione dei valori degli operandi è lo stesso.
Due esempi di espressioni booleane equivalenti sono dati dalle LEGGI DI DE MORGAN:
A AND B = NOT ((NOT A) OR (NOT B))
A OR B = NOT ((NOTA) AND (NOT B))</answer_text><num_votes>1</num_votes></answer><answer id="A2300"><answer_text>Due espressioni booleane si dicono equivalenti se presentano la medesima tavola di verit e quindi
conducono allo stesso risltato. E&#39; possibile riscontrare un esempio di equivalenza nelle Leggi di 
De Morgan: 
A AND B equivale a NOT((NOTA) OR (NOTB)) e A OR B equivale a NOT((NOTA) AND (NOTB)).</answer_text><num_votes>0</num_votes></answer><answer id="A2110"><answer_text>Due espressioni booleane sono espressioni logiche, per cui risultano equivalenti se alla fine assumono sempre lo stesso valore.</answer_text><num_votes>0</num_votes></answer><answer id="A2082"><answer_text>Due equazioni booleane si dicono equivalenti quando, per qualsiasi valore assegnato alle variabili di tali espressioni, il risultato delle due espressioni coincide.
Ad esempio si notano i due teoremi di De Morgan dove, l&#39;espressione !(A + B) è equivalente all&#39;espressione !A &#38; !B.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2250"><question_text>A cosa serve e come funzione il registro interruzioni? Ha una qualche correlazione con la gestione degli interrupt del linguaggio C?</question_text><answer id="A2274"><answer_text>Il registro interruzioni tiene memoria delle richieste di attenzione da parte delle unitÃ  esterna che richiedono attenzione in tempo reale. Se non ci fosse il registro questa richiesta fermerebbe l&#39;unitÃ  logica perdendo quanto fatto fino a quel momento. A livello di software invece questo sistema permette di richiamare un programma chiamato da uno chiamante. Quindi c&#39;Ã¨ una forte correlazione in quanto a livello software si applica la stessa procedura dell&#39;hardware per il real-time delle per.</answer_text><num_votes>0</num_votes></answer><answer id="A2091"><answer_text>L&#39;INTR è un registro contenente informazioni relative all’operatività delle periferiche e il suo funzionamento è strettamente legato agli interrupts di C. I codici che contengono le informazioni per gestire gli interrupts sono salvati in memoria, in posizioni fisse relative ad un indirizzo di base tramite un offset di memoria.Questo offset è contenuto proprio nel registro di interrupt e quando una periferica invia un interrupt, l’INTR si aggiorna in base alla posizione di offset corrispondente. </answer_text><num_votes>1</num_votes></answer><answer id="A2086"><answer_text>Contiene informazioni relative al funzionamento delle periferiche. Se una periferica o un processo devono contattare la CPU verrà inviato un segnale su questo registro.In seguito il processore memorizza il suo stato di esecuzione fino all&#39;arrivo dell&#39;interrupt ed inizia l&#39;esecuzione della subroutine che esegue la richiesta dell&#39;interrupt, infine il processore riprende l&#39;esecuzione delle operazioni che stava elaborando.Il C è in grado di sfruttare gli interrupt a seconda della funzione richiesta.</answer_text><num_votes>4</num_votes></answer><answer id="A2184"><answer_text>Il registro interruzioni, insieme ad un segnale, fa&#39; sì che l&#39;interfaccia sia in grado di generare l&#39;interruzione e viene inserito nella realizzazione dell&#39;interfaccia stessa. La sua funzione è quella di bloccare un&#39;operazione quando una più importante deve essere compiuta. C&#39;è correlazione tra registro e gestione delle interruzioni poichè, una volta che il registro permette che l&#39;interfaccia generi l&#39;interruzione, il processore interrompe le operazioni ed esegue una gestione delle interruzioni.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2215"><question_text>Quali sono i registri nella CPU e quale è la loro funzione/utilizzo?</question_text><answer id="A2288"><answer_text>I registri sono un insieme di bit ed hanno la funzione di memorizzare dati.
Essi sono:
registro degli indirizzi di memoria: da l&#39;indirizzo della memoria che si vuole selezionare
registro dei dati di memoria: ti dice i dati giÃ?Â  presenti nella memoria selezionata o quelli che sono stati introdotti
contatore di programma: contiene gli indirizzi delle istruzione sucessive
registro della istruzione corrente:contiene le istruzioni da tradurre ed eseguire
registro delle interruzioni: da informazioni sullo stato di funzionamento delle periferiche.</answer_text><num_votes>2</num_votes></answer><answer id="A2286"><answer_text>Esistono vari registri della CPU, quali: PC, IR, SR, AR, MAR, MDR, GPR. 
La loro funzione è quella di ospitare le informazioni corrette.</answer_text><num_votes>0</num_votes></answer><answer id="A2104"><answer_text>Registri di dati: sono usati per memorizzare dati.
Registri di indirizzo: per accedere alla memoria.
Registro generico: contiene sia dati che indirizzi. 
Registri floating-point: per memorizzare numeri a virgola mobile. 
Registri costanti: contengono dati di sola lettura. 
Registri speciali: contengono dati interni della CPU, tipo il program counter, il clock, ecc... 
Registro di istruzione: contiene l&#39;istruzione corrente.
Registri indice: per cambiare l&#39;indirizzo degli operandi.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2372"><question_text>Che cosa si intendo con il termine &#34;macchina virtuale&#34;?</question_text><answer id="A2276"><answer_text>Il termine macchina virtuale indica un software che, attraverso un processo di virtualizzazione, crea un ambiente virtuale che emula tipicamente il comportamento di una macchina fisica grazie al riservamento di risorse hardware (porzioni di HD, RAM e risorse di processamento) ed in cui alcune applicazioni possono essere eseguite come se interagissero con tale macchina. In caso dovesse andare fuori uso il sistema operativo della macchina virtuale il sistema operativo di base non ne risentirebbe.
</answer_text><num_votes>2</num_votes></answer><answer id="A2287"><answer_text>Per macchina virtuale intendiamo indicare il software che crea un ambiente virtuale che simula il comportamento di una macchina fisica. Questo e&#39; reso possibile grazie al fatto che vengono riservate delle risorse hardware per questa macchina virtuale (parti del disco rigido, RAM ecc...).
Il vantaggio di questa &#34;macchina&#34; e&#39; quello di offrire contemporaneamente a piu&#39; utenti la possibilita&#39; di avere diversi ambiente operativi separati e attivabili ciascuno su propria richiesta.</answer_text><num_votes>1</num_votes></answer><answer id="A3441"><answer_text>Il termine macchina virtuale indica un software che, attraverso un processo di virtualizzazione, crea un ambiente virtuale che emula tipicamente il comportamento di una macchina fisica grazie all&#39;assegnazione di risorse hardware (porzioni di disco rigido, RAM e risorse di processamento) ed in cui alcune applicazioni possono essere eseguite come se interagissero con tale macchina. Di fatto si offre contemporaneamente ed efficientemente a più utenti, diversi ambienti operativi separati, ciascuno attivabile su effettiva richiesta, senza sporcare il sistema fisico reale con partizioni.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2328"><question_text>Quali sono le differenze e le analogie, se presenti, tra un calcolatore a 32bit ed uno a 64bit? Quali vantaggi o svantaggi porta un&#39;architettura rispetto all&#39;altra?</question_text><answer id="A2221"><answer_text>Con i termini 32 e 64 bit si intende la grandezza in bit delle variabili semplici in una architettura hardware. Ad esempio nelle CPU, i registri con architettura a 64 bit hanno una dimensione maggiore rispetto ai 32 bit perchè devono &#34;ospitare&#34; una quantità maggiore di dati e così il sistema può gestire più dati contemporaneamente.
Questa è l&#39;unica differenza tra i due calcolatori in quanto essi operano sempre come con lo stesso metodo: Fase di fetch, interpretazione ed esecuzione.
</answer_text><num_votes>0</num_votes></answer><answer id="A2183"><answer_text>Con gli aggettivi 32 e 64 bit intendiamo la dimensione del formato standard di una variabile all&#39;interno di un&#39; architettura hardware(una differente gestione delle informazioni da parte della CPU). A seconda dell&#39;architettura quindi varia la dimensione dei registri interni del microprocessore. Un&#39;architettura da 64bit può gestire il doppio dei dati e sarà molto più efficiente ma è &#34;conveniente&#34; solo se supportata da bus di dati e indirizzi, nonché da una memoria ram, &#34;adeguati&#34; all&#39;architettura.</answer_text><num_votes>0</num_votes></answer><answer id="A2309"><answer_text>Dato che un calcolatore a 64 bit memorizza i dati in unita&#39; della medesima dimensione, esso avra&#39; accesso a quantitativi di indirizzi e quindi di potenziale memoria RAM molto piu&#39; ampi rispetto alle versioni a 32 bit, con un picco teorico di 2^64 indirizzi contro i 2^32 dei secondi -corrispondenti ad una limitazione di circa 4GB di RAM sul sistema. A livello software, ogni architettura necessitera&#39; di un proprio set di drivers rendendo programmi per architetture differenti non sempre retrocompatibili.</answer_text><num_votes>0</num_votes></answer><answer id="A2100"><answer_text>I 64 bit o 32 bit, indicano nelle rispettive architetture la lunghezza dei registri, spazio di indirizzamento in memoria ecc.
Un vantaggio è che la capacità di elaborazione delle operazioni al secondo raddoppia da 2^32  a 2^64.
Uno svantaggio è che i dati più ampi possono significare più spazio occupato e molte volte sprecato. Per esempio memorizzare il numero 300 richiede nove bit. Se lo memorizziamo su 32 bit, 23 si sprecano, invece a 64 bit ne sprechiamo 55.</answer_text><num_votes>0</num_votes></answer><answer id="A2290"><answer_text>Il numero di bit è riferito alla lunghezza delle variabili che un processore può gestire; un processore con istruzioni a 64bit è in grado quindi di gestire istruzioni di lunghezza doppia rispetto a uno a 32b,con 32bit il sistema operativo può gestire 2^32bit di memoria,mentre con un sistema a 64 bit la memoria sale a 2^64.Il processore gestendo variabili più lunghe deve fare meno operazioni di ricostruzione/decostruzione delle informazioni e questo dà  alcuni vantaggi soprattutto nell&#39;utilizzo delle memorie di grandi dimensioni e con il 64 bit il sistema è meno soggetto ad overflow.</answer_text><num_votes>0</num_votes></answer><answer id="A2158"><answer_text>Con gli aggettivi 32 e 64 bit intendiamo la dimensione del formato standard di una variabile all&#39;interno di un&#39; architettura hardware(una differente gestione delle informazioni da parte della CPU). A seconda dell&#39;architettura quindi varia la dimensione dei registri interni del microprocessore. Un&#39;architettura da 64bit può gestire il doppio dei dati e sarà molto più efficiente ma è &#34;conveniente&#34; solo se supportata da bus di dati e indirizzi, nonché da una memoria ram, &#34;adeguati&#34; all&#39;architettura.</answer_text><num_votes>0</num_votes></answer><answer id="A2103"><answer_text>Con i termini 32 e 64 bit si intende la grandezza in bit delle variabili semplici in una architettura hardware. Ad esempio nelle CPU, i registri con architettura a 64 bit hanno una dimensione maggiore rispetto ai 32 bit perchè devono &#34;ospitare&#34; una quantità maggiore di dati e così il sistema può gestire più dati contemporaneamente.
Questa è l&#39;unica differenza tra i due calcolatori in quanto essi operano sempre come con lo stesso metodo: Fase di fetch, interpretazione ed esecuzione.</answer_text><num_votes>0</num_votes></answer><answer id="A2105"><answer_text>prova di scrittura...</answer_text><num_votes>0</num_votes></answer><answer id="A2175"><answer_text>La differenza sta fondamentalmente nella dimensione del BUS dati: i processori a 32 bit hanno un BUS di una WORD (32 bit), mentre quelli a 64 sono a DOUBLEWORD (64 bit).
Un&#39;altra differenza è che la versione a 64 bit supporta astrattamente fino a 128GB di memoria RAM mentre la versione a 32 bit al massimo 4GB.
Un sistema a 64 bit quindi in genere offre prestazioni migliori; lo svantaggio del 64 bit è che ancora moltissimi programmi non sono scritti per girare sui sistemi a 64 bit.</answer_text><num_votes>1</num_votes></answer><answer id="A2098"><answer_text>Entrambi i calcolatori presentano gli stessi componenti e lo stesso sistema di comunicazione tra i moduli interni alla CPU. Ciò che li distingue è la lunghezza dei dati memorizzati ed elaborati, dei registri e delle celle di memoria. I calcolatori a 32bit presentano dati lunghi 32 bit mentre quelli a 64 elaborano numeri formati da 64 bit. Con dati binari formati da più bit si possono rappresentare più combinazioni e si possono compiere elaborazioni più complesse e più velocemente.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2233"><question_text>Qual&#39;è la relazione tra il numero di bit che costituisce un indirizzo di memoria e lo spazio di indirizzamento a disposizione?</question_text><answer id="A2115"><answer_text>Lo spazio di indirizzamento è definito dal numero di parole indirizzabili e dipende esclusivamente dal numero di bit dell’indirizzo e non dal numero di parole di memoria effettivamente disponibile: se N è il numero di bit che costituiscono l’indirizzo di una memoria allora il suo spazio di indirizzamento è 2^N. Dato che tutti i byte devono essere indirizzabili la dimensione effettiva della memoria è sempre minore o uguale al suo spazio di indirizzamento.</answer_text><num_votes>0</num_votes></answer><answer id="A2076"><answer_text>Il numero di bit che costituisce un indirizzo di memoria determina il numero di indirizzi, cioè lo spazio di indirizzamento.
In particolare, se un indirizzo di memoria è lungo N bit, lo spazio di indirizzamento a disposizione è di 2^N celle.</answer_text><num_votes>2</num_votes></answer><answer id="A2077"><answer_text>Il numero di bit che costituisce un indirizzo dipende dallo spazio di indirizzamento a disposizione in rapporto 2^N dove N è il numero di bit dell&#39;indirizzo.</answer_text><num_votes>0</num_votes></answer><answer id="A2117"><answer_text>Lo spazio di indirizzamento è definito dal numero di parole indirizzabili e dipende esclusivamente dal numero di bit dell’indirizzo e non dal numero di parole di memoria effettivamente disponibile: se N è il numero di bit che costituiscono l’indirizzo di una memoria allora il suo spazio di indirizzamento è 2^N. Dato che tutti i byte devono essere indirizzabili la dimensione effettiva della memoria è sempre minore o uguale al suo spazio di indirizzamento.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2235"><question_text>Per quale motivo all&#39;interno di un calcolatore è presente una memoria ROM, quale è la sua caratteristica principale e per cosa viene utilizzata all&#39;interno di un computer?</question_text><answer id="A2307"><answer_text>La ROM viene utilizzata per memorizzare dati e programmi che servono al
momento dell&#39;accensione dell&#39;elaboratore, prima del caricamento del sistema operativo,
ad esempio possono contenere il BIOS (Basic Input-Output System).
La ROM (read-only-memory) Ã¨ una memoria a sola lettura non programmabile ad accesso rapido,
i dati contenuti in essa vengono inseriti nella fase di costruzione e non possono 
essere modificati successivamente.
</answer_text><num_votes>2</num_votes></answer><answer id="A2283"><answer_text>Le memorie ROM sono utilizzate per memorizzare dati e programmi che servono al momento dell&#39;accensione del computer, prima del caricamento del sistema operativo. Le ROM effettuano un&#39;operazione importantissima all&#39;avvio del sistema, il boot e l&#39;auto diagnostica, che consiste nel verificare che i file di sistema e le periferiche del computer non abbiano problemi. Il contenuto di tali memorie si puo&#39; leggere ma non modificare ed e&#39;  persistente, cioe&#39; non viene perso allo spegnimento del calcolatore.</answer_text><num_votes>1</num_votes></answer><answer id="A2102"><answer_text>La ROM (Read-Only Memory) è una memoria con caratteristiche simili a quelle della RAM (Random Access Memory), ma vi differisce per due motivi: è una memoria di tipo permanente e ha un tempo d&#39;accesso notevolmente superiore a quest&#39;ultima. La si utilizza per memorizzare i dati che servono al momento dell&#39;accessione del calcolatore e prima del caricamento del sistema operativo, per esempio il BIOS. I dati nella ROM vengono in genere inseriti in fase di costruzione e non posso essere modificati.</answer_text><num_votes>0</num_votes></answer><answer id="A2088"><answer_text>La ROM (Read Only Memory) come esprime il nome stesso è una memoria che si distingue dalla sua gemella RAM dal fatto che è una memoria permanente, nel senso che a differenza di una RAM, quando viene tolta l&#39;alimentazione i dati permangono in essa; nella ROM risiedono ad esempio il BIOS e programmi/dati che servono all&#39;avvio dell&#39;OS; ecco perchè è indispensabile in un computer.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2254"><question_text>Cosa si intente per Raid (Redundant Array of Inexpensive Disks) e che tipi di Raid esistono?</question_text><answer id="A2094"><answer_text>Il RAID è una modalità che consente,tramite un controller,di avere più dischi fissi il che permette di avere un aumento delle prestazioni di lettura/scrittura.Il RAID consiste in 7 schemi diversi(RAID 0-6 che coinvolgono il numero minimo di dischi impiegati:da minimo 2(RAID 0)a minimo 4(RAID 6)) associati a diverse architetture di distribuzioni dati.Il Raid visto dal SO come unico disco.Spesso utilizzato per i server e in campi finanziario e bancario(garantisce un servizio continuo).</answer_text><num_votes>1</num_votes></answer><answer id="A2210"><answer_text>Il Raid è un sistema informatico che usa un gruppo di dischi rigidi per condividere o replicare le informazioni, combinando dischi a basso costo per rendere il sistema complessivo migliore di un disco singolo di ultima generazione. Esistono vari livelli di Raid in base alla combinazione dei dischi, di cui i più utilizzati vanno dal livello 0, con un numero minimo di 2 dischi, al livello 5, con un minimo di 4.</answer_text><num_votes>0</num_votes></answer><answer id="A2218"><answer_text>Il Raid è un sistema informatico che usa un gruppo di dischi rigidi per condividere o replicare le informazioni, combinando dischi a basso costo per rendere il sistema complessivo migliore di un disco singolo di ultima generazione. Esistono vari livelli di Raid in base alla combinazione dei dischi, di cui i più utilizzati vanno dal livello 0, con un numero minimo di 2 dischi, al livello 5, con un minimo di 4.</answer_text><num_votes>0</num_votes></answer><answer id="A2211"><answer_text>Il Raid è un sistema informatico che usa un gruppo di dischi rigidi per condividere o replicare le informazioni, combinando dischi a basso costo per rendere il sistema complessivo migliore di un disco singolo di ultima generazione. Esistono vari livelli di Raid in base alla combinazione dei dischi, di cui i più utilizzati vanno dal livello 0, con un numero minimo di 2 dischi, al livello 5, con un minimo di 4.</answer_text><num_votes>0</num_votes></answer><answer id="A2194"><answer_text>Per RAID si intende un sistema che combina un&#39;insieme di dischi rigidi nella stessa unitÃ .
Il sistema operativo riconosce l&#39;insieme di dischi come un unico volume.
CiÃ² consente di aumentare l&#39;integritÃ  dei dati, la tolleranza ai guasti e le prestazioni, rispetto all&#39;uso di un disco singolo.
Ci sono 7 tipi di Raid, denominati con i numeri da 0 a 6 (anche se il raid 0 non sarebbe un vero e proprio raid in quanto non permette nessun guasto sui dischi....non Ã¨ di conseguenza rindondante).</answer_text><num_votes>2</num_votes></answer></question><question id="Q2238"><question_text>Perchè la SRAM consente un accesso più rapido della RAM alle informazioni? Perchè la sua capacità è molto minore rispetto alla memoria RAM?</question_text><answer id="A2291"><answer_text>La SRAM, acronimo di Static Random Access Memory consentono un accesso più rapido alle informazioni per via di come sono state costruite le celle,in modo molto più complesso e costoso rispetto alle ram normali. Per questo le SRAM riescono ad essere fino a 20-30 più veloci rispetto alle RAM normali.La sua capacità  è molto minore sempre per via del metodo di costruzione delle celle di memoria,infatti per una maggiore densità  di flusso dati è meglio utilizzare la DRAM,meno veloce ma più capiente.</answer_text><num_votes>1</num_votes></answer><answer id="A2153"><answer_text>Le memorie SRAM, acronimo di Static Random Access Memory, consentono un accesso più rapido delle RAM in quanto dispongono di una capienze non troppo elevate (dell&#39;ordine di pochi Mb). Le SRAM sono generalmente usate come memoria cache dove sono necessarie elevate velocità.</answer_text><num_votes>0</num_votes></answer><answer id="A2107"><answer_text>La memoria SRAM è una memoria di tipo statico (i dati contenuti in essa permangono per tempi molto lunghi) che contiene pochi dati. 
La sua alta velocità di accesso alle informazioni deriva dal modo in cui è realizzata e dal fatto che contenga pochi dati al suo interno.
La sua capacità è limitata perchè ogni cella di memoria richiede un numero elevato di componenti. Infatti per elevate quantità di dati viene utilizzata la DRAM che viene realizzata usando celle di memoria meno complesse.</answer_text><num_votes>3</num_votes></answer></question><question id="Q2355"><question_text>Quali sono le proprietà degli operatori Booleani ?</question_text><answer id="A2314"><answer_text>Le proprieta&#39;  degli operatori Booleani sono: 1) proprieta&#39;  commutativa 2) proprieta&#39;  distributiva di uno verso l&#39;altro.
Esempio proprieta&#39;  commutativa: A OR B = B OR A.
Esempio proprieta&#39;  distributiva di uno verso l&#39;altro: A OR (B AND C) = (A OR B) AND (A OR C)</answer_text><num_votes>2</num_votes></answer><answer id="A2299"><answer_text>le proprietà  degli operatori booleani sono la commutativa ( A AND B = B AND A), e la distributiva.
Un esempio di quest&#39;ultima è: A AND (B OR C) = (A AND B) OR (A AND C)
</answer_text><num_votes>1</num_votes></answer></question><question id="Q2335"><question_text>A cosa serve la fase di interpretazione nel funzionamento del processore?</question_text><answer id="A2163"><answer_text>Nel funzionamento del processore la fase di interpretazione o di decodifica dell&#39;istruzione e&#39; svolta dall&#39;unita&#39;Â  di controllo (Control Unit) e consiste nella trasformazione del linguaggio di programmazione in linguaggio macchina. </answer_text><num_votes>1</num_votes></answer><answer id="A2251"><answer_text>L&#39;unità di controllo analizza il contenuto del Registro di Istruzione Corrente e ne decodifica le istruzioni presenti dal  &#39;&#39;linguaggio astratto&#39;&#39; al &#39;&#39;linguaggio macchina&#39;&#39; rendendo possibile l&#39;esecuzione delle istruzioni. 
Ad esempio viene individuato il tipo di operazione e i suoi operandi: registri generali oppure celle di memoria. In questo caso, sarà  necessario almeno un altro accesso in memoria per reperire l&#39;operando.</answer_text><num_votes>1</num_votes></answer><answer id="A2092"><answer_text>Il processore nella fase di interpretazione decodifica, grazie all&#39;UnitÃ Â  di Controllo (UC), il Registro dell&#39;Istruzione Corrente (CIR,) nella quale sarÃ  salvata l&#39;istruziuone che il compilatore dovra eseguire in seguito, dopo aver ricevuto i due operandi salvati nel registro A e B.</answer_text><num_votes>2</num_votes></answer></question><question id="Q2227"><question_text>Come viene implementata l&#39;algebra di Boole a livello hardware?</question_text><answer id="A2073"><answer_text>L&#39;algebra di Boole è un&#39;algebra astratta che opera con i soli valori logici di 0 (falso) e 1 (vero). A livello hardware un calcolatore o un qualsiasi elaboratore elettronico è strutturalmente basato su elementi bistabili, quindi può operare solamente su sequenze di simboli binari (BIT). In questo caso l&#39;algebra di Boole può essere implementata per la rappresentazione di circuiti logici dove a 0 e 1 corrisponderanno le due condizioni che un BIT può assumere.</answer_text><num_votes>0</num_votes></answer><answer id="A2071"><answer_text>L&#39;algebra di Boole è un&#39;algebra astratta che opera con i soli valori logici di 0 (falso) e 1 (vero). A livello hardware un calcolatore o un qualsiasi elaboratore elettronico è strutturalmente basato su elementi bistabili, quindi può operare solamente su sequenze di simboli binari (BIT). In questo caso l&#39;algebra di Boole può essere implementata per la rappresentazione di circuiti logici dove a 0 e 1 corrisponderanno le due condizioni che un BIT può assumere.</answer_text><num_votes>0</num_votes></answer><answer id="A2072"><answer_text>L&#39;algebra di Boole è un&#39;algebra astratta che opera con i soli valori logici di 0 (falso) e 1 (vero). A livello hardware un calcolatore o un qualsiasi elaboratore elettronico è strutturalmente basato su elementi bistabili, quindi può operare solamente su sequenze di simboli binari (BIT). In questo caso l&#39;algebra di Boole può essere implementata per la rappresentazione di circuiti logici dove a 0 e 1 corrisponderanno le due condizioni che un BIT può assumere.</answer_text><num_votes>0</num_votes></answer><answer id="A2085"><answer_text>Le informazioni sono rappresentate ed elaborate da dispositivi elettronici, detti reti logiche le quali possiedono le porte logiche che  costituiscono gli elementi di base di tutti i dispositivi digitali.Le porte logiche si basano sul funzionamento del transistor come interruttore binario veloce e queste  implementano gli operatori dell&#39;algebra di Boole, algebra a due valori (0,1).Una funzione booleana può essere descritta mediante una Tavola di verità.  </answer_text><num_votes>2</num_votes></answer><answer id="A2097"><answer_text>L&#39;algebra di Boole esegue operazioni matematiche di base tra numeri BINARI.
Ora, per implementare quest&#39;algebra a livello hardware, viene fatto uso di piccoli componenti elettronici, i TRANSISTOR, che combinati tra loro danno luogo a delle PORTE LOGICHE. Sono proprio queste porte che eseguono le operazioni matematiche, e le principali sono:
- AND: moltiplicazione  
- OR: somma
- NOT: negazione                                                                                  
  </answer_text><num_votes>0</num_votes></answer></question><question id="Q2253"><question_text>Spiegare il funzionamento della scrittura/lettura di dati(parole di memoria,word) nella memoria centrale specificando  le funzioni del registro di indirizzi(AR) e del registro di dati(DR)(modalità store/load).

Inoltre dire quale può essere l&#39;indirizzo minimo e massimo di una word quando il registro di indirizzi è di 16 bit. </question_text><answer id="A2197"><answer_text>I regisri DR e AR sono comandati dall UC per eseguire istruzioni. Su AR vengono scritti gli indirizzi delle celle di memoria su cui operare. Una volta raggiunte queste celle, si carica il dato in DR e si eseguono le operazioni necessarie. Su DR quindi c&#39;è il dato letto o da scrivere nella cella indirizzata dall AR.
Una word da 16 bit può conenere dati da 0 a 65535, convertiti in binario.</answer_text><num_votes>1</num_votes></answer><answer id="A2172"><answer_text>Le azioni di scrittura e lettura di dati dalla memoria centrale vengono gestite dalla CPU sfruttando il bus indirizzi e il bus di controllo
La CPU carica l&#39;indirizzo dal registro indirizzi e lo mette sul bus indirizzi per fare in modo che la periferica corretta si attivi e tramite segnali di controllo trasmessi sul bus dedicato fa compiere a questa l&#39;azione desiderata(store/load per la memoria)
Con indirizzi a 16 bit questi possono essere tutte le possibilitÃ?Â  tra 16 uni e 16 zeri (2 alla 16)</answer_text><num_votes>0</num_votes></answer><answer id="A2306"><answer_text>L&#39;acquisizione di un&#39;informazione e&#39; resa possibile dalla funzione del registro indirizzi (AR) e del registro dati (DR).Il primo permette all&#39;elaboratore di selezionare una particolare cella di memoria avvalendosi del suo &#34;indirizzo&#34; (posizione), il secondo rende possibile le operazioni di lettura e scrittura.
Durante la &#34;lettura&#34; il contenuto della cella di memoria e&#39; copiato sul DR (load), durante la scrittura e&#39; il contenuto del DR ad essere copiato nella cella (store).
Se il registro di indirizzi e&#39; di 16bit, , vengono indirizzate 2^16 celle i cui indirizzi vanno da 0 a 2^16-1.</answer_text><num_votes>2</num_votes></answer><answer id="A2186"><answer_text>L&#39;operazione di lettura effettua la copia dei dati contenuti in una cella di memoria all&#39;interno del registro dati. Tale cella e&#39; indirizzata attraverso il registro indirizzi.
L&#39;operazione di scrittura provoca la copia del contenuto del registro dati all&#39;interno di una cella di memoria, la quale e&#39; indirizzata dal registro indirizzi.
Nel caso il registro indirizzi sia di 16 bit, e&#39; possibile indirizzare 65536 word. L&#39;indirizzo minimo di una word risultera&#39; quindi 0 mentre quello massimo 65535.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2320"><question_text>lL CPU al suo interno contiene un &#34;clock&#34; che scandisce il lavoro tramite impulsi. Un calcolatore con una velocità di clock elevata è sempre più performante di uno con una velocità di clock più bassa? Motivare la risposta.</question_text><answer id="A2084"><answer_text>Il clock è un circuito generatore di impulsi che fornisce al processore la scansione temporale per l&#39;esecuzione delle singole operazioni logiche. La risposta alla domande è no. Infatti, quello che bisogna considerare in una CPU è, insieme alla frequenza di clock, il numero di istruzioni per clock. Inoltre, ad esempio, l&#39;architettura multi core adottata ormai da quasi tutte le CPU dei calcolatori moderni consente di aumentare la potenza di calcolo senza aumentare la frequenza di clock di lavoro. </answer_text><num_votes>1</num_votes></answer><answer id="A2278"><answer_text>La velocitÃ  di clock, o frequenza, Ã¨ il numero di commutiziano che riesce a compiere tr i livelli logici &#34;0&#34; e &#34;1&#34; in un secondo. PiÃ¹ la frequenza Ã¨ elevata e piÃ¹ commutazioni riesce a compiere, tuttavia la frequenza dev&#39;essere calcolata in modo tale che ogni circuito riesca a completare le proprie operazioni. Se la frequenza Ã¨ troppo elevata ed i circuiti non riesco a completare i calcoli la CPU non Ã¨ piÃ¹ performante.</answer_text><num_votes>0</num_votes></answer><answer id="A2213"><answer_text>si, lo è poichè un clock con frequenza maggiore riesce a eseguire le stesse istruzioni in un periodo di tempo minore(rispetto ad un clock con frequenza minore).</answer_text><num_votes>0</num_votes></answer><answer id="A2279"><answer_text>La velocitÃ  di clock, o frequenza, Ã¨ il numero di commutiziano che riesce a compiere tr i livelli logici &#34;0&#34; e &#34;1&#34; in un secondo. PiÃ¹ la frequenza Ã¨ elevata e piÃ¹ commutazioni riesce a compiere, tuttavia la frequenza dev&#39;essere calcolata in modo tale che ogni circuito riesca a completare le proprie operazioni. Se la frequenza Ã¨ troppo elevata ed i circuiti non riesco a completare i calcoli la CPU non Ã¨ piÃ¹ performante.</answer_text><num_votes>0</num_votes></answer><answer id="A2280"><answer_text>La velocitÃ  di clock, o frequenza, Ã¨ il numero di commutiziano che riesce a compiere tr i livelli logici &#34;0&#34; e &#34;1&#34; in un secondo. PiÃ¹ la frequenza Ã¨ elevata e piÃ¹ commutazioni riesce a compiere, tuttavia la frequenza dev&#39;essere calcolata in modo tale che ogni circuito riesca a completare le proprie operazioni. Se la frequenza Ã¨ troppo elevata ed i circuiti non riesco a completare i calcoli la CPU non Ã¨ piÃ¹ performante.</answer_text><num_votes>0</num_votes></answer><answer id="A2277"><answer_text>La velocità  di clock, o frequenza, è il numero di commutiziano che riesce a compiere tra i livelli logici &#34;0&#34; e &#34;1&#34; in un secondo. Più  la frequenza è elevata e più commutazioni riesce a compiere, tuttavia la frequenza dev&#39;essere calcolata in modo tale che ogni circuito riesca a completare le proprie operazioni. Se la frequenza è troppo elevata ed i circuiti non riesco a completare i calcoli la CPU non è più performante.</answer_text><num_votes>1</num_votes></answer></question><question id="Q2358"><question_text>Cosa si intende per modalità master/slave nell&#39;ambito del funzionamento del bus di sistema?</question_text><answer id="A2164"><answer_text>Il bus di sistema è un canale che permette di collegare tra di loro tutti i componenti all&#39;interno della scheda madre di un calcolatore e le periferiche esterne ad essa, è gestito secondo una gerarchia master/slave, il master è il componente che detiene il controllo del bus quando viene eseguita una richiesta, invece lo slave è rappresentato tutte le componenti implicate nel corso della richiesta che eseguono l&#39;istruzione, quindi non detengono il controllo del bus.</answer_text><num_votes>2</num_votes></answer><answer id="A2111"><answer_text>Per modalità master/slave nell&#39;ambito del funzionamento del bus di sistema, si intende la facoltà della CPU di controllare in modo unidirezionale le informazioni che viaggiano sul bus di sistema.</answer_text><num_votes>0</num_votes></answer><answer id="A2256"><answer_text>La modalitÃ  master/slave consiste in un gruppo di dispositivi o processi dei quali uno(master) possiede o assume il compito di controllare e gestire gli altri dispositivi(slaves). </answer_text><num_votes>0</num_votes></answer><answer id="A2169"><answer_text>Per modalità master/slave nell&#39;ambito del funzionamento del bus di sistema si intende la facoltà della CPU di controllare in modo unidirezionale le informazioni che viaggiano sul bus di sistema (dati, indirizzi o segnali di controllo).</answer_text><num_votes>0</num_votes></answer><answer id="A2219"><answer_text>Per modalità master/slave si indica un particolare sistema di connessione  fra dispositivi interfacciati ad un comune bus di sistema. Nella fattispecie il dispositivo che verrà indicato come master avrà la priorità esecutiva sul dispositivo indicato come slave e il funzionamento di quest&#39;ultimo dipenderà dal dispositivo master.</answer_text><num_votes>0</num_votes></answer></question><question id="Q2259"><question_text>Descrivere le fasi che il processore (CPU) svolge per eseguire un&#39;istruzione.</question_text><answer id="A2207"><answer_text>Le fasi di esecuzione della CPU sono principalmente tre: la fase di fetch, la fase di interpretazione e quella di esecuzione. Nella prima fase l&#39;unità di controllo trasferisce l&#39;istruzione nel registro istruzioni (CIR). Nella seconda la UC decodifica l&#39;istruzione in CIR e nell&#39;ultima fase la UC genera i segnali di controllo per eseguire l&#39;istruzione.</answer_text><num_votes>0</num_votes></answer><answer id="A2208"><answer_text>Le fasi di esecuzione della CPU sono principalmente tre: la fase di fetch, la fase di interpretazione e quella di esecuzione. Nella prima fase l’unità di controllo trasferisce l’istruzione nel registro istruzioni (CIR). Nella seconda la UC decodifica l’istruzione in CIR e nell’ultima fase la UC genera i segnali di controllo per eseguire l’istruzione.</answer_text><num_votes>0</num_votes></answer><answer id="A2096"><answer_text>Il processore esegue un&#39;istruzione con queste fasi
- caricamento della prima istruzione nel contatore Program counter
- Fetch: L&#39;UnitÃ  di controllo UC sposta l&#39;istruzione nel registro degli indirizzi AR, per prelevare il dato nel registro Dati DR. Poi l&#39;UC sposta il dato nel registro d&#39;istruzione corrente CIR.
- Interpretazione: l&#39;UC decodifica l&#39;istruzione nel registro CIR
- Esecuzione: l&#39;UC esegue l&#39;istruzione mediante i registri e l&#39;ALU.
- incremento PC  alla prossima istruzione
</answer_text><num_votes>3</num_votes></answer></question><question id="Q2224"><question_text>Cosa accade se all&#39;interno di un&#39;espressione matematica il compilatore si trova a lavorare con variabili di tipo diverso? </question_text><answer id="A2220"><answer_text>Se eseguo un&#39;espressione matematica tra variabili diverse il compilatore mi restituirà un &#34;warning&#34;(un&#39;avvertimento del compilatore, che però non pregiudica la compilazione vera e propria) oppure un ERRORE vero e proprio. Per effettuare operazioni tra variabili di tipo diverso dovrò ricorrere alla &#34;conversione di cast&#34;, semplicemente specificando tra parentesi il tipo di operazione che voglio effettuare(esempio: int a=1 float b=2.7 c=(float) a+b=3.7).</answer_text><num_votes>1</num_votes></answer><answer id="A2149"><answer_text>Il risultato di quell&#39;operazione non sara&#39;  quello desiderato. Ad esempio se lavorassimo con degli interi e volessimo un risultato di tipo float,dobbiamo usare l&#39;operazione detta &#34;casting&#34; ossia mettere prima dell&#39;espressione il tipo del dato desiderato tra parentesi. ( (float) a/b.. dove a e b sono interi). Senza il casting il risultato nella variabile float sara&#39;   composto da sola parte intera e senza parte decimale.</answer_text><num_votes>1</num_votes></answer><answer id="A2130"><answer_text>Il casting automatico assegnerà all&#39;espressione un valore del tipo che risulta essere dominante rispetto agli altri (gerarchia dei tipi di dato). Se invece il casting non è automatico, ma è stato impostato dal programmatore, il valore dell&#39;espressione verrà valutato in base ad esso (ad esempio nell&#39;espressione x=(float)2/3; il valore dell&#39;espressione verrà calcolato nell&#39;ambito dei numeri razionali anche se i due operandi sono interi).</answer_text><num_votes>1</num_votes></answer></question><question id="Q2306"><question_text>Qual&#39;è la differenza tra gli interi long, short e int?</question_text><answer id="A2170"><answer_text>Long e short sono qualificatori di tipo per gli interi e condizionano lo spazio allocato dal compilatore per le variabili; quando viene eseguito un programma vale la seguente regola: spazio allocato(short int)&#60;=spazio(int)&#60;=spazio(long int). Tipicamente per i long sono utilizzati 32 bit, per i short 16 e per gli int 16-32 bit.</answer_text><num_votes>0</num_votes></answer><answer id="A2313"><answer_text>La dichiarazione di una variabile con tipo int definisce lâ??insieme di valori che questa puÃ² assumere.I calcolatori prevedono che i tipi di dato abbiano una dimensione in memoria fortemente dipendente dall&#39;hardware,esistono poi dei qualificatori che ci permettono di aumentarla o diminuirla.SHORT utilizza valori compresi tra -32767 e 32767(2^15)mentre LONG tra -2147483647 e 2147483647(2^31).INT invece assume valori max e min in base al calcolatore(16bit-&#62;2^15 o 32bit-&#62;2^31).
SHORT&#60;=INT&#60;=LONG</answer_text><num_votes>0</num_votes></answer><answer id="A2204"><answer_text>La dichiarazione di una variabile con tipo int definisce l’insieme di valori che questa può assumere.I calcolatori prevedono che i tipi di dato abbiano una dimensione in memoria fortemente dipendente dall&#39;hardware,esistono poi dei qualificatori che ci permettono di aumentarla o diminuirla.SHORT utilizza valori compresi tra -32767 e 32767(2^15)mentre LONG tra -2147483647 e 2147483647(2^31).INT invece assume valori max e min in base al calcolatore(16bit-&#62;2^15 o 32bit-&#62;2^31).
SHORT&#60;=INT&#60;=LONG</answer_text><num_votes>0</num_votes></answer><answer id="A2298"><answer_text>Long e short sono qualificatori di tipo per gli interi e condizionano lo spazio allocato dal compilatore per le variabili; quando viene eseguito un programma vale la seguente regola: spazio allocato(short int)&#60;=spazio(int)&#60;=spazio(long int). Tipicamente per i long sono utilizzati 32 bit, per i short 16 e per gli int 16-32 bit.</answer_text><num_votes>0</num_votes></answer><answer id="A2124"><answer_text>Long e short qualificano il tipo della variabile int. Condizionando lo spazio allocato dal compilatore per la variabile ne determinano il valore massimo e minimo.
Su un elaboratore a 32 bit il compilatore alloca 16 bit per la variabile short int, (-32.768; 32.767) e 32 bit per la variabile int o long int (-2.147.483.648 ; +2.147.483.647).
Qualora supportato dalla macchina, long int allocato a 64bit ha estensione maggiore di int.
Dev&#39;essere quindi che &#39;short int&#39; &#60;= &#39;int&#39; &#60;=&#39;long int&#39; </answer_text><num_votes>1</num_votes></answer><answer id="A2134"><answer_text>La dichiarazione di una variabile con tipo int definisce l&#39;insieme di valori che questa può assumere.
I calcolatori prevedono che i tipi di dato abbiano una dimensione in memoria fortemente
dipendente dall&#39;hardware,esistono poi dei qualificatori che ci permettono di aumentarla o 
diminuirla.SHORT utilizza valori compresi tra -32767 e 32767(2^15)mentre LONG tra -2147483647 e 2147483647(2^31).INT invece assume valori max e min in base al calcolatore(16bit-&#62;2^15 o 32bit-&#62;2^31).SHORT&#60;=INT&#60;=LONG</answer_text><num_votes>0</num_votes></answer></question><question id="Q2278"><question_text>Come avviene la lettura di un dato nella RAM tramite la cpu e come la scrittura sempre tramite la cpu? </question_text><answer id="A2116"><answer_text>-CPU scrive indirizzo della locazione con il contenuto interessato nel registro indirizzi
-attiva il segnale di controllo Read che giunge alla RAM
-RAM ricerca la locazione (indirizzo indicato nel registro indirizzi) e ne copia il contenuto nel registro dati accessibile alla CPU

-CPU scrive indirizzo della locazione interessata nel registro indirizzi
-inserisce il dato da scrivere nel registro dati
-attiva il segnale di controllo Write che giunge alla RAM
-RAM prende il dato contenuto nel registro dati e lo memorizza nella locazione (indirizzo indicato nel registro indirizzi)</answer_text><num_votes>0</num_votes></answer><answer id="A2315"><answer_text>La CPU legge i dati presenti nella RAM, attraverso il bus di sistema, in maniera casuale (random access memory), velocemente e senza una regola ben definita. Scrive, inoltre, i dati nella RAM, attraverso il bus di sistema, allocandoli in un indirizzo ben definio.</answer_text><num_votes>0</num_votes></answer><answer id="A2174"><answer_text>L&#39;unità di controllo (CU) carica nel registro indirizzi (AR) l&#39;indirizzo in cui si trova il dato da leggere (o da scrivere) nella RAM. Attraverso il Bus di sistema la CU manda un&#39;istruzione di lettura (o scrittura) alla RAM; con un&#39;istruzione di trasferimento dati il dato contenuto in quell&#39;indirizzo viene trasferito nel registro dati (DR) o viceversa il dato del DR viene scritto nella posizione della RAM corrispondente a quell&#39;indirizzo.</answer_text><num_votes>2</num_votes></answer></question></lecture><lecture id="IKEA_EN_001" title="IKEA FAQ" date="2014-03-20"><question id="Q4192"><question_text>How do I shop in IKEA?</question_text><answer id="A4283"><answer_text>We want your next trip to IKEA to be as pleasant as possible. So, here are some tips on how to shop the easy way at our IKEA stores! IKEA stores have free parking (subject to minimum spend at Southampton and Coventry) and provide easy access for the disabled. Everything you need to shop is available at the entrance: pencils, paper, tape measures, store guides, catalogues, shopping strollers and shopping bags. Everything you need to know about how to shop at your local IKEA store.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4193"><question_text>How do I check stock availability?</question_text><answer id="A4284"><answer_text>Every effort is made to maintain the availability of items shown in the catalogue, but due to popularity and supply issues, some products may not always be available, you can check the availability of stock in your local store here. If an item is out of stock you will have the option to leave a mobile number or email address and we will notify you when more stock arrives.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4194"><question_text>What online tools do you have to assist with planning?</question_text><answer id="A4285"><answer_text>Yes, there are a number of online planning tools available for you to use to help you furnish your home, your way. See our online planning tools</answer_text><num_votes>1</num_votes></answer></question><question id="Q4195"><question_text>Can I buy items online?</question_text><answer id="A4286"><answer_text>Most of our range is available to buy online for delivery from our distribution centre to your home address, find out more information here.Unfortunately we currently don&#39;t offer online or home-shopping in Northern Ireland and the Republic of Ireland but our stores in Belfast &#38; Dublin look forward to welcoming you.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4196"><question_text>What additional services do you offer to help me shop?</question_text><answer id="A4287"><answer_text>We offer a number of services from home delivery to finance. Find more information here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4197"><question_text>Do you offer any guarantees on products?</question_text><answer id="A4288"><answer_text>We offer a range of guarantees on a number of product ranges. You can find out more information on the IKEA everyday quality guarantees.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4198"><question_text>Can I purchase items over the phone, for delivery or collection from store?</question_text><answer id="A4289"><answer_text>Unfortunately it is not possible to take payments over the phone, or reserve items for collection. When you purchase goods online they come directly from our distribution centre to your home.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4199"><question_text>Can I reserve an item for collection?</question_text><answer id="A4290"><answer_text>It is not possible to reserve an item in our stores; you are able to check stock availability before visiting store using our online stock checker.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4200"><question_text>Store opening times and directions?</question_text><answer id="A4291"><answer_text>Each store has their own website which includes opening times, directions and store information. Click here to choose your favourite store.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4201"><question_text>Is there parking when I get there?</question_text><answer id="A4292"><answer_text>All IKEA stores have free parking (subject to minimum spend at Southampton and Coventry).</answer_text><num_votes>1</num_votes></answer></question><question id="Q4202"><question_text>What facilities do you have for people with disabilities?</question_text><answer id="A4293"><answer_text>For our visitors with disabilities, we are pleased to offer the following services at IKEA stores: • Wheelchairs, free to use in the store. • Assisted shopping, please go to the customer information desk in store to request this. • Facilities for hearing impaired visitors</answer_text><num_votes>1</num_votes></answer></question><question id="Q4203"><question_text>Are your stores family friendly?</question_text><answer id="A4294"><answer_text>Each store supplies high chairs, organic baby food, baby food warming stations, and healthy meals for children in the restaurant, play areas and nursing areas. All our stores have a crèche facility usable for 45 minutes at a time (book in store). Bring the family we have something for everyone.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4204"><question_text>Why are items sometimes out of stock?</question_text><answer id="A4295"><answer_text>Every effort is made to maintain the availability of items shown in the catalogue, but due to popularity and supply issues, some products may not always be available. Generally, IKEA can estimate when a product should be back in stock. You can use our online stock checker to make sure items are available before you visit.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4205"><question_text>Do your stores offer home delivery or van hire?</question_text><answer id="A4296"><answer_text>Since most IKEA furniture is flat-packed, you can take your goods home today in your car and enjoy them right away. If you&#39;d prefer, IKEA can arrange home delivery at a reasonable rate, visit the home delivery desk in the Customer Service area after checkouts. We also offer a van hire service through Europcar. Find out more about the IKEA range of services we can offer.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4206"><question_text>Can you help me with assembly?</question_text><answer id="A4297"><answer_text>Yes, you can find assembly guides next to the product description online, ask in store or call us for general help or if you would like the furniture assembled you can find more information on our services page.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4207"><question_text>Can someone help me plan and design rooms?</question_text><answer id="A4298"><answer_text>Many IKEA stores offer a home decoration service if you wish to furnish an entire room or home. Our friendly co-workers will be happy to assist you in store. IKEA also have online planning tools for a range of products including storage, kitchens, wardrobes and office furniture. Our kitchen departments can also arrange a visit to your home to help design your ideal kitchen, ,a href=&#34;http://www.ikea.com/ms/en_GB/customer_service/ikea_services/kitchen_planner.html&#34;&#62;see here for more information regarding kitchen services.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4208"><question_text>I&#39;ve lost something at the store - how do I get it back?</question_text><answer id="A4299"><answer_text>For lost items, please return to the store you visited where our co-workers will be happy to help you at the customer service desk. Please note that credit cards will be destroyed after 24 hours for security purposes.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4209"><question_text>There seems to be a mistake on my receipt from the store. What should I do?</question_text><answer id="A4300"><answer_text>Please return to store with your receipt and we can investigate this for you. If you are unable to return to store please contact us.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4210"><question_text>Worldwide store locator</question_text><answer id="A4301"><answer_text>Details about IKEA stores outside of the UK can be found here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4211"><question_text>How do I buy online?</question_text><answer id="A4302"><answer_text>To find out how you can shop online please click here. Please note at present shopping online is only available to mainland England, Scotland and Wales.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4212"><question_text>Why are there products on the website that I cannot buy online?</question_text><answer id="A4303"><answer_text>The majority of the IKEA furniture range is available at Shop Online along with an increasing selection of our home accessories range. We are planning to increase the ranges available in the future. We do try to show as many items as possible online as you may wish to visit one of our stores for the item, and it will enable you to have the product details to hand before you visit. Items available to purchase online have the option “Add to basket” next to them.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4213"><question_text>Are your prices online the same as in store?</question_text><answer id="A4304"><answer_text>Shop Online product prices will normally be the same as store prices. However, occasionally promotions will mean some prices can differ.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4214"><question_text>What if I change my mind after ordering online Online?</question_text><answer id="A4305"><answer_text>It’s fine to change your mind; you are able to cancel an order, by contacting us. If you’ve already had delivery and you’ve changed your mind, simply take it to a store or request a collection. Full details can be found in the Shop Online returns policy.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4215"><question_text>Are my personal details given to third parties?</question_text><answer id="A4306"><answer_text>We sometimes need to hire other companies to help us provide our services. We limit the information we give them, to ensure this is only used for the fulfilment of your order. They are strictly monitored by IKEA in order to make certain our customer privacy is always protected.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4216"><question_text>Can I cancel an order I placed online?</question_text><answer id="A4307"><answer_text>IKEA complies fully with the Distance Selling Regulations, you may cancel at any time before delivery by contacting us with your order details, after receiving your goods we understand you need time to consider your purchase, if you would like to cancel within 14 days of receiving your items, you may take the items to your nearest store with your order receipt email or contact us for collection. This does not apply to items made to your specification. You can find more information here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4217"><question_text>Can I add to or change an existing order?</question_text><answer id="A4308"><answer_text>If you need to make a change to an existing order, please call us as soon as possible. Once your order has been confirmed any changes may delay your delivery date. To add to an order placed in store, you would need to return to store.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4218"><question_text>Can I order online and pick up from store?</question_text><answer id="A4309"><answer_text>All our online products are delivered directly from our distribution centre to your home, it is not possible to collect online purchases from store, we do not offer a product reservation service in our stores.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4219"><question_text>Can I add assembly to my order?</question_text><answer id="A4310"><answer_text>It is not possible to add assembly to your online order, you can visit your nearest store to arrange assembly or call us for more information. Additional details can be found on our services page.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4220"><question_text>What payment methods do you accept?</question_text><answer id="A4311"><answer_text>In store you can pay with all major credit and debit cards including: VISA, VISA Electron, MasterCard, Maestro, Delta, IKEA Home Card, IKEA Gift Card and cash. We do not accept cheques or American Express.To view the payment methods we accept online, please click here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4221"><question_text>How safe are my personal details and credit card information?</question_text><answer id="A4312"><answer_text>The security of our customers’ details is a number one priority for us. We work with a fully integrated and secure checkout process. All payment details are secure at all times. You can view our full privacy policy here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4222"><question_text>IKEA Home Card</question_text><answer id="A4313"><answer_text>The IKEA Home card was a payment card previously offered by IKEA. Existing holders may still use their cards in store. The card was issued by contact IKANO Financial Services. If you have any questions about your card, please contact IKANO customer service at 0871 781 3045 or via email at customerservice@ikano.net.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4223"><question_text>Do you offer Finance options or interest free credit?</question_text><answer id="A4314"><answer_text>You can read more about IKEA finance options here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4224"><question_text>When am I entitled to claim a VAT refund and what do I need to do to obtain one?</question_text><answer id="A4315"><answer_text>If you are purchasing goods in an IKEA Store you are entitled to claim a VAT refund when you are either: • Non EU resident • Customer registered for VAT in the an EU country, other than the UK. Non EU resident: If you are exporting purchases outside the EU you may be entitled to a VAT refund. If you are shipping the goods as freight please request an IKEA ‘VAT refunds for export outside the EU’ notice.If you are taking the goods with you as on board luggage, you must request a ‘TaxFreeWorldwide’ receipt.Customers registered for VAT in the EU not in UK: If you are dispatching purchases back to an EU country where you are registered for VAT, please request either an IKEA ‘VAT refunds for overseas businesses elsewhere in the EU’, or for Irish customers, ‘VAT refunds for businesses in the Republic of Ireland’. Please note that refunds can only be made to the persons who originally purchased the goods and cannot be made to any UK residents. The notices will request evidence to qualify for a refund. IKEA must receive all necessary evidence within 3 months of the date of your purchase. If you are purchasing goods online via the IKEA website to be shipped directly abroad, then you may be able to claim back the VAT on the goods (VAT cannot be claimed for the delivery charges). Your order confirmation email is your vat receipt. For more information visit www.hmrc.gov.uk</answer_text><num_votes>1</num_votes></answer></question><question id="Q4225"><question_text>Can I return items?</question_text><answer id="A4316"><answer_text>You&#39;re free to change your mind. Return unused items in their original packaging within 90 days, together with your till receipt or copy of your online order form, for a full refund. See our returns policy.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4226"><question_text>Can I return a mattress?</question_text><answer id="A4317"><answer_text>Unless faulty you may only return a mattress for a refund within 90 days if the packaging is still on the mattress and unopened. We do understand that you may need to try a mattress first to see if it’s comfortable that’s why you may exchange your mattress once within 90 days under our love it or exchange it offer.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4227"><question_text>Can I return a made to order product?</question_text><answer id="A4318"><answer_text>Made to order products cannot be cancelled at any time as these are made specifically to your order. The majority of made to order products are a selection from our kitchen worktop range. We will confirm that you have ordered a made to order product and take you through the specific terms and conditions. These products can only be returned to us if they are faulty and not fit for purpose described.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4228"><question_text>Can I return goods I have opened or assembled?</question_text><answer id="A4319"><answer_text>Items can be returned to the store with your original receipt, but should be disassembled. Depending on the condition of the items the value and method of refund would be at the discretion of the store.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4229"><question_text>Can a different account be credited with a refund?</question_text><answer id="A4320"><answer_text>Sorry. A refund has to be made to the original card used for payment. In the event that you are unable to access this account we may refund to a gift card.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4230"><question_text>Do you provide extra or replacement fittings?</question_text><answer id="A4321"><answer_text>As long as the fittings have a 6 digit code in the assembly guide, we can arrange for these to be posted directly to you free of charge. Just click here to fill out a parts request form. If you no longer have the assembly guide, copies can be found in the product description on the website, or for older products click here</answer_text><num_votes>1</num_votes></answer></question><question id="Q4231"><question_text>I’m missing part of a product I’ve just purchased.</question_text><answer id="A4322"><answer_text>Please take your receipt and copy of the assembly guide showing the piece that is missing to store and we will replace this for you, if this part has a 6 digit code on the assembly guide we can arrange for these to be posted directly to you free of charge. Just click here to fill out a parts request form.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4232"><question_text>The product I’ve purchased has a faulty or damaged part.</question_text><answer id="A4323"><answer_text>You only need to take the faulty part to store with your receipt and we will exchange this for you. Alternatively you may return the whole product for a replacement or full refund. If you damaged the item yourself and swiped your FAMILY card at the till, you may be covered by FAMILY card insurance.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4233"><question_text>Can I get help with assembly?</question_text><answer id="A4324"><answer_text>All our products come with detailed instructions, if you need more help we do have instructional videos for our most popular products here, or if you go to store you can arrange for an assembly company, click here for more information.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4234"><question_text>Missing Assembly Guide</question_text><answer id="A4325"><answer_text>Copies can be found in the product description on the website. If you are still unable to locate the assembly guide, please contact us with either the article number or if possible email pictures of the item and we will do our best to locate them for you.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4235"><question_text>Faulty items, under guarantee</question_text><answer id="A4326"><answer_text>IKEA offers a generous guarantee policy. Guarantees can be found in the back of the catalogue or by clicking here. If you do notice a problem with any product within the first year of purchase or within the full guarantee period, please return the item to store or email pictures and a description of the fault. Please include proof of the original purchase from IKEA.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4236"><question_text>Where do I find information about product recalls?</question_text><answer id="A4327"><answer_text>For information about product recalls and safety alerts please visit our press page here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4237"><question_text>Do you deliver?</question_text><answer id="A4328"><answer_text>Yes we can deliver, you can either visit one our stores where you may be able to use our home delivery service arrange next day delivery, or you may purchase online and use our online delivery service to have your items delivered directly to your home.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4238"><question_text>Can I get a faster delivery?</question_text><answer id="A4329"><answer_text>If you are ordering online, the estimated delivery date is the earliest date we can deliver as the items come from our distribution centre. If you visit store, our home delivery service may be able to offer you next day delivery.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4239"><question_text>Do you do international shipping?</question_text><answer id="A4330"><answer_text>Our online shopping service is only able to deliver items to mainland UK; however we can deliver to a shipping agent if you specify them as the delivery address when you order.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4240"><question_text>Can I choose a delivery time?</question_text><answer id="A4331"><answer_text>If you arrange our home delivery in store, they will contact you one hour before they are due to arrive, they deliver between 7am and 8pm. For online orders or orders sent from our distribution centre you can find full delivery information here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4241"><question_text>Will I be able to order online and then pick up in the store?</question_text><answer id="A4332"><answer_text>Our online orders are only able to be delivered directly from our distribution centre to your home. It is not possible to order and reserve in store.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4242"><question_text>Can I order delivery to a different name or address?</question_text><answer id="A4333"><answer_text>Yes, as long as the delivery address is in mainland UK.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4243"><question_text>Can I track my delivery?</question_text><answer id="A4334"><answer_text>If you have purchased online you will be able to use our order tracking you will need your order number, post code and the email address you gave when the order was placed. For deliveries booked in store we will agree a delivery day, then call you one hour before we are due to deliver.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4244"><question_text>Can I change my delivery date?</question_text><answer id="A4335"><answer_text>The original estimated date you receive is the earliest date we can get your order to you. It may be possible to deliver it at a slightly later date, on a day that’s more convenient to you. Please contact us as soon as possible if you require a later date.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4245"><question_text>How do I tell you about delivery restrictions?</question_text><answer id="A4336"><answer_text>If you think we may have difficulty accessing your property, please click here for more information.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4246"><question_text>Do you do next day delivery?</question_text><answer id="A4337"><answer_text>When you visit store the majority of our deliveries will be within 48 hours, and normally next day subject to availability, and the distance you live from the store.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4247"><question_text>How much does delivery cost?</question_text><answer id="A4338"><answer_text>When you shop online, you can see the cost of delivery before ordering by placing your items in the basket, adding your postcode and press calculate. For our home delivery service from store, please choose the store you wish to visit from the link on this page.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4248"><question_text>What do I do if I have something missing from my delivery?</question_text><answer id="A4339"><answer_text>You should contact the delivery company as soon as possible, their contact details will be on your delivery paperwork, alternatively you can contact us.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4249"><question_text>What is IKEA FAMILY?</question_text><answer id="A4340"><answer_text>IKEA FAMILY is the IKEA loyalty programme. IKEA FAMILY is open to everyone, and it’s free to join. With an IKEA FAMILY card you get discounts on selected home furnishing products, food products and services. We also hold member only events in-stores such as free home furnishing workshops/seminars and previews of new ranges. Find out more.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4250"><question_text>How can I become an IKEA FAMILY member?</question_text><answer id="A4341"><answer_text>It is free to sign up and you can start using the benefits the same day. You can sign up, in store, via a paper application, in one of the IKEA FAMILY kiosks or online today. You will get a temporary card on registration; your plastic card will be sent home to you within 2-4 weeks of registration, your temporary card entitles you to all the benefits until the plastic card arrives.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4251"><question_text>What do I do if I want to shop at IKEA before my card arrives?</question_text><answer id="A4342"><answer_text>You can always print out a temporary card, either online or in store at a FAMILY kioskYou need to show a card, plastic or temporary, at time of purchase to qualify for an IKEA FAMILY offer in store.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4252"><question_text>Can I add an existing purchase to my FAMILY card?</question_text><answer id="A4343"><answer_text>To qualify for any offers you need to swipe your card at the time of purchase, it is not possible to add an existing purchase at a later date.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4253"><question_text>What do I do if I have lost my card?</question_text><answer id="A4344"><answer_text>You can request a new card; in store, online via your FAMILY account or contact us. You can print out a temporary card from either your online account or in store.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4254"><question_text>How do I make changes to my FAMILY card details, or cancel my account?</question_text><answer id="A4345"><answer_text>You can update any of your details such as name, address, contact details, marketing preferences and home interests online via your FAMILY account. To cancel, simply log in and choose the option to cancel at the bottom the FAMILY account page. Alternatively you may contact us.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4255"><question_text>How do I log in to my online account?</question_text><answer id="A4346"><answer_text>You can log in here. You need to have an email address registered with us in order to access your online IKEA FAMILY account.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4256"><question_text>I’ve forgotten my email or password:</question_text><answer id="A4347"><answer_text>You can retrieve the email address attached to your account or a lost password by selecting “password help” from the log in page.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4257"><question_text>How do I sign up to a workshop, seminar or event?</question_text><answer id="A4348"><answer_text>All events are listed by store here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4258"><question_text>Can you tell me more about the free product insurance?</question_text><answer id="A4349"><answer_text>IKEA FAMILY members benefit from free product insurance, against any accidental damage on the way home or whilst assembling. The insurance is valid on any purchase and not just items with an IKEA FAMILY price. The IKEA FAMILY card must be swiped at time of purchase to insure the products. To claim on your insurance please come to store within 90 days of the date of purchase with the item, your FAMILY card and your receipt.Insurance can only be claimed in store, not by contacting Customer Services by phone, email or online. Terms and conditions.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4259"><question_text>What are the FAMILY general terms and conditions?</question_text><answer id="A4350"><answer_text>Full terms and Conditions can be found here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4260"><question_text>How is my data being used?</question_text><answer id="A4351"><answer_text>IKEA Ltd will safeguard any information provided. More information can be found here. More info can be found here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4261"><question_text>Is there credit connected to the IKEA FAMILY card?</question_text><answer id="A4352"><answer_text>No there is not credit connected to the card. IKEA does not currently offer a credit card.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4262"><question_text>Is IKEA FAMILY card the same as IKEA Home Card?</question_text><answer id="A4353"><answer_text>No, the IKEA Home Card is a credit card previously offered to IKEA customers. These credit cards are no longer issued, but are still valid as payment in-store.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4263"><question_text>Who do I contact about my IKEA Home Card?</question_text><answer id="A4354"><answer_text>The IKEA Home card is issued by IKANO Financial Services. If you have any questions about your card, contact IKANO customer service at 0871 781 3045 or via email at customerservice@ikano.net.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4264"><question_text>What is the IKEA catalogue?</question_text><answer id="A4355"><answer_text>The IKEA catalogue is produced in 30 languages and more than 210 million copies and delivered to homes in 44 countries. The catalogue offers more than just a glimpse at the diverse IKEA product range. You&#39;ll discover new affordable solutions and creative approaches to help inspire home furnishing ideas for better living. For the best possible ideas and inspiration the online catalogue comes with augmented reality.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4265"><question_text>How can I get a copy of the IKEA catalogue?</question_text><answer id="A4356"><answer_text>The IKEA catalogue is mass-distributed annually in the area around each IKEA store. If you did not receive this year&#39;s catalogue, stop by the IKEA store near you for a free copy. Alternatively, you can view the whole catalogue online Download our latest catalogue, or view it on the IKEA catalogue app for your smart phone available from your app store. Unfortunately we are unable to post copies.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4266"><question_text>When does the new catalogue come out?</question_text><answer id="A4357"><answer_text>The annual catalogue is distributed in August/September of each year and is valid for a full year. Prices are guaranteed not to increase while the catalogue is valid. In it you can discover our furnishings, accessories and room settings along with detailed information on materials, colours, sizes, product care, prices and additional content accessible through your mobile phone. That way you can plan your next visit to IKEA all from the comfort of your own home!</answer_text><num_votes>1</num_votes></answer></question><question id="Q4267"><question_text>How environmentally friendly is the IKEA catalogue?</question_text><answer id="A4358"><answer_text>Our catalogues are printed on totally chlorine-free paper and contain at least 10-15% post-consumer waste. No rainforest or old-growth fibres are used. The pre-press process is 100% digital, which means no film is used and none of the associated chemicals. No optical brighteners are used on the paper.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4268"><question_text>What settings or software do I need on my computer to view the IKEA site?</question_text><answer id="A4359"><answer_text>In order to view the IKEA site you need a normal modern web browser like Chrome, Firefox, Internet Explorer or Safari.Both Chrome and Firefox are automatically updated on a frequent basis and IKEA recommend users to always upgrade.For Internet Explorer we support version 8 to 11, and for Safari we support version 5 to 7.If you are using a Smartphone or tablet with Android, both the Chrome browser and the built in Android browser will work since Android version 2.3.If you are using an iPhone or iPad with Safari we support version 5 to 7.The IKEA site is built to support a wide range of browsers and other modern browsers than those mentioned above should work fine too, even if we are not actively testing them in our development.One exception that we know of, is that Internet Explorer 7 and earlier will not support all features.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4269"><question_text>What information is collected about me when I visit the site?</question_text><answer id="A4360"><answer_text>We do not require any information to obtain access to any part of our site, unless specifically stated. We may ask for specific information in order to provide a service to you, such as our FAMILY card. Information requested may include name, title, company, address, e-mail address, and phone number. We do anonymously track traffic patterns using cookies, in order to measure site performance and make improvements. Cookies are small pieces of information stored on your computer that are read by the browser.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4270"><question_text>Can I find all IKEA products on this site?</question_text><answer id="A4361"><answer_text>This site features hundreds of IKEA products as a way of demonstrating the breadth and depth of our product range; however, this is only a small portion of IKEA’s complete product range. Each store carries a much larger selection. Be sure to visit your local IKEA store for a look at our full selection.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4271"><question_text>I’ve forgotten my account email or password</question_text><answer id="A4362"><answer_text>You can retrieve the email address attached to your account or a lost password by selecting “password help” from the log in page.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4272"><question_text>Who owns the IKEA concept?</question_text><answer id="A4363"><answer_text>IKEA retailing, with its Swedish roots, is based on a franchise system. Inter IKEA Systems B.V., located in Delft, The Netherlands, is the owner and franchisor of the IKEA Concept. IKEA stores are operated by a number of different franchisees in 29 countries.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4273"><question_text>Can I distribute IKEA products?</question_text><answer id="A4364"><answer_text>The IKEA experience is more than just products, it is a retail concept. For the concept to work, it is necessary to have all aspects in place. Therefore, IKEA products are sold only in IKEA stores franchised by Inter IKEA Systems B.V.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4274"><question_text>How can I become a franchisee?</question_text><answer id="A4365"><answer_text>IKEA products are sold solely in stores operating the IKEA Retail System--franchised by Inter IKEA Systems B.V. of The Netherlands. Franchises are granted by Inter IKEA Systems B.V. as part of a detailed expansion plan. Serious applicants are carefully researched and evaluated and franchises are granted only to companies and/or individuals with strong financial backing and a proven record in retail. Please visit our franchisor site for more information.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4275"><question_text>What is the IKEA Group?</question_text><answer id="A4366"><answer_text>The IKEA Group is a private group of companies owned by a charitable foundation in The Netherlands. The IKEA Group is active in developing, purchasing, distributing and selling IKEA products. The IKEA group is the biggest group of franchisees operating over 100 IKEA stores. The Management Services to the IKEA Group are provided by IKEA International A/S in Humlebaek, Denmark.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4276"><question_text>What is the IKEA business idea?</question_text><answer id="A4367"><answer_text>The IKEA business idea is: &#34;We shall offer a wide range of well-designed, functional home furnishing products at prices so low that as many people as possible will be able to afford them.&#34; More information about the IKEA group can be found here.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4277"><question_text>How can I find out about job opportunities within IKEA?</question_text><answer id="A4368"><answer_text>If you are out-going, dedicated, customer-service orientated and interested in working as part of a team, contact the IKEA store near you for possible openings. It is also possible to view openings at your local store by visiting the job section within our website.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4278"><question_text>How does IKEA approach environmental issues?</question_text><answer id="A4369"><answer_text>We&#39;re working to create a better everyday life for the many people. This includes doing what we can to help create a world where we take better care of our environment. You can find out more information in the People and Planet section of the website.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4279"><question_text>Where are IKEA products manufactured</question_text><answer id="A4370"><answer_text>IKEA has more than 1200 furniture suppliers around the world as well as 100 food suppliers and 275 suppliers of transport. The five countries that supply most goods and services to IKEA are China, Poland, Italy, Germany and Sweden. The profile of our well-designed and high quality range is distinctively Swedish/Scandinavian. The low price is literally built into the production and the flat packs facilitate a rational distribution, self-service and immediate take-away.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4280"><question_text>What is your registered UK business address and VAT number?</question_text><answer id="A4371"><answer_text>IKEA Limited is a company registered in England with its registered office at Witan Gate House 500-600 Witan Gate West Milton Keynes MK9 1SH and company number 01986283. Our VAT number is 527773320. IKEA Limited is licensed to sell under the IKEA brand name by Inter IKEA Systems B.V., a company registered in the Netherlands.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4281"><question_text>Can I use my gift card online?</question_text><answer id="A4372"><answer_text>IKEA Gift cards can be used to make a purchase online as long as they have a scratch off pin number on the back of the card, all cards issued after October 2013 will have this pin number.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4282"><question_text>How long is my gift card valid for?</question_text><answer id="A4373"><answer_text>Gift cards have no expiry date.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4283"><question_text>Can I use gift cards in other Countries?</question_text><answer id="A4374"><answer_text>Please see here for a list of countries that accept UK Gift Cards.</answer_text><num_votes>1</num_votes></answer></question><question id="Q4284"><question_text>How do I purchase a gift card?</question_text><answer id="A4375"><answer_text>Gift cards may be purchased in store or online.</answer_text><num_votes>1</num_votes></answer></question></lecture></course>
